{"module": "study.py", "name": "Study_2:0", "notes": "", "sol_bodies": ["    return 'ho' * (800 + 1) + 'o' * (100 * 2 - 1)"], "sol_header": "def sol():", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string with 1000 'o's, 100 pairs of adjacent 'o's and 801 copies of 'ho'.\"\"\"", "weight": 1.0, "sat": "def sat(s: str):\n    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801", "input": "def sat(s: str):\n    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801", "target": ""}
{"module": "study.py", "name": "Study_4:0", "notes": "", "sol_bodies": ["    return list(range(10 // 2)) * 2"], "sol_header": "def sol():", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of length 10 where the fourth element occurs exactly twice.\"\"\"", "weight": 1.0, "sat": "def sat(li: List[int]):\n    return len(li) == 10 and li.count(li[3]) == 2", "input": "def sat(li: List[int]):\n    return len(li) == 10 and li.count(li[3]) == 2", "target": ""}
{"module": "study.py", "name": "Study_6:0", "notes": "", "sol_bodies": ["    return 4 + 10 ** 10 + 123 - 10 ** 10 % 123"], "sol_header": "def sol():", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer greater than 10^10 which is 4 mod 123.\"\"\"", "weight": 1.0, "sat": "def sat(i: int):\n    return i % 123 == 4 and i > 10 ** 10", "input": "def sat(i: int):\n    return i % 123 == 4 and i > 10 ** 10", "target": ""}
{"module": "study.py", "name": "Study_8:0", "notes": "", "sol_bodies": ["    return [''] * 1235 + ['a']"], "sol_header": "def sol():", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find a list of more than 1235 strings such that the 1234th string is a proper substring of the 1235th.\"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str]):\n    return ls[1234] in ls[1235] and ls[1234] != ls[1235]", "input": "def sat(ls: List[str]):\n    return ls[1234] in ls[1235] and ls[1234] != ls[1235]", "target": ""}
{"module": "study.py", "name": "Study_10:0", "notes": "", "sol_bodies": ["    s = str(8 ** 1818)\n    return next(s[i: i + le]\n                for le in range(12, len(s) + 1)\n                for i in range(len(s) - le + 1)\n                if s[i: i + le] == s[i: i + le][::-1]\n                )"], "sol_header": "def sol():", "ans_type": "str", "sol_docstring": "    \"\"\"Find a palindrome of length greater than 11 in the decimal representation of 8^1818.\"\"\"", "weight": 1.0, "sat": "def sat(s: str):\n    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11", "input": "def sat(s: str):\n    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11", "target": ""}
{"module": "study.py", "name": "Study_12:0", "notes": "", "sol_bodies": ["    return [9 - 4, 4] * (1000 // 2)"], "sol_header": "def sol():", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of 1,000 integers where every two adjacent integers sum to 9, and where the first\n    integer plus 4 is 9.\"\"\"", "weight": 1.0, "sat": "def sat(li: List[int]):\n    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000", "input": "def sat(li: List[int]):\n    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000", "target": ""}
{"module": "study.py", "name": "Study_14:0", "notes": "", "sol_bodies": ["    return [1] * 20"], "sol_header": "def sol():", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of integers such that the sum of the first i integers is i, for i=0, 1, 2, ..., 19.\"\"\"", "weight": 1.0, "sat": "def sat(li: List[int]):\n    return all([sum(li[:i]) == i for i in range(20)])", "input": "def sat(li: List[int]):\n    return all([sum(li[:i]) == i for i in range(20)])", "target": ""}
{"module": "study.py", "name": "Study_16:0", "notes": "", "sol_bodies": ["    return str(4.5 - len(str(4.5)))"], "sol_header": "def sol():", "ans_type": "str", "sol_docstring": "    \"\"\"Find a real number such that when you add the length of its decimal representation to it, you get 4.5.\n    Your answer should be the string form of the number in its decimal representation.\"\"\"", "weight": 1.0, "sat": "def sat(s: str):\n    return float(s) + len(s) == 4.5", "input": "def sat(s: str):\n    return float(s) + len(s) == 4.5", "target": ""}
{"module": "study.py", "name": "Study_18:0", "notes": "", "sol_bodies": ["    seen = set()\n    ans = []\n    for s in 'berlin berger linber linger gerber gerlin'.split():\n        t = s[:3]\n        if t not in seen:\n            ans.append(t)\n            seen.add(t)\n    return ans"], "sol_header": "def sol():", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of strings that when you combine them in all pairwise combinations gives the six strings:\n    'berlin', 'berger', 'linber', 'linger', 'gerber', 'gerlin'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str]):\n    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()", "input": "def sat(ls: List[str]):\n    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()", "target": ""}
{"module": "study.py", "name": "Study_20:0", "notes": "A more interesting version of this puzzle with a length constraint is ShortIntegerPath in graphs.py", "sol_bodies": ["    return [1, 3, 4, 12, 13, 14, 42, 126, 127]"], "sol_header": "def sol():", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list of integers, starting with 0 and ending with 128, such that each integer either differs from\n    the previous one by one or is thrice the previous one.\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int]):\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))", "input": "def sat(li: List[int]):\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))", "target": ""}
{"module": "study.py", "name": "Study_22:0", "notes": "", "sol_bodies": ["    return \"\"\"abacadaeaaaaaaaaaa\"\"\""], "sol_header": "def sol():", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string s containing exactly five distinct characters which also contains as a substring every other\n    character of s (e.g., if the string s were 'parrotfish' every other character would be 'profs').\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str):\n    return s[::2] in s and len(set(s)) == 5", "input": "def sat(s: str):\n    return s[::2] in s and len(set(s)) == 5", "target": ""}
{"module": "study.py", "name": "Study_24:0", "notes": "", "sol_bodies": ["    return [17] * 3 + [3] * 2"], "sol_header": "def sol():", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of integers with exactly three occurrences of seventeen and at least two occurrences of three.\"\"\"", "weight": 1.0, "sat": "def sat(li: List[int]):\n    return li.count(17) == 3 and li.count(3) >= 2", "input": "def sat(li: List[int]):\n    return li.count(17) == 3 and li.count(3) >= 2", "target": ""}
{"module": "study.py", "name": "Study_26:0", "notes": "", "sol_bodies": ["    return [str(8 ** 88)[i:i + 8] for i in range(0, len(str(8 ** 88)), 8)]"], "sol_header": "def sol():", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Divide the decimal representation of 8^88 up into strings of length eight.\"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str]):\n    return \"\".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)", "input": "def sat(ls: List[str]):\n    return \"\".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)", "target": ""}
{"module": "study.py", "name": "Study_28:0", "notes": "9/15/2021: updated to a list since sets were removed from puzzle formats", "sol_bodies": ["    return list(range(0, 1000, 10))"], "sol_header": "def sol():", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of one hundred integers between 0 and 999 which all differ by at least ten from one another.\"\"\"", "weight": 1.0, "sat": "def sat(li: List[int]):\n    return all(i in range(1000) and abs(i - j) >= 10 for i in li for j in li if i != j) and len(set(li)) == 100", "input": "def sat(li: List[int]):\n    return all(i in range(1000) and abs(i - j) >= 10 for i in li for j in li if i != j) and len(set(li)) == 100", "target": ""}
{"module": "study.py", "name": "Study_30:0", "notes": "", "sol_bodies": ["    return sorted(range(1000), key=lambda n: 123 * n % 1000)[:21]", "    return list(range(1000))[::8][::-1]"], "sol_header": "def sol():", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define f(n) to be the residue of 123 times n mod 1000. Find a list of integers such that the first twenty one\n    are between 0 and 999, inclusive, and are strictly increasing in terms of f(n).\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int]):\n    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])", "input": "def sat(li: List[int]):\n    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])", "target": ""}
{"module": "classic_puzzles.py", "name": "TowersOfHanoi:0", "notes": "[Towers of Hanoi](https://en.wikipedia.org/w/index.php?title=Tower_of_Hanoi)\n\nIn this classic version one must move all 8 disks from the first to third peg.", "sol_bodies": ["    def helper(m, i, j):\n        if m == 0:\n            return []\n        k = 3 - i - j\n        return helper(m - 1, i, k) + [[i, j]] + helper(m - 1, k, j)\n\n    return helper(8, 0, 2)"], "sol_header": "def sol():", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Eight disks of sizes 1-8 are stacked on three towers, with each tower having disks in order of largest to\n    smallest. Move [i, j] corresponds to taking the smallest disk off tower i and putting it on tower j, and it\n    is legal as long as the towers remain in sorted order. Find a sequence of moves that moves all the disks\n    from the first to last towers.\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[List[int]]):\n    rods = ([8, 7, 6, 5, 4, 3, 2, 1], [], [])\n    for [i, j] in moves:\n        rods[j].append(rods[i].pop())\n        assert rods[j][-1] == min(rods[j]), \"larger disk on top of smaller disk\"\n    return rods[0] == rods[1] == []", "input": "def sat(moves: List[List[int]]):\n    rods = ([8, 7, 6, 5, 4, 3, 2, 1], [], [])\n    for [i, j] in moves:\n        rods[j].append(rods[i].pop())\n        assert rods[j][-1] == min(rods[j]), \"larger disk on top of smaller disk\"\n    return rods[0] == rods[1] == []", "target": ""}
{"module": "classic_puzzles.py", "name": "TowersOfHanoiArbitrary:0", "notes": "[Towers of Hanoi](https://en.wikipedia.org/w/index.php?title=Tower_of_Hanoi)\n\nIn this version one must transform a given source state to a target state.", "sol_bodies": ["    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"], "sol_header": "def sol(source=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[List[int]], source=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target", "input": "def sat(moves: List[List[int]], source=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target", "target": ""}
{"module": "classic_puzzles.py", "name": "TowersOfHanoiArbitrary:1", "notes": "[Towers of Hanoi](https://en.wikipedia.org/w/index.php?title=Tower_of_Hanoi)\n\nIn this version one must transform a given source state to a target state.", "sol_bodies": ["    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"], "sol_header": "def sol(source=[[1, 3, 5], [2, 8, 14], [0, 4, 6, 7, 9, 10, 11, 12, 13]], target=[[5, 12], [0, 3, 4, 7, 10, 11], [1, 2, 6, 8, 9, 13, 14]]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[List[int]], source=[[1, 3, 5], [2, 8, 14], [0, 4, 6, 7, 9, 10, 11, 12, 13]], target=[[5, 12], [0, 3, 4, 7, 10, 11], [1, 2, 6, 8, 9, 13, 14]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target", "input": "def sat(moves: List[List[int]], source=[[1, 3, 5], [2, 8, 14], [0, 4, 6, 7, 9, 10, 11, 12, 13]], target=[[5, 12], [0, 3, 4, 7, 10, 11], [1, 2, 6, 8, 9, 13, 14]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target", "target": ""}
{"module": "classic_puzzles.py", "name": "TowersOfHanoiArbitrary:2", "notes": "[Towers of Hanoi](https://en.wikipedia.org/w/index.php?title=Tower_of_Hanoi)\n\nIn this version one must transform a given source state to a target state.", "sol_bodies": ["    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"], "sol_header": "def sol(source=[[0, 1, 6, 7, 8, 9, 14, 16], [5, 15], [2, 3, 4, 10, 11, 12, 13]], target=[[1, 2, 4, 5, 13], [3, 6, 11, 12, 14], [0, 7, 8, 9, 10, 15, 16]]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[List[int]], source=[[0, 1, 6, 7, 8, 9, 14, 16], [5, 15], [2, 3, 4, 10, 11, 12, 13]], target=[[1, 2, 4, 5, 13], [3, 6, 11, 12, 14], [0, 7, 8, 9, 10, 15, 16]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target", "input": "def sat(moves: List[List[int]], source=[[0, 1, 6, 7, 8, 9, 14, 16], [5, 15], [2, 3, 4, 10, 11, 12, 13]], target=[[1, 2, 4, 5, 13], [3, 6, 11, 12, 14], [0, 7, 8, 9, 10, 15, 16]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target", "target": ""}
{"module": "classic_puzzles.py", "name": "TowersOfHanoiArbitrary:3", "notes": "[Towers of Hanoi](https://en.wikipedia.org/w/index.php?title=Tower_of_Hanoi)\n\nIn this version one must transform a given source state to a target state.", "sol_bodies": ["    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"], "sol_header": "def sol(source=[[2, 11, 12, 16], [1, 3, 6, 8, 9, 10, 13], [0, 4, 5, 7, 14, 15]], target=[[0, 2, 3, 5, 7, 8, 14, 16], [9, 11, 12, 13, 15], [1, 4, 6, 10]]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[List[int]], source=[[2, 11, 12, 16], [1, 3, 6, 8, 9, 10, 13], [0, 4, 5, 7, 14, 15]], target=[[0, 2, 3, 5, 7, 8, 14, 16], [9, 11, 12, 13, 15], [1, 4, 6, 10]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target", "input": "def sat(moves: List[List[int]], source=[[2, 11, 12, 16], [1, 3, 6, 8, 9, 10, 13], [0, 4, 5, 7, 14, 15]], target=[[0, 2, 3, 5, 7, 8, 14, 16], [9, 11, 12, 13, 15], [1, 4, 6, 10]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target", "target": ""}
{"module": "classic_puzzles.py", "name": "TowersOfHanoiArbitrary:4", "notes": "[Towers of Hanoi](https://en.wikipedia.org/w/index.php?title=Tower_of_Hanoi)\n\nIn this version one must transform a given source state to a target state.", "sol_bodies": ["    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"], "sol_header": "def sol(source=[[5, 6], [1, 2, 4], [0, 3]], target=[[2, 3, 4, 6], [0, 1], [5]]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[List[int]], source=[[5, 6], [1, 2, 4], [0, 3]], target=[[2, 3, 4, 6], [0, 1], [5]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target", "input": "def sat(moves: List[List[int]], source=[[5, 6], [1, 2, 4], [0, 3]], target=[[2, 3, 4, 6], [0, 1], [5]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target", "target": ""}
{"module": "classic_puzzles.py", "name": "LongestMonotonicSubstring:0", "notes": "This is a form of the classic\n[Longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) problem\nwhere the goal is to find a substring with characters in sorted order.", "sol_bodies": ["    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"], "sol_header": "def sol(length=13, s=\"Dynamic programming solves this puzzle!!!\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], length=13, s=\"Dynamic programming solves this puzzle!!!\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))", "input": "def sat(x: List[int], length=13, s=\"Dynamic programming solves this puzzle!!!\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))", "target": ""}
{"module": "classic_puzzles.py", "name": "LongestMonotonicSubstring:1", "notes": "This is a form of the classic\n[Longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) problem\nwhere the goal is to find a substring with characters in sorted order.", "sol_bodies": ["    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"], "sol_header": "def sol(length=193, s=\"    !!\\\"\\\"\\\"#$$%&&')''((()!))****X**++,,,,---...///0111114445556888::::;s;;<<==,=>>>>ABBBBBCDEEEEEEEFGHIIKKKKLMNOOPPPQQQRRRRASUUUVVVWWXXZZZ[]]]!``aEaabbbccccPcdeeeeefghjjjjkkkllmmooooKpppppqsttwt'$ww=wLwwyyyyzz{\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], length=193, s=\"    !!\\\"\\\"\\\"#$$%&&')''((()!))****X**++,,,,---...///0111114445556888::::;s;;<<==,=>>>>ABBBBBCDEEEEEEEFGHIIKKKKLMNOOPPPQQQRRRRASUUUVVVWWXXZZZ[]]]!``aEaabbbccccPcdeeeeefghjjjjkkkllmmooooKpppppqsttwt'$ww=wLwwyyyyzz{\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))", "input": "def sat(x: List[int], length=193, s=\"    !!\\\"\\\"\\\"#$$%&&')''((()!))****X**++,,,,---...///0111114445556888::::;s;;<<==,=>>>>ABBBBBCDEEEEEEEFGHIIKKKKLMNOOPPPQQQRRRRASUUUVVVWWXXZZZ[]]]!``aEaabbbccccPcdeeeeefghjjjjkkkllmmooooKpppppqsttwt'$ww=wLwwyyyyzz{\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))", "target": ""}
{"module": "classic_puzzles.py", "name": "LongestMonotonicSubstring:2", "notes": "This is a form of the classic\n[Longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) problem\nwhere the goal is to find a substring with characters in sorted order.", "sol_bodies": ["    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"], "sol_header": "def sol(length=737, s=\"    _   !m!!!!!!!!!!!V!\\\"=\\\"\\\"\\\"\\\"\\\"l#####$$r$$$$$$$$$%%%%%&&&&&&y&''''''@'''''<(((())))))******+++++++p,,,,,!,-----w-----o-....,.......//////D000000000000111111111222222,23h33c33334444444'4455555555566666R6@9777777T7888888-8994999999999::::::::::;;;;;;;P;;;<<<:<<^<)<<sn<<<====u=*=>>>>>>>>>???A?j??8??.?@@O@@@@@@ArAA&ABBBBBBBBBCCCCCDDDEEEEEEEEE%E(EEEEEFF!FFG-GGGGGGGGHHCHHHIGIsIIIInIIIIJJJRJFJJKKKKKKa0K<KKLL.LLLLLLMMMnMMM_MMMNNNONNOOOOOPPPP4LPPPPQQ\\\\QQQbQQQ7QQRRRRR\\\"RRSSSSSSTTgTTTTUUtUUUUUVVVVVVVVVVVqVVVMWWRWWWWWWWW%XXXXXXXXXXYYYYYZZZZZZZZZ2y[S[[[I[[[[\\\\$g\\\"\\\\\\\\\\\\\\\\T]]]]]]]]]]^^o^^______________`?&`I`y````aaaaaabbbbcccccc3ddddIu;L*dddeeee#eee]ffff1f]=fffffffffgggghhxhhhhhhiigiiiiiiiDiiCiiiijLjjIljjjjjjjkklllllmmmmJymmmmnnnnMnnnnnnoooiobooXoopppppqy5qqqdqqrrIrrrrJrssssssssTsstt'ttttZttt@tttuluuuuu0uuuvvxvvvv\\\\vv3vvvvwwwwwwba.wwx4xxxxxxxxxxxxxJyyyyyyyyyyzzzzzzzz{{{{{{{{\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], length=737, s=\"    _   !m!!!!!!!!!!!V!\\\"=\\\"\\\"\\\"\\\"\\\"l#####$$r$$$$$$$$$%%%%%&&&&&&y&''''''@'''''<(((())))))******+++++++p,,,,,!,-----w-----o-....,.......//////D000000000000111111111222222,23h33c33334444444'4455555555566666R6@9777777T7888888-8994999999999::::::::::;;;;;;;P;;;<<<:<<^<)<<sn<<<====u=*=>>>>>>>>>???A?j??8??.?@@O@@@@@@ArAA&ABBBBBBBBBCCCCCDDDEEEEEEEEE%E(EEEEEFF!FFG-GGGGGGGGHHCHHHIGIsIIIInIIIIJJJRJFJJKKKKKKa0K<KKLL.LLLLLLMMMnMMM_MMMNNNONNOOOOOPPPP4LPPPPQQ\\\\QQQbQQQ7QQRRRRR\\\"RRSSSSSSTTgTTTTUUtUUUUUVVVVVVVVVVVqVVVMWWRWWWWWWWW%XXXXXXXXXXYYYYYZZZZZZZZZ2y[S[[[I[[[[\\\\$g\\\"\\\\\\\\\\\\\\\\T]]]]]]]]]]^^o^^______________`?&`I`y````aaaaaabbbbcccccc3ddddIu;L*dddeeee#eee]ffff1f]=fffffffffgggghhxhhhhhhiigiiiiiiiDiiCiiiijLjjIljjjjjjjkklllllmmmmJymmmmnnnnMnnnnnnoooiobooXoopppppqy5qqqdqqrrIrrrrJrssssssssTsstt'ttttZttt@tttuluuuuu0uuuvvxvvvv\\\\vv3vvvvwwwwwwba.wwx4xxxxxxxxxxxxxJyyyyyyyyyyzzzzzzzz{{{{{{{{\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))", "input": "def sat(x: List[int], length=737, s=\"    _   !m!!!!!!!!!!!V!\\\"=\\\"\\\"\\\"\\\"\\\"l#####$$r$$$$$$$$$%%%%%&&&&&&y&''''''@'''''<(((())))))******+++++++p,,,,,!,-----w-----o-....,.......//////D000000000000111111111222222,23h33c33334444444'4455555555566666R6@9777777T7888888-8994999999999::::::::::;;;;;;;P;;;<<<:<<^<)<<sn<<<====u=*=>>>>>>>>>???A?j??8??.?@@O@@@@@@ArAA&ABBBBBBBBBCCCCCDDDEEEEEEEEE%E(EEEEEFF!FFG-GGGGGGGGHHCHHHIGIsIIIInIIIIJJJRJFJJKKKKKKa0K<KKLL.LLLLLLMMMnMMM_MMMNNNONNOOOOOPPPP4LPPPPQQ\\\\QQQbQQQ7QQRRRRR\\\"RRSSSSSSTTgTTTTUUtUUUUUVVVVVVVVVVVqVVVMWWRWWWWWWWW%XXXXXXXXXXYYYYYZZZZZZZZZ2y[S[[[I[[[[\\\\$g\\\"\\\\\\\\\\\\\\\\T]]]]]]]]]]^^o^^______________`?&`I`y````aaaaaabbbbcccccc3ddddIu;L*dddeeee#eee]ffff1f]=fffffffffgggghhxhhhhhhiigiiiiiiiDiiCiiiijLjjIljjjjjjjkklllllmmmmJymmmmnnnnMnnnnnnoooiobooXoopppppqy5qqqdqqrrIrrrrJrssssssssTsstt'ttttZttt@tttuluuuuu0uuuvvxvvvv\\\\vv3vvvvwwwwwwba.wwx4xxxxxxxxxxxxxJyyyyyyyyyyzzzzzzzz{{{{{{{{\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))", "target": ""}
{"module": "classic_puzzles.py", "name": "LongestMonotonicSubstring:3", "notes": "This is a form of the classic\n[Longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) problem\nwhere the goal is to find a substring with characters in sorted order.", "sol_bodies": ["    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"], "sol_header": "def sol(length=0, s=\"\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], length=0, s=\"\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))", "input": "def sat(x: List[int], length=0, s=\"\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))", "target": ""}
{"module": "classic_puzzles.py", "name": "LongestMonotonicSubstring:4", "notes": "This is a form of the classic\n[Longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) problem\nwhere the goal is to find a substring with characters in sorted order.", "sol_bodies": ["    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"], "sol_header": "def sol(length=1, s=\"xwV\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], length=1, s=\"xwV\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))", "input": "def sat(x: List[int], length=1, s=\"xwV\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))", "target": ""}
{"module": "classic_puzzles.py", "name": "LongestMonotonicSubstringTricky:0", "notes": "The same as the above problem, but with a twist!", "sol_bodies": ["    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"], "sol_header": "def sol(length=20, s=\"Dynamic programming solves this classic job-interview puzzle!!!\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], length=20, s=\"Dynamic programming solves this classic job-interview puzzle!!!\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "input": "def sat(x: List[int], length=20, s=\"Dynamic programming solves this classic job-interview puzzle!!!\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "target": ""}
{"module": "classic_puzzles.py", "name": "LongestMonotonicSubstringTricky:1", "notes": "The same as the above problem, but with a twist!", "sol_bodies": ["    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"], "sol_header": "def sol(length=535, s=\"RRRS  S !L!eSSSS!TTT+!TTTUU!!UU!UU\\\"U\\\"\\\"\\\"VVV\\\"\\\"\\\"VK#WW##gfW##X##6$$X$XX@$XXP%%%YY%+YY%&ZZ)%ZZ&#Z&[&[[[[\\\\'\\\\\\\\]\\\\\\\\]''']]']]]^^(^R^((^))^)^^*^_*_L____**;**_``*```++`+`+[+++``,m,,`,,-aa@aa[a-arb-b--b(vzbb-.b.6.ccc.cKcc.cc//c/cc//dddddd/0deeeee000e0f0ff0f01ff11f1<1gg;g12R2g22233gg33g333g3g445555566ghhh66799h9hhh9h999iEii/iYi::i::j:jvv:;;;;jj<j<<k===kkkk===ll=l=l>>l>ll0>l>m>m@mmm??0m^,?nn???n?sn@@oo@DobAAooAo7AAppppBqC$qqqqCCCCqqqqrDrrrrrrrDbrsDDDEsEs9asssfttEtttEEEtEEtFFtuuLFuuuFFFvF0FGvGGGvvvvRwwwwxGHxHHHx+HIxxIexxIIyyyPCyyyII,yIyyIzIJzJJQJzKzzKz{KK{{{{{[K{K{KK{?{KLLLLLLLMMM>NNNNNOOOOOOOOPPPQQQQQQQRRR\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], length=535, s=\"RRRS  S !L!eSSSS!TTT+!TTTUU!!UU!UU\\\"U\\\"\\\"\\\"VVV\\\"\\\"\\\"VK#WW##gfW##X##6$$X$XX@$XXP%%%YY%+YY%&ZZ)%ZZ&#Z&[&[[[[\\\\'\\\\\\\\]\\\\\\\\]''']]']]]^^(^R^((^))^)^^*^_*_L____**;**_``*```++`+`+[+++``,m,,`,,-aa@aa[a-arb-b--b(vzbb-.b.6.ccc.cKcc.cc//c/cc//dddddd/0deeeee000e0f0ff0f01ff11f1<1gg;g12R2g22233gg33g333g3g445555566ghhh66799h9hhh9h999iEii/iYi::i::j:jvv:;;;;jj<j<<k===kkkk===ll=l=l>>l>ll0>l>m>m@mmm??0m^,?nn???n?sn@@oo@DobAAooAo7AAppppBqC$qqqqCCCCqqqqrDrrrrrrrDbrsDDDEsEs9asssfttEtttEEEtEEtFFtuuLFuuuFFFvF0FGvGGGvvvvRwwwwxGHxHHHx+HIxxIexxIIyyyPCyyyII,yIyyIzIJzJJQJzKzzKz{KK{{{{{[K{K{KK{?{KLLLLLLLMMM>NNNNNOOOOOOOOPPPQQQQQQQRRR\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "input": "def sat(x: List[int], length=535, s=\"RRRS  S !L!eSSSS!TTT+!TTTUU!!UU!UU\\\"U\\\"\\\"\\\"VVV\\\"\\\"\\\"VK#WW##gfW##X##6$$X$XX@$XXP%%%YY%+YY%&ZZ)%ZZ&#Z&[&[[[[\\\\'\\\\\\\\]\\\\\\\\]''']]']]]^^(^R^((^))^)^^*^_*_L____**;**_``*```++`+`+[+++``,m,,`,,-aa@aa[a-arb-b--b(vzbb-.b.6.ccc.cKcc.cc//c/cc//dddddd/0deeeee000e0f0ff0f01ff11f1<1gg;g12R2g22233gg33g333g3g445555566ghhh66799h9hhh9h999iEii/iYi::i::j:jvv:;;;;jj<j<<k===kkkk===ll=l=l>>l>ll0>l>m>m@mmm??0m^,?nn???n?sn@@oo@DobAAooAo7AAppppBqC$qqqqCCCCqqqqrDrrrrrrrDbrsDDDEsEs9asssfttEtttEEEtEEtFFtuuLFuuuFFFvF0FGvGGGvvvvRwwwwxGHxHHHx+HIxxIexxIIyyyPCyyyII,yIyyIzIJzJJQJzKzzKz{KK{{{{{[K{K{KK{?{KLLLLLLLMMM>NNNNNOOOOOOOOPPPQQQQQQQRRR\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "target": ""}
{"module": "classic_puzzles.py", "name": "LongestMonotonicSubstringTricky:2", "notes": "The same as the above problem, but with a twist!", "sol_bodies": ["    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"], "sol_header": "def sol(length=1, s=\"O!A{SeKv\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], length=1, s=\"O!A{SeKv\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "input": "def sat(x: List[int], length=1, s=\"O!A{SeKv\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "target": ""}
{"module": "classic_puzzles.py", "name": "LongestMonotonicSubstringTricky:3", "notes": "The same as the above problem, but with a twist!", "sol_bodies": ["    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"], "sol_header": "def sol(length=61, s=\" OW##P%T'UW)X+X-YY]^_`bd/044e5egk7lm779:<m?D@ADnnpDEFIpNNOqqwxx\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], length=61, s=\" OW##P%T'UW)X+X-YY]^_`bd/044e5egk7lm779:<m?D@ADnnpDEFIpNNOqqwxx\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "input": "def sat(x: List[int], length=61, s=\" OW##P%T'UW)X+X-YY]^_`bd/044e5egk7lm779:<m?D@ADnnpDEFIpNNOqqwxx\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "target": ""}
{"module": "classic_puzzles.py", "name": "LongestMonotonicSubstringTricky:4", "notes": "The same as the above problem, but with a twist!", "sol_bodies": ["    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"], "sol_header": "def sol(length=19, s=\"1>C>DmJh5\\\"Ju,\\\"Q8zJ_u-O-VfnVTZ?W'm=jq.\\\\l&%m$cU.nqv2\\\\**.o\\\">]FZ5owil>l*kIM wcLd<*UX`\\\"_u'DC3R$8wr;jT]CW\\\"F$QKeRPMzZY'U42&Km dRr8b$T3x)w2v,_k(dR,F:`=c$MjE_Kf/KCXFg^ueiO.U%S8_](:GF;`2`^O%eAqSRAHW0dYg5!u<ZV@usa`-<<ET@xZ)&<6=ogIhp9jJ/`$/_jEa-N$oZVT6#]^]x5u!$ Xk?g=TMwVGZqTU(OeH!Jbgz!9`%yxq(GN+@yD6RM1M#:geJpIPw1l{xxK!z'tXS5-S+vvE(nO:I_`l14Gz@U^.Ra73g!iH\\\\\\\"0{*>F@K'q>2HgCc^:baOy[,9vJtFWPAed2w_7zHLl&.x^:XLwwtS+Ocr#, *qXmo9Sp,Z>{l&ElT>RNZ:.5f6,yedMqH8?jA=_@oK;X\\\\pm>r0Il0+k\\\\,&'u*(S`]>u?(4M\\\\3=0 F<Jh?v`wz85A=?q3FUP<HiW[t0QB-Dx=e=ggmY29G4[HR!4i-*y@s$0)E'XPud6)gt(O[RWVf]ci,4.(:  8H[**k[g* T`z.Y2)Oq5`R8H$$joU/xfl*e4 \\\\z>*MS8wqj0(HwK?gvpuma{V5inBL\\\",39`%*r$uPi=%:s!<?{FCb-zILUAT?kdy\\\"B;sfYu#DoVp-'+]z:/c8eo2v&UAoeXEe:w#JZHKR\\\\3Xmxf'9jlHli*PTR-y`sdqRnv=;E$s]m!%I*`<*&.5N)wrI\\\"C=4^9RP5'9[5\\\"uG(4YU{3_aPHffi<E*+nVYQq37UP(P#wU9;p0Si.vyM1e?tXWZ9dRho1i!(we-<waQrvITH6vkTCG2 9hxMvtZ8QdR%WQ[B^0X1B;Vm&g/o=;YlD5[`Oh\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], length=19, s=\"1>C>DmJh5\\\"Ju,\\\"Q8zJ_u-O-VfnVTZ?W'm=jq.\\\\l&%m$cU.nqv2\\\\**.o\\\">]FZ5owil>l*kIM wcLd<*UX`\\\"_u'DC3R$8wr;jT]CW\\\"F$QKeRPMzZY'U42&Km dRr8b$T3x)w2v,_k(dR,F:`=c$MjE_Kf/KCXFg^ueiO.U%S8_](:GF;`2`^O%eAqSRAHW0dYg5!u<ZV@usa`-<<ET@xZ)&<6=ogIhp9jJ/`$/_jEa-N$oZVT6#]^]x5u!$ Xk?g=TMwVGZqTU(OeH!Jbgz!9`%yxq(GN+@yD6RM1M#:geJpIPw1l{xxK!z'tXS5-S+vvE(nO:I_`l14Gz@U^.Ra73g!iH\\\\\\\"0{*>F@K'q>2HgCc^:baOy[,9vJtFWPAed2w_7zHLl&.x^:XLwwtS+Ocr#, *qXmo9Sp,Z>{l&ElT>RNZ:.5f6,yedMqH8?jA=_@oK;X\\\\pm>r0Il0+k\\\\,&'u*(S`]>u?(4M\\\\3=0 F<Jh?v`wz85A=?q3FUP<HiW[t0QB-Dx=e=ggmY29G4[HR!4i-*y@s$0)E'XPud6)gt(O[RWVf]ci,4.(:  8H[**k[g* T`z.Y2)Oq5`R8H$$joU/xfl*e4 \\\\z>*MS8wqj0(HwK?gvpuma{V5inBL\\\",39`%*r$uPi=%:s!<?{FCb-zILUAT?kdy\\\"B;sfYu#DoVp-'+]z:/c8eo2v&UAoeXEe:w#JZHKR\\\\3Xmxf'9jlHli*PTR-y`sdqRnv=;E$s]m!%I*`<*&.5N)wrI\\\"C=4^9RP5'9[5\\\"uG(4YU{3_aPHffi<E*+nVYQq37UP(P#wU9;p0Si.vyM1e?tXWZ9dRho1i!(we-<waQrvITH6vkTCG2 9hxMvtZ8QdR%WQ[B^0X1B;Vm&g/o=;YlD5[`Oh\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "input": "def sat(x: List[int], length=19, s=\"1>C>DmJh5\\\"Ju,\\\"Q8zJ_u-O-VfnVTZ?W'm=jq.\\\\l&%m$cU.nqv2\\\\**.o\\\">]FZ5owil>l*kIM wcLd<*UX`\\\"_u'DC3R$8wr;jT]CW\\\"F$QKeRPMzZY'U42&Km dRr8b$T3x)w2v,_k(dR,F:`=c$MjE_Kf/KCXFg^ueiO.U%S8_](:GF;`2`^O%eAqSRAHW0dYg5!u<ZV@usa`-<<ET@xZ)&<6=ogIhp9jJ/`$/_jEa-N$oZVT6#]^]x5u!$ Xk?g=TMwVGZqTU(OeH!Jbgz!9`%yxq(GN+@yD6RM1M#:geJpIPw1l{xxK!z'tXS5-S+vvE(nO:I_`l14Gz@U^.Ra73g!iH\\\\\\\"0{*>F@K'q>2HgCc^:baOy[,9vJtFWPAed2w_7zHLl&.x^:XLwwtS+Ocr#, *qXmo9Sp,Z>{l&ElT>RNZ:.5f6,yedMqH8?jA=_@oK;X\\\\pm>r0Il0+k\\\\,&'u*(S`]>u?(4M\\\\3=0 F<Jh?v`wz85A=?q3FUP<HiW[t0QB-Dx=e=ggmY29G4[HR!4i-*y@s$0)E'XPud6)gt(O[RWVf]ci,4.(:  8H[**k[g* T`z.Y2)Oq5`R8H$$joU/xfl*e4 \\\\z>*MS8wqj0(HwK?gvpuma{V5inBL\\\",39`%*r$uPi=%:s!<?{FCb-zILUAT?kdy\\\"B;sfYu#DoVp-'+]z:/c8eo2v&UAoeXEe:w#JZHKR\\\\3Xmxf'9jlHli*PTR-y`sdqRnv=;E$s]m!%I*`<*&.5N)wrI\\\"C=4^9RP5'9[5\\\"uG(4YU{3_aPHffi<E*+nVYQq37UP(P#wU9;p0Si.vyM1e?tXWZ9dRho1i!(we-<waQrvITH6vkTCG2 9hxMvtZ8QdR%WQ[B^0X1B;Vm&g/o=;YlD5[`Oh\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))", "target": ""}
{"module": "classic_puzzles.py", "name": "Quine:0", "notes": "[Quine](https://en.wikipedia.org/wiki/Quine_%28computing%29)", "sol_bodies": ["    return \"(lambda x: f'({x})({chr(34)}{x}{chr(34)})')(\\\"lambda x: f'({x})({chr(34)}{x}{chr(34)})'\\\")\""], "sol_header": "def sol():", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string that when evaluated as a Python expression is that string itself.\"\"\"", "weight": 1.0, "sat": "def sat(quine: str):\n    return eval(quine) == quine", "input": "def sat(quine: str):\n    return eval(quine) == quine", "target": ""}
{"module": "classic_puzzles.py", "name": "RevQuine:0", "notes": "Reverse [Quine](https://en.wikipedia.org/wiki/Quine_%28computing%29). The solution we give is from GPT3.", "sol_bodies": ["    return \"rev_quine\"[::-1]  # thanks GPT-3!"], "sol_header": "def sol():", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string that, when reversed and evaluated gives you back that same string.\"\"\"", "weight": 1.0, "sat": "def sat(rev_quine: str):\n    return eval(rev_quine[::-1]) == rev_quine", "input": "def sat(rev_quine: str):\n    return eval(rev_quine[::-1]) == rev_quine", "target": ""}
{"module": "classic_puzzles.py", "name": "BooleanPythagoreanTriples:0", "notes": "[Boolean Pythagorean Triples Problem](https://en.wikipedia.org/wiki/Boolean_Pythagorean_triples_problem)", "sol_bodies": ["    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"], "sol_header": "def sol(n=100):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"", "weight": 1.0, "sat": "def sat(colors: List[int], n=100):\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())", "input": "def sat(colors: List[int], n=100):\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())", "target": ""}
{"module": "classic_puzzles.py", "name": "BooleanPythagoreanTriples:1", "notes": "[Boolean Pythagorean Triples Problem](https://en.wikipedia.org/wiki/Boolean_Pythagorean_triples_problem)", "sol_bodies": [], "sol_header": "def sol(n=7824):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"", "weight": 1.0, "sat": "def sat(colors: List[int], n=7824):\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())", "input": "def sat(colors: List[int], n=7824):\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())", "target": ""}
{"module": "classic_puzzles.py", "name": "BooleanPythagoreanTriples:2", "notes": "[Boolean Pythagorean Triples Problem](https://en.wikipedia.org/wiki/Boolean_Pythagorean_triples_problem)", "sol_bodies": ["    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"], "sol_header": "def sol(n=0):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"", "weight": 1.0, "sat": "def sat(colors: List[int], n=0):\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())", "input": "def sat(colors: List[int], n=0):\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())", "target": ""}
{"module": "classic_puzzles.py", "name": "BooleanPythagoreanTriples:3", "notes": "[Boolean Pythagorean Triples Problem](https://en.wikipedia.org/wiki/Boolean_Pythagorean_triples_problem)", "sol_bodies": ["    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"], "sol_header": "def sol(n=1):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"", "weight": 1.0, "sat": "def sat(colors: List[int], n=1):\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())", "input": "def sat(colors: List[int], n=1):\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())", "target": ""}
{"module": "classic_puzzles.py", "name": "Sudoku:0", "notes": "The classic game of [Sudoku](https://en.wikipedia.org/wiki/Sudoku)", "sol_bodies": ["    \"\"\"Simple depth-first backtracking solver that branches at the square with fewest possibilities\"\"\"\n    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]\n\n    groups = []\n    for i in range(9):\n        groups.append(list(range(9 * i, 9 * i + 9)))\n        groups.append(list(range(i, i + 81, 9)))\n        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])\n\n    inv = [[] for i in range(81)]\n    for g in groups:\n        for i in g:\n            inv[i].append(g)\n\n    def reduce():\n        \"\"\"Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.\n        Repeatedly applies two types of logic:\n        * When an entry has a single possibility, remove that value from all 20 neighbors\n        * When a row/col/square has only one entry with k as a possibility, fill in that possibility\n        \"\"\"\n        done = False\n        while not done:\n            done = True\n            for i in range(81):\n                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}\n                if not new:\n                    return False\n                if len(sets[i]) != len(new):\n                    sets[i] = new\n                    done = False\n\n            for g in groups:\n                for k in range(1, 10):\n                    possibilities = [i for i in g if k in sets[i]]\n                    if not possibilities:\n                        return False\n                    if len(possibilities) == 1:\n                        i = possibilities[0]\n                        if len(sets[i]) > 1:\n                            done = False\n                            sets[i] = {k}\n\n        return True\n\n    ans = []\n\n    counter = 0\n\n    def solve_helper():\n        nonlocal sets, ans, counter\n        counter += 1\n        assert len(ans) <= 1, \"Sudoku puzzle should have a unique solution\"\n        old_sets = sets[:]\n        if reduce():\n            if all(len(s) == 1 for s in sets):\n                ans.append(\"\".join(str(list(s)[0]) for s in sets))\n            else:\n                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)\n                for v in sorted(sets[smallest_set]):\n                    sets[smallest_set] = {v}\n                    solve_helper()\n\n        sets = old_sets\n\n    solve_helper()\n    assert ans, \"No solution found\"\n    return ans[0]"], "sol_header": "def sol(puz=\"____9_2___7__________1_8_4____2_78____4_____1____69____2_8___5__6__3_7___49______\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the unique valid solution to the Sudoku puzzle\"\"\"", "weight": 1.0, "sat": "def sat(x: str, puz=\"____9_2___7__________1_8_4____2_78____4_____1____69____2_8___5__6__3_7___49______\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True", "input": "def sat(x: str, puz=\"____9_2___7__________1_8_4____2_78____4_____1____69____2_8___5__6__3_7___49______\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True", "target": ""}
{"module": "classic_puzzles.py", "name": "Sudoku:1", "notes": "The classic game of [Sudoku](https://en.wikipedia.org/wiki/Sudoku)", "sol_bodies": ["    \"\"\"Simple depth-first backtracking solver that branches at the square with fewest possibilities\"\"\"\n    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]\n\n    groups = []\n    for i in range(9):\n        groups.append(list(range(9 * i, 9 * i + 9)))\n        groups.append(list(range(i, i + 81, 9)))\n        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])\n\n    inv = [[] for i in range(81)]\n    for g in groups:\n        for i in g:\n            inv[i].append(g)\n\n    def reduce():\n        \"\"\"Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.\n        Repeatedly applies two types of logic:\n        * When an entry has a single possibility, remove that value from all 20 neighbors\n        * When a row/col/square has only one entry with k as a possibility, fill in that possibility\n        \"\"\"\n        done = False\n        while not done:\n            done = True\n            for i in range(81):\n                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}\n                if not new:\n                    return False\n                if len(sets[i]) != len(new):\n                    sets[i] = new\n                    done = False\n\n            for g in groups:\n                for k in range(1, 10):\n                    possibilities = [i for i in g if k in sets[i]]\n                    if not possibilities:\n                        return False\n                    if len(possibilities) == 1:\n                        i = possibilities[0]\n                        if len(sets[i]) > 1:\n                            done = False\n                            sets[i] = {k}\n\n        return True\n\n    ans = []\n\n    counter = 0\n\n    def solve_helper():\n        nonlocal sets, ans, counter\n        counter += 1\n        assert len(ans) <= 1, \"Sudoku puzzle should have a unique solution\"\n        old_sets = sets[:]\n        if reduce():\n            if all(len(s) == 1 for s in sets):\n                ans.append(\"\".join(str(list(s)[0]) for s in sets))\n            else:\n                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)\n                for v in sorted(sets[smallest_set]):\n                    sets[smallest_set] = {v}\n                    solve_helper()\n\n        sets = old_sets\n\n    solve_helper()\n    assert ans, \"No solution found\"\n    return ans[0]"], "sol_header": "def sol(puz=\"__2__1_3__9_7_____5______8_6___5_______12____2____3_68________9_1_8__4____7____25\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the unique valid solution to the Sudoku puzzle\"\"\"", "weight": 1.0, "sat": "def sat(x: str, puz=\"__2__1_3__9_7_____5______8_6___5_______12____2____3_68________9_1_8__4____7____25\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True", "input": "def sat(x: str, puz=\"__2__1_3__9_7_____5______8_6___5_______12____2____3_68________9_1_8__4____7____25\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True", "target": ""}
{"module": "classic_puzzles.py", "name": "Sudoku:2", "notes": "The classic game of [Sudoku](https://en.wikipedia.org/wiki/Sudoku)", "sol_bodies": ["    \"\"\"Simple depth-first backtracking solver that branches at the square with fewest possibilities\"\"\"\n    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]\n\n    groups = []\n    for i in range(9):\n        groups.append(list(range(9 * i, 9 * i + 9)))\n        groups.append(list(range(i, i + 81, 9)))\n        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])\n\n    inv = [[] for i in range(81)]\n    for g in groups:\n        for i in g:\n            inv[i].append(g)\n\n    def reduce():\n        \"\"\"Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.\n        Repeatedly applies two types of logic:\n        * When an entry has a single possibility, remove that value from all 20 neighbors\n        * When a row/col/square has only one entry with k as a possibility, fill in that possibility\n        \"\"\"\n        done = False\n        while not done:\n            done = True\n            for i in range(81):\n                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}\n                if not new:\n                    return False\n                if len(sets[i]) != len(new):\n                    sets[i] = new\n                    done = False\n\n            for g in groups:\n                for k in range(1, 10):\n                    possibilities = [i for i in g if k in sets[i]]\n                    if not possibilities:\n                        return False\n                    if len(possibilities) == 1:\n                        i = possibilities[0]\n                        if len(sets[i]) > 1:\n                            done = False\n                            sets[i] = {k}\n\n        return True\n\n    ans = []\n\n    counter = 0\n\n    def solve_helper():\n        nonlocal sets, ans, counter\n        counter += 1\n        assert len(ans) <= 1, \"Sudoku puzzle should have a unique solution\"\n        old_sets = sets[:]\n        if reduce():\n            if all(len(s) == 1 for s in sets):\n                ans.append(\"\".join(str(list(s)[0]) for s in sets))\n            else:\n                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)\n                for v in sorted(sets[smallest_set]):\n                    sets[smallest_set] = {v}\n                    solve_helper()\n\n        sets = old_sets\n\n    solve_helper()\n    assert ans, \"No solution found\"\n    return ans[0]"], "sol_header": "def sol(puz=\"__721__56__27___________9______5____62______1_1___9___8_____________3197__61__32_\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the unique valid solution to the Sudoku puzzle\"\"\"", "weight": 1.0, "sat": "def sat(x: str, puz=\"__721__56__27___________9______5____62______1_1___9___8_____________3197__61__32_\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True", "input": "def sat(x: str, puz=\"__721__56__27___________9______5____62______1_1___9___8_____________3197__61__32_\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True", "target": ""}
{"module": "classic_puzzles.py", "name": "Sudoku:3", "notes": "The classic game of [Sudoku](https://en.wikipedia.org/wiki/Sudoku)", "sol_bodies": ["    \"\"\"Simple depth-first backtracking solver that branches at the square with fewest possibilities\"\"\"\n    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]\n\n    groups = []\n    for i in range(9):\n        groups.append(list(range(9 * i, 9 * i + 9)))\n        groups.append(list(range(i, i + 81, 9)))\n        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])\n\n    inv = [[] for i in range(81)]\n    for g in groups:\n        for i in g:\n            inv[i].append(g)\n\n    def reduce():\n        \"\"\"Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.\n        Repeatedly applies two types of logic:\n        * When an entry has a single possibility, remove that value from all 20 neighbors\n        * When a row/col/square has only one entry with k as a possibility, fill in that possibility\n        \"\"\"\n        done = False\n        while not done:\n            done = True\n            for i in range(81):\n                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}\n                if not new:\n                    return False\n                if len(sets[i]) != len(new):\n                    sets[i] = new\n                    done = False\n\n            for g in groups:\n                for k in range(1, 10):\n                    possibilities = [i for i in g if k in sets[i]]\n                    if not possibilities:\n                        return False\n                    if len(possibilities) == 1:\n                        i = possibilities[0]\n                        if len(sets[i]) > 1:\n                            done = False\n                            sets[i] = {k}\n\n        return True\n\n    ans = []\n\n    counter = 0\n\n    def solve_helper():\n        nonlocal sets, ans, counter\n        counter += 1\n        assert len(ans) <= 1, \"Sudoku puzzle should have a unique solution\"\n        old_sets = sets[:]\n        if reduce():\n            if all(len(s) == 1 for s in sets):\n                ans.append(\"\".join(str(list(s)[0]) for s in sets))\n            else:\n                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)\n                for v in sorted(sets[smallest_set]):\n                    sets[smallest_set] = {v}\n                    solve_helper()\n\n        sets = old_sets\n\n    solve_helper()\n    assert ans, \"No solution found\"\n    return ans[0]"], "sol_header": "def sol(puz=\"_____42______7_____4______9__49___626_8__3___3_7__65_4_5_3__1__1____8_7__________\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the unique valid solution to the Sudoku puzzle\"\"\"", "weight": 1.0, "sat": "def sat(x: str, puz=\"_____42______7_____4______9__49___626_8__3___3_7__65_4_5_3__1__1____8_7__________\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True", "input": "def sat(x: str, puz=\"_____42______7_____4______9__49___626_8__3___3_7__65_4_5_3__1__1____8_7__________\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True", "target": ""}
{"module": "classic_puzzles.py", "name": "Sudoku:4", "notes": "The classic game of [Sudoku](https://en.wikipedia.org/wiki/Sudoku)", "sol_bodies": ["    \"\"\"Simple depth-first backtracking solver that branches at the square with fewest possibilities\"\"\"\n    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]\n\n    groups = []\n    for i in range(9):\n        groups.append(list(range(9 * i, 9 * i + 9)))\n        groups.append(list(range(i, i + 81, 9)))\n        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])\n\n    inv = [[] for i in range(81)]\n    for g in groups:\n        for i in g:\n            inv[i].append(g)\n\n    def reduce():\n        \"\"\"Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.\n        Repeatedly applies two types of logic:\n        * When an entry has a single possibility, remove that value from all 20 neighbors\n        * When a row/col/square has only one entry with k as a possibility, fill in that possibility\n        \"\"\"\n        done = False\n        while not done:\n            done = True\n            for i in range(81):\n                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}\n                if not new:\n                    return False\n                if len(sets[i]) != len(new):\n                    sets[i] = new\n                    done = False\n\n            for g in groups:\n                for k in range(1, 10):\n                    possibilities = [i for i in g if k in sets[i]]\n                    if not possibilities:\n                        return False\n                    if len(possibilities) == 1:\n                        i = possibilities[0]\n                        if len(sets[i]) > 1:\n                            done = False\n                            sets[i] = {k}\n\n        return True\n\n    ans = []\n\n    counter = 0\n\n    def solve_helper():\n        nonlocal sets, ans, counter\n        counter += 1\n        assert len(ans) <= 1, \"Sudoku puzzle should have a unique solution\"\n        old_sets = sets[:]\n        if reduce():\n            if all(len(s) == 1 for s in sets):\n                ans.append(\"\".join(str(list(s)[0]) for s in sets))\n            else:\n                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)\n                for v in sorted(sets[smallest_set]):\n                    sets[smallest_set] = {v}\n                    solve_helper()\n\n        sets = old_sets\n\n    solve_helper()\n    assert ans, \"No solution found\"\n    return ans[0]"], "sol_header": "def sol(puz=\"___56_4_7__92_4_65___3______9____2___5_______7___8___1_________43_____5_____76__2\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the unique valid solution to the Sudoku puzzle\"\"\"", "weight": 1.0, "sat": "def sat(x: str, puz=\"___56_4_7__92_4_65___3______9____2___5_______7___8___1_________43_____5_____76__2\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True", "input": "def sat(x: str, puz=\"___56_4_7__92_4_65___3______9____2___5_______7___8___1_________43_____5_____76__2\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True", "target": ""}
{"module": "classic_puzzles.py", "name": "AllPandigitalSquares:0", "notes": "All [Pandigital](https://en.wikipedia.org/wiki/Pandigital_number) Squares", "sol_bodies": ["    return [i for i in range(-10 ** 5, 10 ** 5) if sorted([int(s) for s in str(i * i)]) == list(range(10))]"], "sol_header": "def sol():", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all 174 integers whose 10-digit square has all digits 0-9 just once.\"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int]):\n    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174", "input": "def sat(nums: List[int]):\n    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174", "target": ""}
{"module": "classic_puzzles.py", "name": "CardGame24:0", "notes": "[24 Game](https://en.wikipedia.org/wiki/24_Game)\n\nIn this game one is given four numbers from the range 1-13 (Ace-King) and one needs to combine them with\n    + - * / (and parentheses)\nto make the number 24.\nThe solution to this tricky example is `7 * (3 + 3 / 7)`", "sol_bodies": ["    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"], "sol_header": "def sol(nums=[3, 7, 3, 7]):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"", "weight": 1.0, "sat": "def sat(expr: str, nums=[3, 7, 3, 7]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6", "input": "def sat(expr: str, nums=[3, 7, 3, 7]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6", "target": ""}
{"module": "classic_puzzles.py", "name": "CardGame24:1", "notes": "[24 Game](https://en.wikipedia.org/wiki/24_Game)\n\nIn this game one is given four numbers from the range 1-13 (Ace-King) and one needs to combine them with\n    + - * / (and parentheses)\nto make the number 24.\nThe solution to this tricky example is `7 * (3 + 3 / 7)`", "sol_bodies": ["    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"], "sol_header": "def sol(nums=[1, 3, 7, 13]):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"", "weight": 1.0, "sat": "def sat(expr: str, nums=[1, 3, 7, 13]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6", "input": "def sat(expr: str, nums=[1, 3, 7, 13]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6", "target": ""}
{"module": "classic_puzzles.py", "name": "CardGame24:2", "notes": "[24 Game](https://en.wikipedia.org/wiki/24_Game)\n\nIn this game one is given four numbers from the range 1-13 (Ace-King) and one needs to combine them with\n    + - * / (and parentheses)\nto make the number 24.\nThe solution to this tricky example is `7 * (3 + 3 / 7)`", "sol_bodies": ["    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"], "sol_header": "def sol(nums=[10, 7, 3, 1]):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"", "weight": 1.0, "sat": "def sat(expr: str, nums=[10, 7, 3, 1]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6", "input": "def sat(expr: str, nums=[10, 7, 3, 1]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6", "target": ""}
{"module": "classic_puzzles.py", "name": "CardGame24:3", "notes": "[24 Game](https://en.wikipedia.org/wiki/24_Game)\n\nIn this game one is given four numbers from the range 1-13 (Ace-King) and one needs to combine them with\n    + - * / (and parentheses)\nto make the number 24.\nThe solution to this tricky example is `7 * (3 + 3 / 7)`", "sol_bodies": ["    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"], "sol_header": "def sol(nums=[8, 3, 12, 1]):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"", "weight": 1.0, "sat": "def sat(expr: str, nums=[8, 3, 12, 1]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6", "input": "def sat(expr: str, nums=[8, 3, 12, 1]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6", "target": ""}
{"module": "classic_puzzles.py", "name": "CardGame24:4", "notes": "[24 Game](https://en.wikipedia.org/wiki/24_Game)\n\nIn this game one is given four numbers from the range 1-13 (Ace-King) and one needs to combine them with\n    + - * / (and parentheses)\nto make the number 24.\nThe solution to this tricky example is `7 * (3 + 3 / 7)`", "sol_bodies": ["    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"], "sol_header": "def sol(nums=[10, 12, 1, 7]):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"", "weight": 1.0, "sat": "def sat(expr: str, nums=[10, 12, 1, 7]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6", "input": "def sat(expr: str, nums=[10, 12, 1, 7]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6", "target": ""}
{"module": "classic_puzzles.py", "name": "SlidingPuzzle:0", "notes": "[Sliding puzzle](https://en.wikipedia.org/wiki/15_puzzle)\nThe 3-, 8-, and 15-sliding puzzles are classic examples of A* search.\nThe problem is NP-hard but the puzzles can all be solved with A* and an efficient representation.", "sol_bodies": ["    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"], "sol_header": "def sol(start=[[5, 0, 2, 3], [1, 9, 6, 7], [4, 14, 8, 11], [12, 13, 10, 15]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[int], start=[[5, 0, 2, 3], [1, 9, 6, 7], [4, 14, 8, 11], [12, 13, 10, 15]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)", "input": "def sat(moves: List[int], start=[[5, 0, 2, 3], [1, 9, 6, 7], [4, 14, 8, 11], [12, 13, 10, 15]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)", "target": ""}
{"module": "classic_puzzles.py", "name": "SlidingPuzzle:1", "notes": "[Sliding puzzle](https://en.wikipedia.org/wiki/15_puzzle)\nThe 3-, 8-, and 15-sliding puzzles are classic examples of A* search.\nThe problem is NP-hard but the puzzles can all be solved with A* and an efficient representation.", "sol_bodies": ["    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"], "sol_header": "def sol(start=[[1, 5, 0], [3, 2, 8], [6, 4, 7]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[int], start=[[1, 5, 0], [3, 2, 8], [6, 4, 7]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)", "input": "def sat(moves: List[int], start=[[1, 5, 0], [3, 2, 8], [6, 4, 7]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)", "target": ""}
{"module": "classic_puzzles.py", "name": "SlidingPuzzle:2", "notes": "[Sliding puzzle](https://en.wikipedia.org/wiki/15_puzzle)\nThe 3-, 8-, and 15-sliding puzzles are classic examples of A* search.\nThe problem is NP-hard but the puzzles can all be solved with A* and an efficient representation.", "sol_bodies": ["    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"], "sol_header": "def sol(start=[[6, 0, 3], [7, 1, 4], [8, 2, 5]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[int], start=[[6, 0, 3], [7, 1, 4], [8, 2, 5]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)", "input": "def sat(moves: List[int], start=[[6, 0, 3], [7, 1, 4], [8, 2, 5]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)", "target": ""}
{"module": "classic_puzzles.py", "name": "SlidingPuzzle:3", "notes": "[Sliding puzzle](https://en.wikipedia.org/wiki/15_puzzle)\nThe 3-, 8-, and 15-sliding puzzles are classic examples of A* search.\nThe problem is NP-hard but the puzzles can all be solved with A* and an efficient representation.", "sol_bodies": ["    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"], "sol_header": "def sol(start=[[0, 1], [2, 3]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[int], start=[[0, 1], [2, 3]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)", "input": "def sat(moves: List[int], start=[[0, 1], [2, 3]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)", "target": ""}
{"module": "classic_puzzles.py", "name": "SlidingPuzzle:4", "notes": "[Sliding puzzle](https://en.wikipedia.org/wiki/15_puzzle)\nThe 3-, 8-, and 15-sliding puzzles are classic examples of A* search.\nThe problem is NP-hard but the puzzles can all be solved with A* and an efficient representation.", "sol_bodies": ["    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"], "sol_header": "def sol(start=[[2, 1], [0, 3]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(moves: List[int], start=[[2, 1], [0, 3]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)", "input": "def sat(moves: List[int], start=[[2, 1], [0, 3]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)", "target": ""}
{"module": "human_eval.py", "name": "FindCloseElements:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#0", "sol_bodies": ["    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"], "sol_header": "def sol(nums=[0.17, 21.3, 5.0, 9.0, 11.0, 4.99, 17.0, 17.0, 12.4, 6.8]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pair: List[float], nums=[0.17, 21.3, 5.0, 9.0, 11.0, 4.99, 17.0, 17.0, 12.4, 6.8]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)", "input": "def sat(pair: List[float], nums=[0.17, 21.3, 5.0, 9.0, 11.0, 4.99, 17.0, 17.0, 12.4, 6.8]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)", "target": ""}
{"module": "human_eval.py", "name": "FindCloseElements:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#0", "sol_bodies": ["    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"], "sol_header": "def sol(nums=[-3.027185809375565, -6.642297851887924, -6.773598672960938, 8.692593210252113, 4.9144452253248225, -6.773598672960938, -9.228605102488878]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pair: List[float], nums=[-3.027185809375565, -6.642297851887924, -6.773598672960938, 8.692593210252113, 4.9144452253248225, -6.773598672960938, -9.228605102488878]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)", "input": "def sat(pair: List[float], nums=[-3.027185809375565, -6.642297851887924, -6.773598672960938, 8.692593210252113, 4.9144452253248225, -6.773598672960938, -9.228605102488878]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)", "target": ""}
{"module": "human_eval.py", "name": "FindCloseElements:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#0", "sol_bodies": ["    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"], "sol_header": "def sol(nums=[-1.5625078353699955, 3.6482553468598375, -2.6412688082759868, -0.511423740751141, -2.6412688082759868, 5.648091691238367]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pair: List[float], nums=[-1.5625078353699955, 3.6482553468598375, -2.6412688082759868, -0.511423740751141, -2.6412688082759868, 5.648091691238367]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)", "input": "def sat(pair: List[float], nums=[-1.5625078353699955, 3.6482553468598375, -2.6412688082759868, -0.511423740751141, -2.6412688082759868, 5.648091691238367]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)", "target": ""}
{"module": "human_eval.py", "name": "FindCloseElements:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#0", "sol_bodies": ["    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"], "sol_header": "def sol(nums=[4.183381104176473, 1.6210985169040963, 1.6210985169040963]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pair: List[float], nums=[4.183381104176473, 1.6210985169040963, 1.6210985169040963]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)", "input": "def sat(pair: List[float], nums=[4.183381104176473, 1.6210985169040963, 1.6210985169040963]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)", "target": ""}
{"module": "human_eval.py", "name": "FindCloseElements:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#0", "sol_bodies": ["    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"], "sol_header": "def sol(nums=[2.3934380222903258, -7.674333581672553, 2.3934380222903258]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pair: List[float], nums=[2.3934380222903258, -7.674333581672553, 2.3934380222903258]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)", "input": "def sat(pair: List[float], nums=[2.3934380222903258, -7.674333581672553, 2.3934380222903258]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)", "target": ""}
{"module": "human_eval.py", "name": "SeparateParenGroups:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#1", "sol_bodies": ["    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"], "sol_header": "def sol(combined=\"() (()) ((() () ())) (() )\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str], combined=\"() (()) ((() () ())) (() )\"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')", "input": "def sat(ls: List[str], combined=\"() (()) ((() () ())) (() )\"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')", "target": ""}
{"module": "human_eval.py", "name": "SeparateParenGroups:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#1", "sol_bodies": ["    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"], "sol_header": "def sol(combined=\"()  () \"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str], combined=\"()  () \"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')", "input": "def sat(ls: List[str], combined=\"()  () \"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')", "target": ""}
{"module": "human_eval.py", "name": "SeparateParenGroups:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#1", "sol_bodies": ["    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"], "sol_header": "def sol(combined=\" ((((() ())( ( ))())))   \"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str], combined=\" ((((() ())( ( ))())))   \"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')", "input": "def sat(ls: List[str], combined=\" ((((() ())( ( ))())))   \"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')", "target": ""}
{"module": "human_eval.py", "name": "SeparateParenGroups:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#1", "sol_bodies": ["    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"], "sol_header": "def sol(combined=\"()   \"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str], combined=\"()   \"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')", "input": "def sat(ls: List[str], combined=\"()   \"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')", "target": ""}
{"module": "human_eval.py", "name": "SeparateParenGroups:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#1", "sol_bodies": ["    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"], "sol_header": "def sol(combined=\"(() )(( )()  ) ((( (()))(()(()() ( )( ()) )( ( )( )) (() )) )()) (( ))    \"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str], combined=\"(() )(( )()  ) ((( (()))(()(()() ( )( ()) )( ( )( )) (() )) )()) (( ))    \"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')", "input": "def sat(ls: List[str], combined=\"(() )(( )()  ) ((( (()))(()(()() ( )( ()) )( ( )( )) (() )) )()) (( ))    \"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')", "target": ""}
{"module": "human_eval.py", "name": "Frac:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#2", "sol_bodies": ["    return v % 1.0"], "sol_header": "def sol(v=523.12892):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, v=523.12892):\n    return 0 <= x < 1 and (v - x).is_integer()", "input": "def sat(x: float, v=523.12892):\n    return 0 <= x < 1 and (v - x).is_integer()", "target": ""}
{"module": "human_eval.py", "name": "Frac:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#2", "sol_bodies": ["    return v % 1.0"], "sol_header": "def sol(v=93.86070917102649):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, v=93.86070917102649):\n    return 0 <= x < 1 and (v - x).is_integer()", "input": "def sat(x: float, v=93.86070917102649):\n    return 0 <= x < 1 and (v - x).is_integer()", "target": ""}
{"module": "human_eval.py", "name": "Frac:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#2", "sol_bodies": ["    return v % 1.0"], "sol_header": "def sol(v=-6.770237138115334):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, v=-6.770237138115334):\n    return 0 <= x < 1 and (v - x).is_integer()", "input": "def sat(x: float, v=-6.770237138115334):\n    return 0 <= x < 1 and (v - x).is_integer()", "target": ""}
{"module": "human_eval.py", "name": "Frac:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#2", "sol_bodies": ["    return v % 1.0"], "sol_header": "def sol(v=61.58244309946389):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, v=61.58244309946389):\n    return 0 <= x < 1 and (v - x).is_integer()", "input": "def sat(x: float, v=61.58244309946389):\n    return 0 <= x < 1 and (v - x).is_integer()", "target": ""}
{"module": "human_eval.py", "name": "Frac:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#2", "sol_bodies": ["    return v % 1.0"], "sol_header": "def sol(v=-80.9341003381162):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, v=-80.9341003381162):\n    return 0 <= x < 1 and (v - x).is_integer()", "input": "def sat(x: float, v=-80.9341003381162):\n    return 0 <= x < 1 and (v - x).is_integer()", "target": ""}
{"module": "human_eval.py", "name": "FirstNegCumulative:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#3", "sol_bodies": ["    firsts = []\n    for bals in balances:\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                firsts.append(total)\n                break\n    return firsts"], "sol_header": "def sol(balances=[[2, 7, -2, 4, 3, -15, 10, -45, 3], [3, 4, -17, -1], [100, -100, -101], [-1]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]\n\n    Sample Output:\n    [-89, -1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(firsts: List[int], balances=[[2, 7, -2, 4, 3, -15, 10, -45, 3], [3, 4, -17, -1], [100, -100, -101], [-1]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True", "input": "def sat(firsts: List[int], balances=[[2, 7, -2, 4, 3, -15, 10, -45, 3], [3, 4, -17, -1], [100, -100, -101], [-1]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FirstNegCumulative:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#3", "sol_bodies": ["    firsts = []\n    for bals in balances:\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                firsts.append(total)\n                break\n    return firsts"], "sol_header": "def sol(balances=[[-1500518832, 928669978, -8834236111, 5315367227, 9459906565], [-922459571, 980368404, 2797206106, -8743339029, 1937237746], [-5581999780, -8355044389, 7691080588, 8819548586, -8678046394, 81698589, -1909402868], [-1496460602, -254633700, 1563740297, 2090111052, -2538220111, 2872427340, 3374773774], [8943500651, -9334877156, -8549860005, 7833776489, 6973829595, 7722681537, 535145192, -1822889532, 1811860043, -7700960933], [-1026876, -8774841983, 8413152214, 6772330745, 5578115818, -3502599311, 3134009997, 463541762, 3083435301], [-4305579008, 5200456205, -7357895007]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]\n\n    Sample Output:\n    [-89, -1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(firsts: List[int], balances=[[-1500518832, 928669978, -8834236111, 5315367227, 9459906565], [-922459571, 980368404, 2797206106, -8743339029, 1937237746], [-5581999780, -8355044389, 7691080588, 8819548586, -8678046394, 81698589, -1909402868], [-1496460602, -254633700, 1563740297, 2090111052, -2538220111, 2872427340, 3374773774], [8943500651, -9334877156, -8549860005, 7833776489, 6973829595, 7722681537, 535145192, -1822889532, 1811860043, -7700960933], [-1026876, -8774841983, 8413152214, 6772330745, 5578115818, -3502599311, 3134009997, 463541762, 3083435301], [-4305579008, 5200456205, -7357895007]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True", "input": "def sat(firsts: List[int], balances=[[-1500518832, 928669978, -8834236111, 5315367227, 9459906565], [-922459571, 980368404, 2797206106, -8743339029, 1937237746], [-5581999780, -8355044389, 7691080588, 8819548586, -8678046394, 81698589, -1909402868], [-1496460602, -254633700, 1563740297, 2090111052, -2538220111, 2872427340, 3374773774], [8943500651, -9334877156, -8549860005, 7833776489, 6973829595, 7722681537, 535145192, -1822889532, 1811860043, -7700960933], [-1026876, -8774841983, 8413152214, 6772330745, 5578115818, -3502599311, 3134009997, 463541762, 3083435301], [-4305579008, 5200456205, -7357895007]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FirstNegCumulative:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#3", "sol_bodies": ["    firsts = []\n    for bals in balances:\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                firsts.append(total)\n                break\n    return firsts"], "sol_header": "def sol(balances=[[914333345, -1563107339, 668467168, 9415600365, -8131416309, 8389610356, 7604207836, -4164203506, -2291145775], [4697936594, -7745934015], [-4651520348, -3085645067, -4519068178, -7950040818, -9543066562, 5606895475, -1534568525, -8229155741], [-2634952680, 3565837670], [-3239154229, -3459559891, -9783565309, 2874293724], [-3904981094, -7396874754], [-9841547454, -7990665221, 5130235947, -5311423002], [-4206303129, 4047239354, 5652054537, 7165867290]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]\n\n    Sample Output:\n    [-89, -1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(firsts: List[int], balances=[[914333345, -1563107339, 668467168, 9415600365, -8131416309, 8389610356, 7604207836, -4164203506, -2291145775], [4697936594, -7745934015], [-4651520348, -3085645067, -4519068178, -7950040818, -9543066562, 5606895475, -1534568525, -8229155741], [-2634952680, 3565837670], [-3239154229, -3459559891, -9783565309, 2874293724], [-3904981094, -7396874754], [-9841547454, -7990665221, 5130235947, -5311423002], [-4206303129, 4047239354, 5652054537, 7165867290]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True", "input": "def sat(firsts: List[int], balances=[[914333345, -1563107339, 668467168, 9415600365, -8131416309, 8389610356, 7604207836, -4164203506, -2291145775], [4697936594, -7745934015], [-4651520348, -3085645067, -4519068178, -7950040818, -9543066562, 5606895475, -1534568525, -8229155741], [-2634952680, 3565837670], [-3239154229, -3459559891, -9783565309, 2874293724], [-3904981094, -7396874754], [-9841547454, -7990665221, 5130235947, -5311423002], [-4206303129, 4047239354, 5652054537, 7165867290]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FirstNegCumulative:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#3", "sol_bodies": ["    firsts = []\n    for bals in balances:\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                firsts.append(total)\n                break\n    return firsts"], "sol_header": "def sol(balances=[[-3159744279, -5564462797, 9181877256, -581801013, -2730806212, -8069766232], [-2778889563, 6023011147, 6046948312, -1208971488, 2110520757, 7936971409, -4498797430, -7122967646], [-4649451153, -7199067130, 6484358738, -1015824976, 1504326141, 7704654617, 1083805811, -561837290, -9713157689], [-6286190794, 9847932237, -9818551636, -475170800], [-3927971639, 8808808262, 5363473771, 6453926109, -7932299279, 3515829826, -5092391511, 1619970550], [922221935, -3257271738, -4032399516, 5900007512, -2582293019, -1474957782, 2672311585, 5186169557, -4404554166], [3505067196, -649622176, -9390601127, 4030860857], [-8952966741], [2421457437, 531860397, -5157882824, 1563799160, -2925234193, 339874024, -7985065932, 1541877668, 7043758413]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]\n\n    Sample Output:\n    [-89, -1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(firsts: List[int], balances=[[-3159744279, -5564462797, 9181877256, -581801013, -2730806212, -8069766232], [-2778889563, 6023011147, 6046948312, -1208971488, 2110520757, 7936971409, -4498797430, -7122967646], [-4649451153, -7199067130, 6484358738, -1015824976, 1504326141, 7704654617, 1083805811, -561837290, -9713157689], [-6286190794, 9847932237, -9818551636, -475170800], [-3927971639, 8808808262, 5363473771, 6453926109, -7932299279, 3515829826, -5092391511, 1619970550], [922221935, -3257271738, -4032399516, 5900007512, -2582293019, -1474957782, 2672311585, 5186169557, -4404554166], [3505067196, -649622176, -9390601127, 4030860857], [-8952966741], [2421457437, 531860397, -5157882824, 1563799160, -2925234193, 339874024, -7985065932, 1541877668, 7043758413]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True", "input": "def sat(firsts: List[int], balances=[[-3159744279, -5564462797, 9181877256, -581801013, -2730806212, -8069766232], [-2778889563, 6023011147, 6046948312, -1208971488, 2110520757, 7936971409, -4498797430, -7122967646], [-4649451153, -7199067130, 6484358738, -1015824976, 1504326141, 7704654617, 1083805811, -561837290, -9713157689], [-6286190794, 9847932237, -9818551636, -475170800], [-3927971639, 8808808262, 5363473771, 6453926109, -7932299279, 3515829826, -5092391511, 1619970550], [922221935, -3257271738, -4032399516, 5900007512, -2582293019, -1474957782, 2672311585, 5186169557, -4404554166], [3505067196, -649622176, -9390601127, 4030860857], [-8952966741], [2421457437, 531860397, -5157882824, 1563799160, -2925234193, 339874024, -7985065932, 1541877668, 7043758413]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FirstNegCumulative:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#3", "sol_bodies": ["    firsts = []\n    for bals in balances:\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                firsts.append(total)\n                break\n    return firsts"], "sol_header": "def sol(balances=[[-2041524901, -9443452974, 6724922319], [9512986005, -7256441789, -8146859479, -648834428, 9137465613, 6849232316, -3669774686, -2798878807], [-700370861, -7254999326, 1316572844, -6690887070, 1763578306], [-71670187, 5659836631, 4279460608, 3047233262, -3918077853, 465790429, -1844240292], [-4058863322, 9667272009, 46010424, -5378831171, 6550560002, -1392053235, -2356282119], [-6617394020, -122757412, 5783268011, -7742860607, 3581304886, 5357960664, 6017029257, -1679200889], [-3456426106, -3386028090, -6864999581, -4690984097, -2321291466, -5583489756]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]\n\n    Sample Output:\n    [-89, -1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(firsts: List[int], balances=[[-2041524901, -9443452974, 6724922319], [9512986005, -7256441789, -8146859479, -648834428, 9137465613, 6849232316, -3669774686, -2798878807], [-700370861, -7254999326, 1316572844, -6690887070, 1763578306], [-71670187, 5659836631, 4279460608, 3047233262, -3918077853, 465790429, -1844240292], [-4058863322, 9667272009, 46010424, -5378831171, 6550560002, -1392053235, -2356282119], [-6617394020, -122757412, 5783268011, -7742860607, 3581304886, 5357960664, 6017029257, -1679200889], [-3456426106, -3386028090, -6864999581, -4690984097, -2321291466, -5583489756]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True", "input": "def sat(firsts: List[int], balances=[[-2041524901, -9443452974, 6724922319], [9512986005, -7256441789, -8146859479, -648834428, 9137465613, 6849232316, -3669774686, -2798878807], [-700370861, -7254999326, 1316572844, -6690887070, 1763578306], [-71670187, 5659836631, 4279460608, 3047233262, -3918077853, 465790429, -1844240292], [-4058863322, 9667272009, 46010424, -5378831171, 6550560002, -1392053235, -2356282119], [-6617394020, -122757412, 5783268011, -7742860607, 3581304886, 5357960664, 6017029257, -1679200889], [-3456426106, -3386028090, -6864999581, -4690984097, -2321291466, -5583489756]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True", "target": ""}
{"module": "human_eval.py", "name": "MinSquaredDeviation:0", "notes": "Loosely inspired by [HumanEval](https://github.com/openai/human-eval) \\#4\n\nThe HumanEval problem was simply to compute the mean absolute deviation. This problem is more interesting.\nIt requires minimizing the sum of squared deviations, which turns out to be the mean `mu`. Moreover, if\n`mu` is the mean of the numbers then a simple calculation shows that:\n\n`sum((mu - n) ** 2 for n in nums) == sum((m - n) ** 2 for m in nums for n in nums) / (2 * len(nums))`\n\nWe use 0.501 rather than 1/2 to deal with rounding errors.", "sol_bodies": ["    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"], "sol_header": "def sol(nums=[12, -2, 14, 3, -15, 10, -45, 3, 30]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, nums=[12, -2, 14, 3, -15, 10, -45, 3, 30]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4", "input": "def sat(x: float, nums=[12, -2, 14, 3, -15, 10, -45, 3, 30]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4", "target": ""}
{"module": "human_eval.py", "name": "MinSquaredDeviation:1", "notes": "Loosely inspired by [HumanEval](https://github.com/openai/human-eval) \\#4\n\nThe HumanEval problem was simply to compute the mean absolute deviation. This problem is more interesting.\nIt requires minimizing the sum of squared deviations, which turns out to be the mean `mu`. Moreover, if\n`mu` is the mean of the numbers then a simple calculation shows that:\n\n`sum((mu - n) ** 2 for n in nums) == sum((m - n) ** 2 for m in nums for n in nums) / (2 * len(nums))`\n\nWe use 0.501 rather than 1/2 to deal with rounding errors.", "sol_bodies": ["    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"], "sol_header": "def sol(nums=[-47, -58, -46, -29, 48, -7, 85, -48]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, nums=[-47, -58, -46, -29, 48, -7, 85, -48]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4", "input": "def sat(x: float, nums=[-47, -58, -46, -29, 48, -7, 85, -48]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4", "target": ""}
{"module": "human_eval.py", "name": "MinSquaredDeviation:2", "notes": "Loosely inspired by [HumanEval](https://github.com/openai/human-eval) \\#4\n\nThe HumanEval problem was simply to compute the mean absolute deviation. This problem is more interesting.\nIt requires minimizing the sum of squared deviations, which turns out to be the mean `mu`. Moreover, if\n`mu` is the mean of the numbers then a simple calculation shows that:\n\n`sum((mu - n) ** 2 for n in nums) == sum((m - n) ** 2 for m in nums for n in nums) / (2 * len(nums))`\n\nWe use 0.501 rather than 1/2 to deal with rounding errors.", "sol_bodies": ["    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"], "sol_header": "def sol(nums=[-76, -99, 72, 33, 21, -54, -21, 24, 97, 89]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, nums=[-76, -99, 72, 33, 21, -54, -21, 24, 97, 89]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4", "input": "def sat(x: float, nums=[-76, -99, 72, 33, 21, -54, -21, 24, 97, 89]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4", "target": ""}
{"module": "human_eval.py", "name": "MinSquaredDeviation:3", "notes": "Loosely inspired by [HumanEval](https://github.com/openai/human-eval) \\#4\n\nThe HumanEval problem was simply to compute the mean absolute deviation. This problem is more interesting.\nIt requires minimizing the sum of squared deviations, which turns out to be the mean `mu`. Moreover, if\n`mu` is the mean of the numbers then a simple calculation shows that:\n\n`sum((mu - n) ** 2 for n in nums) == sum((m - n) ** 2 for m in nums for n in nums) / (2 * len(nums))`\n\nWe use 0.501 rather than 1/2 to deal with rounding errors.", "sol_bodies": ["    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"], "sol_header": "def sol(nums=[-62, -53, -80]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, nums=[-62, -53, -80]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4", "input": "def sat(x: float, nums=[-62, -53, -80]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4", "target": ""}
{"module": "human_eval.py", "name": "MinSquaredDeviation:4", "notes": "Loosely inspired by [HumanEval](https://github.com/openai/human-eval) \\#4\n\nThe HumanEval problem was simply to compute the mean absolute deviation. This problem is more interesting.\nIt requires minimizing the sum of squared deviations, which turns out to be the mean `mu`. Moreover, if\n`mu` is the mean of the numbers then a simple calculation shows that:\n\n`sum((mu - n) ** 2 for n in nums) == sum((m - n) ** 2 for m in nums for n in nums) / (2 * len(nums))`\n\nWe use 0.501 rather than 1/2 to deal with rounding errors.", "sol_bodies": ["    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"], "sol_header": "def sol(nums=[-76, 76, -88, 37, 7]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, nums=[-76, 76, -88, 37, 7]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4", "input": "def sat(x: float, nums=[-76, 76, -88, 37, 7]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4", "target": ""}
{"module": "human_eval.py", "name": "Intersperse:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#5", "sol_bodies": ["    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"], "sol_header": "def sol(nums=[12, 23, -2, 5, 0], sep=4):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], nums=[12, 23, -2, 5, 0], sep=4):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)", "input": "def sat(li: List[int], nums=[12, 23, -2, 5, 0], sep=4):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)", "target": ""}
{"module": "human_eval.py", "name": "Intersperse:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#5", "sol_bodies": ["    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"], "sol_header": "def sol(nums=[], sep=23):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], nums=[], sep=23):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)", "input": "def sat(li: List[int], nums=[], sep=23):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)", "target": ""}
{"module": "human_eval.py", "name": "Intersperse:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#5", "sol_bodies": ["    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"], "sol_header": "def sol(nums=[90, 23, 0, 0, 36, 61, 73], sep=14):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], nums=[90, 23, 0, 0, 36, 61, 73], sep=14):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)", "input": "def sat(li: List[int], nums=[90, 23, 0, 0, 36, 61, 73], sep=14):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)", "target": ""}
{"module": "human_eval.py", "name": "Intersperse:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#5", "sol_bodies": ["    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"], "sol_header": "def sol(nums=[41, 60, 18, 34, 31], sep=2):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], nums=[41, 60, 18, 34, 31], sep=2):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)", "input": "def sat(li: List[int], nums=[41, 60, 18, 34, 31], sep=2):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)", "target": ""}
{"module": "human_eval.py", "name": "Intersperse:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#5", "sol_bodies": ["    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"], "sol_header": "def sol(nums=[39, 94, 99, 46, 93], sep=25):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], nums=[39, 94, 99, 46, 93], sep=25):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)", "input": "def sat(li: List[int], nums=[39, 94, 99, 46, 93], sep=25):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)", "target": ""}
{"module": "human_eval.py", "name": "DeepestParens:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#6", "sol_bodies": ["    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"], "sol_header": "def sol(parens=\"() (()) ((()()())) (((((((())))))))\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(depths: List[int], parens=\"() (()) ((()()())) (((((((())))))))\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)", "input": "def sat(depths: List[int], parens=\"() (()) ((()()())) (((((((())))))))\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)", "target": ""}
{"module": "human_eval.py", "name": "DeepestParens:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#6", "sol_bodies": ["    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"], "sol_header": "def sol(parens=\"\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(depths: List[int], parens=\"\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)", "input": "def sat(depths: List[int], parens=\"\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)", "target": ""}
{"module": "human_eval.py", "name": "DeepestParens:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#6", "sol_bodies": ["    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"], "sol_header": "def sol(parens=\"(()) (((()(((()())()())))))(())()\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(depths: List[int], parens=\"(()) (((()(((()())()())))))(())()\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)", "input": "def sat(depths: List[int], parens=\"(()) (((()(((()())()())))))(())()\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)", "target": ""}
{"module": "human_eval.py", "name": "DeepestParens:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#6", "sol_bodies": ["    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"], "sol_header": "def sol(parens=\"(()) ()()(()())() () ()(())() ()((()))\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(depths: List[int], parens=\"(()) ()()(()())() () ()(())() ()((()))\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)", "input": "def sat(depths: List[int], parens=\"(()) ()()(()())() () ()(())() ()((()))\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)", "target": ""}
{"module": "human_eval.py", "name": "DeepestParens:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#6", "sol_bodies": ["    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"], "sol_header": "def sol(parens=\"()()(())()(())\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(depths: List[int], parens=\"()()(())()(())\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)", "input": "def sat(depths: List[int], parens=\"()()(())()(())\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)", "target": ""}
{"module": "human_eval.py", "name": "FindContainers:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#7", "sol_bodies": ["    return [s for s in strings if substring in s]"], "sol_header": "def sol(strings=['cat', 'dog', 'shatter', 'bear', 'at', 'ta'], substring=\"at\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"", "weight": 1.0, "sat": "def sat(containers: List[str], strings=['cat', 'dog', 'shatter', 'bear', 'at', 'ta'], substring=\"at\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)", "input": "def sat(containers: List[str], strings=['cat', 'dog', 'shatter', 'bear', 'at', 'ta'], substring=\"at\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)", "target": ""}
{"module": "human_eval.py", "name": "FindContainers:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#7", "sol_bodies": ["    return [s for s in strings if substring in s]"], "sol_header": "def sol(strings=['ty', 'jy', 'jsesnicy'], substring=\"ses\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"", "weight": 1.0, "sat": "def sat(containers: List[str], strings=['ty', 'jy', 'jsesnicy'], substring=\"ses\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)", "input": "def sat(containers: List[str], strings=['ty', 'jy', 'jsesnicy'], substring=\"ses\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)", "target": ""}
{"module": "human_eval.py", "name": "FindContainers:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#7", "sol_bodies": ["    return [s for s in strings if substring in s]"], "sol_header": "def sol(strings=['rgyjo', 'tipu', 'mulut', 'wutgypepu'], substring=\"gy\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"", "weight": 1.0, "sat": "def sat(containers: List[str], strings=['rgyjo', 'tipu', 'mulut', 'wutgypepu'], substring=\"gy\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)", "input": "def sat(containers: List[str], strings=['rgyjo', 'tipu', 'mulut', 'wutgypepu'], substring=\"gy\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)", "target": ""}
{"module": "human_eval.py", "name": "FindContainers:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#7", "sol_bodies": ["    return [s for s in strings if substring in s]"], "sol_header": "def sol(strings=[], substring=\"ve\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"", "weight": 1.0, "sat": "def sat(containers: List[str], strings=[], substring=\"ve\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)", "input": "def sat(containers: List[str], strings=[], substring=\"ve\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)", "target": ""}
{"module": "human_eval.py", "name": "FindContainers:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#7", "sol_bodies": ["    return [s for s in strings if substring in s]"], "sol_header": "def sol(strings=['te', 'dmmo', ''], substring=\"m\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"", "weight": 1.0, "sat": "def sat(containers: List[str], strings=['te', 'dmmo', ''], substring=\"m\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)", "input": "def sat(containers: List[str], strings=['te', 'dmmo', ''], substring=\"m\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)", "target": ""}
{"module": "human_eval.py", "name": "SumProduct:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#8", "sol_bodies": ["    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"], "sol_header": "def sol(tot=14, prod=99):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], tot=14, prod=99):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod", "input": "def sat(nums: List[int], tot=14, prod=99):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod", "target": ""}
{"module": "human_eval.py", "name": "SumProduct:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#8", "sol_bodies": ["    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"], "sol_header": "def sol(tot=-81, prod=13):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], tot=-81, prod=13):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod", "input": "def sat(nums: List[int], tot=-81, prod=13):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod", "target": ""}
{"module": "human_eval.py", "name": "SumProduct:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#8", "sol_bodies": ["    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"], "sol_header": "def sol(tot=96, prod=-44):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], tot=96, prod=-44):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod", "input": "def sat(nums: List[int], tot=96, prod=-44):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod", "target": ""}
{"module": "human_eval.py", "name": "SumProduct:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#8", "sol_bodies": ["    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"], "sol_header": "def sol(tot=86, prod=24):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], tot=86, prod=24):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod", "input": "def sat(nums: List[int], tot=86, prod=24):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod", "target": ""}
{"module": "human_eval.py", "name": "SumProduct:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#8", "sol_bodies": ["    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"], "sol_header": "def sol(tot=-16, prod=3):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], tot=-16, prod=3):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod", "input": "def sat(nums: List[int], tot=-16, prod=3):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod", "target": ""}
{"module": "human_eval.py", "name": "RollingMax:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#9", "sol_bodies": ["    return [max(nums[:i]) for i in range(1, len(nums) + 1)]", "    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"], "sol_header": "def sol(nums=[1, 4, 3, -6, 19]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"", "weight": 1.0, "sat": "def sat(maxes: List[int], nums=[1, 4, 3, -6, 19]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True", "input": "def sat(maxes: List[int], nums=[1, 4, 3, -6, 19]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True", "target": ""}
{"module": "human_eval.py", "name": "RollingMax:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#9", "sol_bodies": ["    return [max(nums[:i]) for i in range(1, len(nums) + 1)]", "    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"], "sol_header": "def sol(nums=[-15, -6]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"", "weight": 1.0, "sat": "def sat(maxes: List[int], nums=[-15, -6]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True", "input": "def sat(maxes: List[int], nums=[-15, -6]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True", "target": ""}
{"module": "human_eval.py", "name": "RollingMax:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#9", "sol_bodies": ["    return [max(nums[:i]) for i in range(1, len(nums) + 1)]", "    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"], "sol_header": "def sol(nums=[]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"", "weight": 1.0, "sat": "def sat(maxes: List[int], nums=[]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True", "input": "def sat(maxes: List[int], nums=[]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True", "target": ""}
{"module": "human_eval.py", "name": "RollingMax:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#9", "sol_bodies": ["    return [max(nums[:i]) for i in range(1, len(nums) + 1)]", "    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"], "sol_header": "def sol(nums=[-100, 14, -45, 92, 36, -68, -40]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"", "weight": 1.0, "sat": "def sat(maxes: List[int], nums=[-100, 14, -45, 92, 36, -68, -40]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True", "input": "def sat(maxes: List[int], nums=[-100, 14, -45, 92, 36, -68, -40]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True", "target": ""}
{"module": "human_eval.py", "name": "RollingMax:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#9", "sol_bodies": ["    return [max(nums[:i]) for i in range(1, len(nums) + 1)]", "    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"], "sol_header": "def sol(nums=[23, -34, 96]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"", "weight": 1.0, "sat": "def sat(maxes: List[int], nums=[23, -34, 96]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True", "input": "def sat(maxes: List[int], nums=[23, -34, 96]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True", "target": ""}
{"module": "human_eval.py", "name": "PalindromeContaining:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#10", "sol_bodies": ["    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""], "sol_header": "def sol(s=\"so easy\", length=20):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"so easy\", length=20):\n    return ans == ans[::-1] and len(ans) == length and s in ans", "input": "def sat(ans: str, s=\"so easy\", length=20):\n    return ans == ans[::-1] and len(ans) == length and s in ans", "target": ""}
{"module": "human_eval.py", "name": "PalindromeContaining:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#10", "sol_bodies": ["    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""], "sol_header": "def sol(s=\"aabbab\", length=12):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"aabbab\", length=12):\n    return ans == ans[::-1] and len(ans) == length and s in ans", "input": "def sat(ans: str, s=\"aabbab\", length=12):\n    return ans == ans[::-1] and len(ans) == length and s in ans", "target": ""}
{"module": "human_eval.py", "name": "PalindromeContaining:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#10", "sol_bodies": ["    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""], "sol_header": "def sol(s=\"bbb\", length=27):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"bbb\", length=27):\n    return ans == ans[::-1] and len(ans) == length and s in ans", "input": "def sat(ans: str, s=\"bbb\", length=27):\n    return ans == ans[::-1] and len(ans) == length and s in ans", "target": ""}
{"module": "human_eval.py", "name": "PalindromeContaining:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#10", "sol_bodies": ["    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""], "sol_header": "def sol(s=\"bb\", length=38):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"bb\", length=38):\n    return ans == ans[::-1] and len(ans) == length and s in ans", "input": "def sat(ans: str, s=\"bb\", length=38):\n    return ans == ans[::-1] and len(ans) == length and s in ans", "target": ""}
{"module": "human_eval.py", "name": "PalindromeContaining:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#10", "sol_bodies": ["    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""], "sol_header": "def sol(s=\"\", length=0):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"\", length=0):\n    return ans == ans[::-1] and len(ans) == length and s in ans", "input": "def sat(ans: str, s=\"\", length=0):\n    return ans == ans[::-1] and len(ans) == length and s in ans", "target": ""}
{"module": "human_eval.py", "name": "BinaryStrXOR:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#11", "sol_bodies": ["    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"], "sol_header": "def sol(nums=['100011101100001', '100101100101110']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(str_num: str, nums=['100011101100001', '100101100101110']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)", "input": "def sat(str_num: str, nums=['100011101100001', '100101100101110']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)", "target": ""}
{"module": "human_eval.py", "name": "BinaryStrXOR:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#11", "sol_bodies": ["    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"], "sol_header": "def sol(nums=['1101101111', '11001100']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(str_num: str, nums=['1101101111', '11001100']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)", "input": "def sat(str_num: str, nums=['1101101111', '11001100']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)", "target": ""}
{"module": "human_eval.py", "name": "BinaryStrXOR:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#11", "sol_bodies": ["    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"], "sol_header": "def sol(nums=['11011111', '1101001110']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(str_num: str, nums=['11011111', '1101001110']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)", "input": "def sat(str_num: str, nums=['11011111', '1101001110']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)", "target": ""}
{"module": "human_eval.py", "name": "BinaryStrXOR:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#11", "sol_bodies": ["    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"], "sol_header": "def sol(nums=['100000001', '1010001001']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(str_num: str, nums=['100000001', '1010001001']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)", "input": "def sat(str_num: str, nums=['100000001', '1010001001']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)", "target": ""}
{"module": "human_eval.py", "name": "BinaryStrXOR:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#11", "sol_bodies": ["    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"], "sol_header": "def sol(nums=['10010110', '10000']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(str_num: str, nums=['10010110', '10000']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)", "input": "def sat(str_num: str, nums=['10010110', '10000']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)", "target": ""}
{"module": "human_eval.py", "name": "LongestStr:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#12", "sol_bodies": ["    return max(words, key=len)"], "sol_header": "def sol(words=['these', 'are', 'some', 'pretty', 'long', 'words']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, words=['these', 'are', 'some', 'pretty', 'long', 'words']):\n    return ans in words and all(len(ans) >= len(w) for w in words)", "input": "def sat(ans: str, words=['these', 'are', 'some', 'pretty', 'long', 'words']):\n    return ans in words and all(len(ans) >= len(w) for w in words)", "target": ""}
{"module": "human_eval.py", "name": "LongestStr:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#12", "sol_bodies": ["    return max(words, key=len)"], "sol_header": "def sol(words=['suquojurethy', 'zetenejubichicyj', 'dyzeroquyxipyfe']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, words=['suquojurethy', 'zetenejubichicyj', 'dyzeroquyxipyfe']):\n    return ans in words and all(len(ans) >= len(w) for w in words)", "input": "def sat(ans: str, words=['suquojurethy', 'zetenejubichicyj', 'dyzeroquyxipyfe']):\n    return ans in words and all(len(ans) >= len(w) for w in words)", "target": ""}
{"module": "human_eval.py", "name": "LongestStr:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#12", "sol_bodies": ["    return max(words, key=len)"], "sol_header": "def sol(words=['thusisequiw', 'tevozequetextupetha', 'texterut', 'zopuhesofowyk', 'chajokapechunekizic', 'hefuhyjiwakifyma', 'thopebom', 'pah']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, words=['thusisequiw', 'tevozequetextupetha', 'texterut', 'zopuhesofowyk', 'chajokapechunekizic', 'hefuhyjiwakifyma', 'thopebom', 'pah']):\n    return ans in words and all(len(ans) >= len(w) for w in words)", "input": "def sat(ans: str, words=['thusisequiw', 'tevozequetextupetha', 'texterut', 'zopuhesofowyk', 'chajokapechunekizic', 'hefuhyjiwakifyma', 'thopebom', 'pah']):\n    return ans in words and all(len(ans) >= len(w) for w in words)", "target": ""}
{"module": "human_eval.py", "name": "LongestStr:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#12", "sol_bodies": ["    return max(words, key=len)"], "sol_header": "def sol(words=['melo', 'zoj', 'wujololyfytew', 'barivitextyte', 'decipywiduvaq', 'ruty', 'gekusoduz']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, words=['melo', 'zoj', 'wujololyfytew', 'barivitextyte', 'decipywiduvaq', 'ruty', 'gekusoduz']):\n    return ans in words and all(len(ans) >= len(w) for w in words)", "input": "def sat(ans: str, words=['melo', 'zoj', 'wujololyfytew', 'barivitextyte', 'decipywiduvaq', 'ruty', 'gekusoduz']):\n    return ans in words and all(len(ans) >= len(w) for w in words)", "target": ""}
{"module": "human_eval.py", "name": "LongestStr:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#12", "sol_bodies": ["    return max(words, key=len)"], "sol_header": "def sol(words=['quicydynigatha', 'pethiquifegosych', 'jixotextoxa', 'pe', 'xona', 'cifuco', 'gyrejypifam']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, words=['quicydynigatha', 'pethiquifegosych', 'jixotextoxa', 'pe', 'xona', 'cifuco', 'gyrejypifam']):\n    return ans in words and all(len(ans) >= len(w) for w in words)", "input": "def sat(ans: str, words=['quicydynigatha', 'pethiquifegosych', 'jixotextoxa', 'pe', 'xona', 'cifuco', 'gyrejypifam']):\n    return ans in words and all(len(ans) >= len(w) for w in words)", "target": ""}
{"module": "human_eval.py", "name": "CertifiedGCD:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#13", "sol_bodies": ["    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"], "sol_header": "def sol(m=200004931, n=66679984):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], m=200004931, n=66679984):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0", "input": "def sat(ans: List[int], m=200004931, n=66679984):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0", "target": ""}
{"module": "human_eval.py", "name": "CertifiedGCD:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#13", "sol_bodies": ["    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"], "sol_header": "def sol(m=2642408, n=828886):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], m=2642408, n=828886):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0", "input": "def sat(ans: List[int], m=2642408, n=828886):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0", "target": ""}
{"module": "human_eval.py", "name": "CertifiedGCD:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#13", "sol_bodies": ["    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"], "sol_header": "def sol(m=184428, n=105545439738):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], m=184428, n=105545439738):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0", "input": "def sat(ans: List[int], m=184428, n=105545439738):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0", "target": ""}
{"module": "human_eval.py", "name": "CertifiedGCD:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#13", "sol_bodies": ["    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"], "sol_header": "def sol(m=3956548155, n=103530):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], m=3956548155, n=103530):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0", "input": "def sat(ans: List[int], m=3956548155, n=103530):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0", "target": ""}
{"module": "human_eval.py", "name": "CertifiedGCD:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#13", "sol_bodies": ["    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"], "sol_header": "def sol(m=101920, n=55199657760):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], m=101920, n=55199657760):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0", "input": "def sat(ans: List[int], m=101920, n=55199657760):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0", "target": ""}
{"module": "human_eval.py", "name": "AllPrefixes:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#14", "sol_bodies": ["    return [s[:i] for i in range(len(s) + 1)]"], "sol_header": "def sol(s=\"donesezichethofalij\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(prefixes: List[str], s=\"donesezichethofalij\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)", "input": "def sat(prefixes: List[str], s=\"donesezichethofalij\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)", "target": ""}
{"module": "human_eval.py", "name": "AllPrefixes:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#14", "sol_bodies": ["    return [s[:i] for i in range(len(s) + 1)]"], "sol_header": "def sol(s=\"vuf\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(prefixes: List[str], s=\"vuf\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)", "input": "def sat(prefixes: List[str], s=\"vuf\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)", "target": ""}
{"module": "human_eval.py", "name": "AllPrefixes:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#14", "sol_bodies": ["    return [s[:i] for i in range(len(s) + 1)]"], "sol_header": "def sol(s=\"t\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(prefixes: List[str], s=\"t\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)", "input": "def sat(prefixes: List[str], s=\"t\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)", "target": ""}
{"module": "human_eval.py", "name": "AllPrefixes:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#14", "sol_bodies": ["    return [s[:i] for i in range(len(s) + 1)]"], "sol_header": "def sol(s=\"qu\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(prefixes: List[str], s=\"qu\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)", "input": "def sat(prefixes: List[str], s=\"qu\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)", "target": ""}
{"module": "human_eval.py", "name": "AllPrefixes:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#14", "sol_bodies": ["    return [s[:i] for i in range(len(s) + 1)]"], "sol_header": "def sol(s=\"dugethixuneku\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(prefixes: List[str], s=\"dugethixuneku\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)", "input": "def sat(prefixes: List[str], s=\"dugethixuneku\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)", "target": ""}
{"module": "human_eval.py", "name": "SpaceyRange:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#15", "sol_bodies": ["    return ' '.join(str(i) for i in range(n + 1))"], "sol_header": "def sol(n=15):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, n=15):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))", "input": "def sat(ans: str, n=15):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))", "target": ""}
{"module": "human_eval.py", "name": "SpaceyRange:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#15", "sol_bodies": ["    return ' '.join(str(i) for i in range(n + 1))"], "sol_header": "def sol(n=54635):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, n=54635):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))", "input": "def sat(ans: str, n=54635):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))", "target": ""}
{"module": "human_eval.py", "name": "SpaceyRange:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#15", "sol_bodies": ["    return ' '.join(str(i) for i in range(n + 1))"], "sol_header": "def sol(n=83):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, n=83):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))", "input": "def sat(ans: str, n=83):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))", "target": ""}
{"module": "human_eval.py", "name": "SpaceyRange:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#15", "sol_bodies": ["    return ' '.join(str(i) for i in range(n + 1))"], "sol_header": "def sol(n=99847):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, n=99847):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))", "input": "def sat(ans: str, n=99847):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))", "target": ""}
{"module": "human_eval.py", "name": "SpaceyRange:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#15", "sol_bodies": ["    return ' '.join(str(i) for i in range(n + 1))"], "sol_header": "def sol(n=18215):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, n=18215):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))", "input": "def sat(ans: str, n=18215):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))", "target": ""}
{"module": "human_eval.py", "name": "DistinctChars:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#16", "sol_bodies": ["    return list(set(s.lower()))"], "sol_header": "def sol(s=\"The quick brown fox jumps over the lazy dog!\", n=28):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[str], s=\"The quick brown fox jumps over the lazy dog!\", n=28):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True", "input": "def sat(ans: List[str], s=\"The quick brown fox jumps over the lazy dog!\", n=28):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "DistinctChars:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#16", "sol_bodies": ["    return list(set(s.lower()))"], "sol_header": "def sol(s=\"Iu]K,>Q8w\", n=9):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[str], s=\"Iu]K,>Q8w\", n=9):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True", "input": "def sat(ans: List[str], s=\"Iu]K,>Q8w\", n=9):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "DistinctChars:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#16", "sol_bodies": ["    return list(set(s.lower()))"], "sol_header": "def sol(s=\"JrUCk=ek&q^xBuvtm\", n=15):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[str], s=\"JrUCk=ek&q^xBuvtm\", n=15):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True", "input": "def sat(ans: List[str], s=\"JrUCk=ek&q^xBuvtm\", n=15):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "DistinctChars:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#16", "sol_bodies": ["    return list(set(s.lower()))"], "sol_header": "def sol(s=\"V-wKeN\", n=6):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[str], s=\"V-wKeN\", n=6):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True", "input": "def sat(ans: List[str], s=\"V-wKeN\", n=6):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "DistinctChars:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#16", "sol_bodies": ["    return list(set(s.lower()))"], "sol_header": "def sol(s=\"F;J*qHN.^YC\", n=11):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[str], s=\"F;J*qHN.^YC\", n=11):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True", "input": "def sat(ans: List[str], s=\"F;J*qHN.^YC\", n=11):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "ParseMusic:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#17", "sol_bodies": ["    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"], "sol_header": "def sol(score=\"o o o| o| .| .| .| o| o| o o o| .|\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(beats: List[int], score=\"o o o| o| .| .| .| o| o| o o o| .|\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score", "input": "def sat(beats: List[int], score=\"o o o| o| .| .| .| o| o| o o o| .|\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score", "target": ""}
{"module": "human_eval.py", "name": "ParseMusic:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#17", "sol_bodies": ["    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"], "sol_header": "def sol(score=\".| o .| o| o| o| o| .| o o\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(beats: List[int], score=\".| o .| o| o| o| o| .| o o\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score", "input": "def sat(beats: List[int], score=\".| o .| o| o| o| o| .| o o\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score", "target": ""}
{"module": "human_eval.py", "name": "ParseMusic:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#17", "sol_bodies": ["    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"], "sol_header": "def sol(score=\"o| .| .| .| .| o| o .| o| o| o\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(beats: List[int], score=\"o| .| .| .| .| o| o .| o| o| o\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score", "input": "def sat(beats: List[int], score=\"o| .| .| .| .| o| o .| o| o| o\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score", "target": ""}
{"module": "human_eval.py", "name": "ParseMusic:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#17", "sol_bodies": ["    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"], "sol_header": "def sol(score=\".| o|\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(beats: List[int], score=\".| o|\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score", "input": "def sat(beats: List[int], score=\".| o|\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score", "target": ""}
{"module": "human_eval.py", "name": "ParseMusic:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#17", "sol_bodies": ["    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"], "sol_header": "def sol(score=\"\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(beats: List[int], score=\"\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score", "input": "def sat(beats: List[int], score=\"\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score", "target": ""}
{"module": "human_eval.py", "name": "OverlappingCount:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#18", "sol_bodies": ["    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"], "sol_header": "def sol(s=\"Bananannanaannanaanananananana\", sub=\"anan\", count=7):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], s=\"Bananannanaannanaanananananana\", sub=\"anan\", count=7):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count", "input": "def sat(ans: List[int], s=\"Bananannanaannanaanananananana\", sub=\"anan\", count=7):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count", "target": ""}
{"module": "human_eval.py", "name": "OverlappingCount:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#18", "sol_bodies": ["    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"], "sol_header": "def sol(s=\"halidykugadobezebothidububawuvejiquitextyrequamobythynethojahyquutatextoquuzilu\", sub=\"ne\", count=1):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], s=\"halidykugadobezebothidububawuvejiquitextyrequamobythynethojahyquutatextoquuzilu\", sub=\"ne\", count=1):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count", "input": "def sat(ans: List[int], s=\"halidykugadobezebothidububawuvejiquitextyrequamobythynethojahyquutatextoquuzilu\", sub=\"ne\", count=1):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count", "target": ""}
{"module": "human_eval.py", "name": "OverlappingCount:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#18", "sol_bodies": ["    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"], "sol_header": "def sol(s=\"sutapifitextidavyjedakotextopogonudy\", sub=\"te\", count=2):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], s=\"sutapifitextidavyjedakotextopogonudy\", sub=\"te\", count=2):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count", "input": "def sat(ans: List[int], s=\"sutapifitextidavyjedakotextopogonudy\", sub=\"te\", count=2):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count", "target": ""}
{"module": "human_eval.py", "name": "OverlappingCount:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#18", "sol_bodies": ["    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"], "sol_header": "def sol(s=\"fizyquohachoromuxuquatextidemihithacazynytytextukozarahuwyfuchyquyhidadytext\", sub=\"quohach\", count=1):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], s=\"fizyquohachoromuxuquatextidemihithacazynytytextukozarahuwyfuchyquyhidadytext\", sub=\"quohach\", count=1):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count", "input": "def sat(ans: List[int], s=\"fizyquohachoromuxuquatextidemihithacazynytytextukozarahuwyfuchyquyhidadytext\", sub=\"quohach\", count=1):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count", "target": ""}
{"module": "human_eval.py", "name": "OverlappingCount:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#18", "sol_bodies": ["    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"], "sol_header": "def sol(s=\"wutextega\", sub=\"xtega\", count=1):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], s=\"wutextega\", sub=\"xtega\", count=1):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count", "input": "def sat(ans: List[int], s=\"wutextega\", sub=\"xtega\", count=1):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count", "target": ""}
{"module": "human_eval.py", "name": "SortNumbers:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#19", "sol_bodies": ["    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"], "sol_header": "def sol(s=\"six one four three two nine eight\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"six one four three two nine eight\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])", "input": "def sat(ans: str, s=\"six one four three two nine eight\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])", "target": ""}
{"module": "human_eval.py", "name": "SortNumbers:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#19", "sol_bodies": ["    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"], "sol_header": "def sol(s=\"nine two four nine zero six six eight\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"nine two four nine zero six six eight\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])", "input": "def sat(ans: str, s=\"nine two four nine zero six six eight\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])", "target": ""}
{"module": "human_eval.py", "name": "SortNumbers:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#19", "sol_bodies": ["    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"], "sol_header": "def sol(s=\"nine six two\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"nine six two\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])", "input": "def sat(ans: str, s=\"nine six two\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])", "target": ""}
{"module": "human_eval.py", "name": "SortNumbers:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#19", "sol_bodies": ["    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"], "sol_header": "def sol(s=\"five nine four eight\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"five nine four eight\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])", "input": "def sat(ans: str, s=\"five nine four eight\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])", "target": ""}
{"module": "human_eval.py", "name": "SortNumbers:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#19", "sol_bodies": ["    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"], "sol_header": "def sol(s=\"seven eight seven zero zero five one\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"seven eight seven zero zero five one\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])", "input": "def sat(ans: str, s=\"seven eight seven zero zero five one\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])", "target": ""}
{"module": "human_eval.py", "name": "FindClosePair:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#20", "sol_bodies": ["    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"], "sol_header": "def sol(nums=[0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True", "input": "def sat(inds: List[int], nums=[0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FindClosePair:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#20", "sol_bodies": ["    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"], "sol_header": "def sol(nums=[-7.587461542549912, 0.7494004368541578, 2.0142388071411013, -1.552072793834526, 0.44845194836415025]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[-7.587461542549912, 0.7494004368541578, 2.0142388071411013, -1.552072793834526, 0.44845194836415025]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True", "input": "def sat(inds: List[int], nums=[-7.587461542549912, 0.7494004368541578, 2.0142388071411013, -1.552072793834526, 0.44845194836415025]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FindClosePair:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#20", "sol_bodies": ["    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"], "sol_header": "def sol(nums=[-5.253924550449174, 7.798134742325132, 2.84274998450722, -5.355403889716619, -8.14069894708204, 6.276599656475899]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[-5.253924550449174, 7.798134742325132, 2.84274998450722, -5.355403889716619, -8.14069894708204, 6.276599656475899]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True", "input": "def sat(inds: List[int], nums=[-5.253924550449174, 7.798134742325132, 2.84274998450722, -5.355403889716619, -8.14069894708204, 6.276599656475899]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FindClosePair:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#20", "sol_bodies": ["    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"], "sol_header": "def sol(nums=[8.647950767409466, 6.069423836495417, 8.647950767409466, -4.483139827348948, 7.822521892934297, 6.339621174459673]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[8.647950767409466, 6.069423836495417, 8.647950767409466, -4.483139827348948, 7.822521892934297, 6.339621174459673]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True", "input": "def sat(inds: List[int], nums=[8.647950767409466, 6.069423836495417, 8.647950767409466, -4.483139827348948, 7.822521892934297, 6.339621174459673]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FindClosePair:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#20", "sol_bodies": ["    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"], "sol_header": "def sol(nums=[-2.4491102095531385, -2.4896924424294635]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[-2.4491102095531385, -2.4896924424294635]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True", "input": "def sat(inds: List[int], nums=[-2.4491102095531385, -2.4896924424294635]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True", "target": ""}
{"module": "human_eval.py", "name": "Rescale:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#21", "sol_bodies": ["    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"], "sol_header": "def sol(nums=[13.0, 17.0, 17.0, 15.5, 2.94]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[float], nums=[13.0, 17.0, 17.0, 15.5, 2.94]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True", "input": "def sat(ans: List[float], nums=[13.0, 17.0, 17.0, 15.5, 2.94]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True", "target": ""}
{"module": "human_eval.py", "name": "Rescale:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#21", "sol_bodies": ["    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"], "sol_header": "def sol(nums=[939.7119884829771, 939.7119884829771, 939.7119884829771]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[float], nums=[939.7119884829771, 939.7119884829771, 939.7119884829771]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True", "input": "def sat(ans: List[float], nums=[939.7119884829771, 939.7119884829771, 939.7119884829771]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True", "target": ""}
{"module": "human_eval.py", "name": "Rescale:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#21", "sol_bodies": ["    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"], "sol_header": "def sol(nums=[0.4458061970026967, -3.9939008694208376, -1.0757147773525169, 0.3895998276095692, 2.0191942234485825, -0.23989163788911685, -0.003822778565885754, -0.8237835423706446, -0.08413275419390705]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[float], nums=[0.4458061970026967, -3.9939008694208376, -1.0757147773525169, 0.3895998276095692, 2.0191942234485825, -0.23989163788911685, -0.003822778565885754, -0.8237835423706446, -0.08413275419390705]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True", "input": "def sat(ans: List[float], nums=[0.4458061970026967, -3.9939008694208376, -1.0757147773525169, 0.3895998276095692, 2.0191942234485825, -0.23989163788911685, -0.003822778565885754, -0.8237835423706446, -0.08413275419390705]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True", "target": ""}
{"module": "human_eval.py", "name": "Rescale:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#21", "sol_bodies": ["    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"], "sol_header": "def sol(nums=[1.7162662285160908, -0.5573868669921508, -11.304736303883987, 1.166009156041828, 2.1833750395727782, 4.274594378665487, -0.45875107135742743, 0.0046661656727550556, 0.8537569786748028]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[float], nums=[1.7162662285160908, -0.5573868669921508, -11.304736303883987, 1.166009156041828, 2.1833750395727782, 4.274594378665487, -0.45875107135742743, 0.0046661656727550556, 0.8537569786748028]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True", "input": "def sat(ans: List[float], nums=[1.7162662285160908, -0.5573868669921508, -11.304736303883987, 1.166009156041828, 2.1833750395727782, 4.274594378665487, -0.45875107135742743, 0.0046661656727550556, 0.8537569786748028]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True", "target": ""}
{"module": "human_eval.py", "name": "Rescale:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#21", "sol_bodies": ["    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"], "sol_header": "def sol(nums=[23.976551109194304, 1.4655002766247416]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[float], nums=[23.976551109194304, 1.4655002766247416]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True", "input": "def sat(ans: List[float], nums=[23.976551109194304, 1.4655002766247416]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FilterInts:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#22", "sol_bodies": ["    if not int_indices:\n        return []\n    ans = [\"\"] * (1 + max(abs(i) for i in int_indices))\n    for i in int_indices:\n        ans[i] = \"17\"\n    return ans"], "sol_header": "def sol(int_indices=[2, 4, 7, 9, 101]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of strings where the only valid integers are at the given indices\n\n    Sample input\n    ---\n    [2, 4, 5]\n\n    Sample output\n    ---\n    [\"cat\", \"2.7\", \"2\", \"\", \"3\", \"-17\", \"free\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(candidates: List[str], int_indices=[2, 4, 7, 9, 101]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True", "input": "def sat(candidates: List[str], int_indices=[2, 4, 7, 9, 101]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FilterInts:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#22", "sol_bodies": ["    if not int_indices:\n        return []\n    ans = [\"\"] * (1 + max(abs(i) for i in int_indices))\n    for i in int_indices:\n        ans[i] = \"17\"\n    return ans"], "sol_header": "def sol(int_indices=[80, 17, 74]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of strings where the only valid integers are at the given indices\n\n    Sample input\n    ---\n    [2, 4, 5]\n\n    Sample output\n    ---\n    [\"cat\", \"2.7\", \"2\", \"\", \"3\", \"-17\", \"free\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(candidates: List[str], int_indices=[80, 17, 74]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True", "input": "def sat(candidates: List[str], int_indices=[80, 17, 74]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FilterInts:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#22", "sol_bodies": ["    if not int_indices:\n        return []\n    ans = [\"\"] * (1 + max(abs(i) for i in int_indices))\n    for i in int_indices:\n        ans[i] = \"17\"\n    return ans"], "sol_header": "def sol(int_indices=[56, 37, 17, 83, 35, 22, 4, 78, 79]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of strings where the only valid integers are at the given indices\n\n    Sample input\n    ---\n    [2, 4, 5]\n\n    Sample output\n    ---\n    [\"cat\", \"2.7\", \"2\", \"\", \"3\", \"-17\", \"free\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(candidates: List[str], int_indices=[56, 37, 17, 83, 35, 22, 4, 78, 79]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True", "input": "def sat(candidates: List[str], int_indices=[56, 37, 17, 83, 35, 22, 4, 78, 79]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FilterInts:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#22", "sol_bodies": ["    if not int_indices:\n        return []\n    ans = [\"\"] * (1 + max(abs(i) for i in int_indices))\n    for i in int_indices:\n        ans[i] = \"17\"\n    return ans"], "sol_header": "def sol(int_indices=[25, 65]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of strings where the only valid integers are at the given indices\n\n    Sample input\n    ---\n    [2, 4, 5]\n\n    Sample output\n    ---\n    [\"cat\", \"2.7\", \"2\", \"\", \"3\", \"-17\", \"free\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(candidates: List[str], int_indices=[25, 65]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True", "input": "def sat(candidates: List[str], int_indices=[25, 65]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FilterInts:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#22", "sol_bodies": ["    if not int_indices:\n        return []\n    ans = [\"\"] * (1 + max(abs(i) for i in int_indices))\n    for i in int_indices:\n        ans[i] = \"17\"\n    return ans"], "sol_header": "def sol(int_indices=[92, 74, 83, 90, 9, 76, 66, 0]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of strings where the only valid integers are at the given indices\n\n    Sample input\n    ---\n    [2, 4, 5]\n\n    Sample output\n    ---\n    [\"cat\", \"2.7\", \"2\", \"\", \"3\", \"-17\", \"free\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(candidates: List[str], int_indices=[92, 74, 83, 90, 9, 76, 66, 0]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True", "input": "def sat(candidates: List[str], int_indices=[92, 74, 83, 90, 9, 76, 66, 0]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True", "target": ""}
{"module": "human_eval.py", "name": "StrLength:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#23", "sol_bodies": ["    return [len(s) for s in strs]"], "sol_header": "def sol(strs=['pneumonoultramicroscopicsilicovolcanoconiosis', ' ', 'foo', '2.5']):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the lengths of a list of non-empty strings\n\n    Sample input\n    ---\n    [\"foo\", \"bars\"]\n\n    Sample output\n    ---\n    [3, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(lengths: List[int], strs=['pneumonoultramicroscopicsilicovolcanoconiosis', ' ', 'foo', '2.5']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)", "input": "def sat(lengths: List[int], strs=['pneumonoultramicroscopicsilicovolcanoconiosis', ' ', 'foo', '2.5']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)", "target": ""}
{"module": "human_eval.py", "name": "StrLength:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#23", "sol_bodies": ["    return [len(s) for s in strs]"], "sol_header": "def sol(strs=['=i', '&?Jq 2aNHt', '?uCcQht', 'e>8=4jZNfhZl3&Mko-MfWd<^QR Vf7:2M', ']Y,G2U4ur-7X,T@(Gv$:Y0^C,-$+xM9$X2,*90|', '+>&?Qa%yLWZA2nBDQ8i)zvVWT', 'Ly+NcKgOvg3J)', 's$0^cow)Q917uY', 'ZSA$sIKe|pz@|[<kk,h[eFCiD#xxN7*G*Ic', '2q7eG maF4Gi8gJvJr[mgY,[jt(VL|2']):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the lengths of a list of non-empty strings\n\n    Sample input\n    ---\n    [\"foo\", \"bars\"]\n\n    Sample output\n    ---\n    [3, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(lengths: List[int], strs=['=i', '&?Jq 2aNHt', '?uCcQht', 'e>8=4jZNfhZl3&Mko-MfWd<^QR Vf7:2M', ']Y,G2U4ur-7X,T@(Gv$:Y0^C,-$+xM9$X2,*90|', '+>&?Qa%yLWZA2nBDQ8i)zvVWT', 'Ly+NcKgOvg3J)', 's$0^cow)Q917uY', 'ZSA$sIKe|pz@|[<kk,h[eFCiD#xxN7*G*Ic', '2q7eG maF4Gi8gJvJr[mgY,[jt(VL|2']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)", "input": "def sat(lengths: List[int], strs=['=i', '&?Jq 2aNHt', '?uCcQht', 'e>8=4jZNfhZl3&Mko-MfWd<^QR Vf7:2M', ']Y,G2U4ur-7X,T@(Gv$:Y0^C,-$+xM9$X2,*90|', '+>&?Qa%yLWZA2nBDQ8i)zvVWT', 'Ly+NcKgOvg3J)', 's$0^cow)Q917uY', 'ZSA$sIKe|pz@|[<kk,h[eFCiD#xxN7*G*Ic', '2q7eG maF4Gi8gJvJr[mgY,[jt(VL|2']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)", "target": ""}
{"module": "human_eval.py", "name": "StrLength:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#23", "sol_bodies": ["    return [len(s) for s in strs]"], "sol_header": "def sol(strs=['A/io]X92K;9aWaICuk7[]p|;af9#L#&aIk6I4E=c8u', '64P#$', 'cOpGRh3@ RoUho:YtF9L>/%4=%?ry(+2', '&.Qf?cuJI%m.>pBZY', 'FUeoE;h(#,f5<jC>[%xwK9@EU', '2NNz-,|C*]Vu9E7|!7mA+ oM9<N', '[3 !D2ddGb4aY17(=Q7lQZ&f H)Hrp)]VHFnxy6Jp', 'wg#VJiO-', 'jwBAk$XQ&*95d;[j,Y+', '!t:$CE#)+Pk7De*V|*&Z@u&0+gIhto/&.P*=q|!hw']):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the lengths of a list of non-empty strings\n\n    Sample input\n    ---\n    [\"foo\", \"bars\"]\n\n    Sample output\n    ---\n    [3, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(lengths: List[int], strs=['A/io]X92K;9aWaICuk7[]p|;af9#L#&aIk6I4E=c8u', '64P#$', 'cOpGRh3@ RoUho:YtF9L>/%4=%?ry(+2', '&.Qf?cuJI%m.>pBZY', 'FUeoE;h(#,f5<jC>[%xwK9@EU', '2NNz-,|C*]Vu9E7|!7mA+ oM9<N', '[3 !D2ddGb4aY17(=Q7lQZ&f H)Hrp)]VHFnxy6Jp', 'wg#VJiO-', 'jwBAk$XQ&*95d;[j,Y+', '!t:$CE#)+Pk7De*V|*&Z@u&0+gIhto/&.P*=q|!hw']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)", "input": "def sat(lengths: List[int], strs=['A/io]X92K;9aWaICuk7[]p|;af9#L#&aIk6I4E=c8u', '64P#$', 'cOpGRh3@ RoUho:YtF9L>/%4=%?ry(+2', '&.Qf?cuJI%m.>pBZY', 'FUeoE;h(#,f5<jC>[%xwK9@EU', '2NNz-,|C*]Vu9E7|!7mA+ oM9<N', '[3 !D2ddGb4aY17(=Q7lQZ&f H)Hrp)]VHFnxy6Jp', 'wg#VJiO-', 'jwBAk$XQ&*95d;[j,Y+', '!t:$CE#)+Pk7De*V|*&Z@u&0+gIhto/&.P*=q|!hw']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)", "target": ""}
{"module": "human_eval.py", "name": "StrLength:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#23", "sol_bodies": ["    return [len(s) for s in strs]"], "sol_header": "def sol(strs=['ij+OUM5ZP Q3?', '^D.i+GLGID@2oUVF4', 'VaLA:aPP@5eKY,WK9MS*Ez', '.%fR+&q&0>Y(l%O2ub5<YXU#K.?9g', 'bO6[sMEL.g0^+r0', 'yCKQT^6Ug4al|r!PiMOF[KHz^%:WYTi]-G', '4lORJ/yub%d5gR@@>ciSw-]geHu6NgF9au)r', 'ED!Bz=4nF6  z^kMW-3-&<Eoc9B604*yscpnhcmJ?/', '?!u7%E0G4Z.r- V9LL 1Cd(W9eL=E^58a2xuf)ZYj-ILLW', 'A|NlyRr8uQG2eJm4y<Bu,r#fz&eNB]=hp']):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the lengths of a list of non-empty strings\n\n    Sample input\n    ---\n    [\"foo\", \"bars\"]\n\n    Sample output\n    ---\n    [3, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(lengths: List[int], strs=['ij+OUM5ZP Q3?', '^D.i+GLGID@2oUVF4', 'VaLA:aPP@5eKY,WK9MS*Ez', '.%fR+&q&0>Y(l%O2ub5<YXU#K.?9g', 'bO6[sMEL.g0^+r0', 'yCKQT^6Ug4al|r!PiMOF[KHz^%:WYTi]-G', '4lORJ/yub%d5gR@@>ciSw-]geHu6NgF9au)r', 'ED!Bz=4nF6  z^kMW-3-&<Eoc9B604*yscpnhcmJ?/', '?!u7%E0G4Z.r- V9LL 1Cd(W9eL=E^58a2xuf)ZYj-ILLW', 'A|NlyRr8uQG2eJm4y<Bu,r#fz&eNB]=hp']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)", "input": "def sat(lengths: List[int], strs=['ij+OUM5ZP Q3?', '^D.i+GLGID@2oUVF4', 'VaLA:aPP@5eKY,WK9MS*Ez', '.%fR+&q&0>Y(l%O2ub5<YXU#K.?9g', 'bO6[sMEL.g0^+r0', 'yCKQT^6Ug4al|r!PiMOF[KHz^%:WYTi]-G', '4lORJ/yub%d5gR@@>ciSw-]geHu6NgF9au)r', 'ED!Bz=4nF6  z^kMW-3-&<Eoc9B604*yscpnhcmJ?/', '?!u7%E0G4Z.r- V9LL 1Cd(W9eL=E^58a2xuf)ZYj-ILLW', 'A|NlyRr8uQG2eJm4y<Bu,r#fz&eNB]=hp']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)", "target": ""}
{"module": "human_eval.py", "name": "StrLength:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#23", "sol_bodies": ["    return [len(s) for s in strs]"], "sol_header": "def sol(strs=['g', ';TWy9!004X#d7!0p ', 'eaX%:#7S2IIIUe&#r3=EB1;5K)3j;1Vn', ']cz!vZ]Wq&O]sMR8D', ')o=#sAp-c8:SM&.yRBpCMmS)-', 'Ql d.i(UA/|sFqHQ/c3M>p]exH|sgXQt', 'mwoa[nS-[%R(rf5!)9o.M[', '23Q0Sugd(RKZ+GuLu', 'x^VP2ZX$8', 'q7(GrHGkG6er!7hX+ZeKolCgdlqI0(*um']):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the lengths of a list of non-empty strings\n\n    Sample input\n    ---\n    [\"foo\", \"bars\"]\n\n    Sample output\n    ---\n    [3, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(lengths: List[int], strs=['g', ';TWy9!004X#d7!0p ', 'eaX%:#7S2IIIUe&#r3=EB1;5K)3j;1Vn', ']cz!vZ]Wq&O]sMR8D', ')o=#sAp-c8:SM&.yRBpCMmS)-', 'Ql d.i(UA/|sFqHQ/c3M>p]exH|sgXQt', 'mwoa[nS-[%R(rf5!)9o.M[', '23Q0Sugd(RKZ+GuLu', 'x^VP2ZX$8', 'q7(GrHGkG6er!7hX+ZeKolCgdlqI0(*um']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)", "input": "def sat(lengths: List[int], strs=['g', ';TWy9!004X#d7!0p ', 'eaX%:#7S2IIIUe&#r3=EB1;5K)3j;1Vn', ']cz!vZ]Wq&O]sMR8D', ')o=#sAp-c8:SM&.yRBpCMmS)-', 'Ql d.i(UA/|sFqHQ/c3M>p]exH|sgXQt', 'mwoa[nS-[%R(rf5!)9o.M[', '23Q0Sugd(RKZ+GuLu', 'x^VP2ZX$8', 'q7(GrHGkG6er!7hX+ZeKolCgdlqI0(*um']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)", "target": ""}
{"module": "human_eval.py", "name": "LargestDivisor:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#24", "sol_bodies": ["    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"], "sol_header": "def sol(n=123456):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"", "weight": 1.0, "sat": "def sat(d: int, n=123456):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))", "input": "def sat(d: int, n=123456):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))", "target": ""}
{"module": "human_eval.py", "name": "LargestDivisor:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#24", "sol_bodies": ["    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"], "sol_header": "def sol(n=17836):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"", "weight": 1.0, "sat": "def sat(d: int, n=17836):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))", "input": "def sat(d: int, n=17836):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))", "target": ""}
{"module": "human_eval.py", "name": "LargestDivisor:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#24", "sol_bodies": ["    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"], "sol_header": "def sol(n=71793):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"", "weight": 1.0, "sat": "def sat(d: int, n=71793):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))", "input": "def sat(d: int, n=71793):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))", "target": ""}
{"module": "human_eval.py", "name": "LargestDivisor:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#24", "sol_bodies": ["    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"], "sol_header": "def sol(n=15466):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"", "weight": 1.0, "sat": "def sat(d: int, n=15466):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))", "input": "def sat(d: int, n=15466):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))", "target": ""}
{"module": "human_eval.py", "name": "LargestDivisor:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#24", "sol_bodies": ["    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"], "sol_header": "def sol(n=57567):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"", "weight": 1.0, "sat": "def sat(d: int, n=57567):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))", "input": "def sat(d: int, n=57567):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))", "target": ""}
{"module": "human_eval.py", "name": "PrimeFactorization:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#25", "sol_bodies": ["    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"], "sol_header": "def sol(n=123456, num_factors=8):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(factors: List[int], n=123456, num_factors=8):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n", "input": "def sat(factors: List[int], n=123456, num_factors=8):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n", "target": ""}
{"module": "human_eval.py", "name": "PrimeFactorization:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#25", "sol_bodies": ["    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"], "sol_header": "def sol(n=1339030, num_factors=6):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(factors: List[int], n=1339030, num_factors=6):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n", "input": "def sat(factors: List[int], n=1339030, num_factors=6):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n", "target": ""}
{"module": "human_eval.py", "name": "PrimeFactorization:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#25", "sol_bodies": ["    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"], "sol_header": "def sol(n=141752, num_factors=6):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(factors: List[int], n=141752, num_factors=6):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n", "input": "def sat(factors: List[int], n=141752, num_factors=6):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n", "target": ""}
{"module": "human_eval.py", "name": "PrimeFactorization:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#25", "sol_bodies": ["    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"], "sol_header": "def sol(n=33088, num_factors=8):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(factors: List[int], n=33088, num_factors=8):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n", "input": "def sat(factors: List[int], n=33088, num_factors=8):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n", "target": ""}
{"module": "human_eval.py", "name": "PrimeFactorization:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#25", "sol_bodies": ["    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"], "sol_header": "def sol(n=2375171125400, num_factors=12):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(factors: List[int], n=2375171125400, num_factors=12):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n", "input": "def sat(factors: List[int], n=2375171125400, num_factors=12):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n", "target": ""}
{"module": "human_eval.py", "name": "Dedup:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#26", "sol_bodies": ["    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"], "sol_header": "def sol(li=[2, 19, 2, 53, 1, 1, 2, 44, 17, 0, 19, 31]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], li=[2, 19, 2, 53, 1, 1, 2, 44, 17, 0, 19, 31]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))", "input": "def sat(ans: List[int], li=[2, 19, 2, 53, 1, 1, 2, 44, 17, 0, 19, 31]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))", "target": ""}
{"module": "human_eval.py", "name": "Dedup:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#26", "sol_bodies": ["    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"], "sol_header": "def sol(li=[3, 3, 7, 9, 7, 2, 9, 4, 1]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], li=[3, 3, 7, 9, 7, 2, 9, 4, 1]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))", "input": "def sat(ans: List[int], li=[3, 3, 7, 9, 7, 2, 9, 4, 1]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))", "target": ""}
{"module": "human_eval.py", "name": "Dedup:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#26", "sol_bodies": ["    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"], "sol_header": "def sol(li=[3, 9, 8, 9, 3, 5, 1, 3, 5]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], li=[3, 9, 8, 9, 3, 5, 1, 3, 5]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))", "input": "def sat(ans: List[int], li=[3, 9, 8, 9, 3, 5, 1, 3, 5]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))", "target": ""}
{"module": "human_eval.py", "name": "Dedup:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#26", "sol_bodies": ["    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"], "sol_header": "def sol(li=[3, 8, 2, 1, 1, 7, 7, 7, 5, 5, 5, 9, 3, 7, 7]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], li=[3, 8, 2, 1, 1, 7, 7, 7, 5, 5, 5, 9, 3, 7, 7]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))", "input": "def sat(ans: List[int], li=[3, 8, 2, 1, 1, 7, 7, 7, 5, 5, 5, 9, 3, 7, 7]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))", "target": ""}
{"module": "human_eval.py", "name": "Dedup:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#26", "sol_bodies": ["    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"], "sol_header": "def sol(li=[0, 3, 3, 2, 7, 0, 0, 6, 2, 4, 4, 5]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], li=[0, 3, 3, 2, 7, 0, 0, 6, 2, 4, 4, 5]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))", "input": "def sat(ans: List[int], li=[0, 3, 3, 2, 7, 0, 0, 6, 2, 4, 4, 5]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))", "target": ""}
{"module": "human_eval.py", "name": "FlipCase:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#27", "sol_bodies": ["    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"], "sol_header": "def sol(s=\"FlIp ME!\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"FlIp ME!\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))", "input": "def sat(ans: str, s=\"FlIp ME!\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))", "target": ""}
{"module": "human_eval.py", "name": "FlipCase:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#27", "sol_bodies": ["    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"], "sol_header": "def sol(s=\"mKC(K2.a!Z|>sv3izC3!\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"mKC(K2.a!Z|>sv3izC3!\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))", "input": "def sat(ans: str, s=\"mKC(K2.a!Z|>sv3izC3!\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))", "target": ""}
{"module": "human_eval.py", "name": "FlipCase:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#27", "sol_bodies": ["    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"], "sol_header": "def sol(s=\"K a&3 tE 1tSG B3v3y(\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"K a&3 tE 1tSG B3v3y(\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))", "input": "def sat(ans: str, s=\"K a&3 tE 1tSG B3v3y(\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))", "target": ""}
{"module": "human_eval.py", "name": "FlipCase:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#27", "sol_bodies": ["    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"], "sol_header": "def sol(s=\"Sb31E#e<@3u\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"Sb31E#e<@3u\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))", "input": "def sat(ans: str, s=\"Sb31E#e<@3u\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))", "target": ""}
{"module": "human_eval.py", "name": "FlipCase:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#27", "sol_bodies": ["    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"], "sol_header": "def sol(s=\"q Y*.zv? !3B3::/3%F3\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: str, s=\"q Y*.zv? !3B3::/3%F3\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))", "input": "def sat(ans: str, s=\"q Y*.zv? !3B3::/3%F3\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))", "target": ""}
{"module": "human_eval.py", "name": "CatStrings:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#28", "sol_bodies": ["    return \"\".join(strings)"], "sol_header": "def sol(strings=['Will', 'i', 'am', 'Now', 'here']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"", "weight": 1.0, "sat": "def sat(cat: str, strings=['Will', 'i', 'am', 'Now', 'here']):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)", "input": "def sat(cat: str, strings=['Will', 'i', 'am', 'Now', 'here']):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)", "target": ""}
{"module": "human_eval.py", "name": "CatStrings:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#28", "sol_bodies": ["    return \"\".join(strings)"], "sol_header": "def sol(strings=['dufe', 'keret', 'kothihisedatextumuva', 'pe', 'sicelynyzysukydew', 'zu', 'kathubaki']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"", "weight": 1.0, "sat": "def sat(cat: str, strings=['dufe', 'keret', 'kothihisedatextumuva', 'pe', 'sicelynyzysukydew', 'zu', 'kathubaki']):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)", "input": "def sat(cat: str, strings=['dufe', 'keret', 'kothihisedatextumuva', 'pe', 'sicelynyzysukydew', 'zu', 'kathubaki']):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)", "target": ""}
{"module": "human_eval.py", "name": "CatStrings:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#28", "sol_bodies": ["    return \"\".join(strings)"], "sol_header": "def sol(strings=[]):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"", "weight": 1.0, "sat": "def sat(cat: str, strings=[]):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)", "input": "def sat(cat: str, strings=[]):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)", "target": ""}
{"module": "human_eval.py", "name": "CatStrings:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#28", "sol_bodies": ["    return \"\".join(strings)"], "sol_header": "def sol(strings=['c', 'vawumich', 'textucagidyhikomuro', 'wuchiquusojahoz', 'l']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"", "weight": 1.0, "sat": "def sat(cat: str, strings=['c', 'vawumich', 'textucagidyhikomuro', 'wuchiquusojahoz', 'l']):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)", "input": "def sat(cat: str, strings=['c', 'vawumich', 'textucagidyhikomuro', 'wuchiquusojahoz', 'l']):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)", "target": ""}
{"module": "human_eval.py", "name": "CatStrings:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#28", "sol_bodies": ["    return \"\".join(strings)"], "sol_header": "def sol(strings=['s', 'nutext', 'quoxezenukowyho', 'botidyhu', 'kicethytextithybaqu']):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"", "weight": 1.0, "sat": "def sat(cat: str, strings=['s', 'nutext', 'quoxezenukowyho', 'botidyhu', 'kicethytextithybaqu']):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)", "input": "def sat(cat: str, strings=['s', 'nutext', 'quoxezenukowyho', 'botidyhu', 'kicethytextithybaqu']):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)", "target": ""}
{"module": "human_eval.py", "name": "FindExtensions:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#29", "sol_bodies": ["    return [s for s in strings if s.startswith(prefix)]"], "sol_header": "def sol(strings=['cat', 'dog', 'shatter', 'donut', 'at', 'todo'], prefix=\"do\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"", "weight": 1.0, "sat": "def sat(extensions: List[str], strings=['cat', 'dog', 'shatter', 'donut', 'at', 'todo'], prefix=\"do\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)", "input": "def sat(extensions: List[str], strings=['cat', 'dog', 'shatter', 'donut', 'at', 'todo'], prefix=\"do\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)", "target": ""}
{"module": "human_eval.py", "name": "FindExtensions:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#29", "sol_bodies": ["    return [s for s in strings if s.startswith(prefix)]"], "sol_header": "def sol(strings=['cot', 'z'], prefix=\"ca\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"", "weight": 1.0, "sat": "def sat(extensions: List[str], strings=['cot', 'z'], prefix=\"ca\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)", "input": "def sat(extensions: List[str], strings=['cot', 'z'], prefix=\"ca\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)", "target": ""}
{"module": "human_eval.py", "name": "FindExtensions:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#29", "sol_bodies": ["    return [s for s in strings if s.startswith(prefix)]"], "sol_header": "def sol(strings=['jof', 'thibi'], prefix=\"le\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"", "weight": 1.0, "sat": "def sat(extensions: List[str], strings=['jof', 'thibi'], prefix=\"le\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)", "input": "def sat(extensions: List[str], strings=['jof', 'thibi'], prefix=\"le\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)", "target": ""}
{"module": "human_eval.py", "name": "FindExtensions:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#29", "sol_bodies": ["    return [s for s in strings if s.startswith(prefix)]"], "sol_header": "def sol(strings=['t'], prefix=\"t\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"", "weight": 1.0, "sat": "def sat(extensions: List[str], strings=['t'], prefix=\"t\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)", "input": "def sat(extensions: List[str], strings=['t'], prefix=\"t\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)", "target": ""}
{"module": "human_eval.py", "name": "FindExtensions:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#29", "sol_bodies": ["    return [s for s in strings if s.startswith(prefix)]"], "sol_header": "def sol(strings=['cpud', 'cpal', 'cv', 'cchut'], prefix=\"c\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"", "weight": 1.0, "sat": "def sat(extensions: List[str], strings=['cpud', 'cpal', 'cv', 'cchut'], prefix=\"c\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)", "input": "def sat(extensions: List[str], strings=['cpud', 'cpal', 'cv', 'cchut'], prefix=\"c\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)", "target": ""}
{"module": "human_eval.py", "name": "FindPositives:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#30", "sol_bodies": ["    return [i for i in nums if i > 0]"], "sol_header": "def sol(nums=[2, 2342, -2, 32, -8, -5, 2342, 0, -9, 44, 11]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"", "weight": 1.0, "sat": "def sat(positives: List[int], nums=[2, 2342, -2, 32, -8, -5, 2342, 0, -9, 44, 11]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []", "input": "def sat(positives: List[int], nums=[2, 2342, -2, 32, -8, -5, 2342, 0, -9, 44, 11]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []", "target": ""}
{"module": "human_eval.py", "name": "FindPositives:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#30", "sol_bodies": ["    return [i for i in nums if i > 0]"], "sol_header": "def sol(nums=[53, 33, 73, 47, 35, 24, 56, 89, 85]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"", "weight": 1.0, "sat": "def sat(positives: List[int], nums=[53, 33, 73, 47, 35, 24, 56, 89, 85]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []", "input": "def sat(positives: List[int], nums=[53, 33, 73, 47, 35, 24, 56, 89, 85]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []", "target": ""}
{"module": "human_eval.py", "name": "FindPositives:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#30", "sol_bodies": ["    return [i for i in nums if i > 0]"], "sol_header": "def sol(nums=[61, -64, -11, -3, -96, -69, -18, -99, 87]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"", "weight": 1.0, "sat": "def sat(positives: List[int], nums=[61, -64, -11, -3, -96, -69, -18, -99, 87]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []", "input": "def sat(positives: List[int], nums=[61, -64, -11, -3, -96, -69, -18, -99, 87]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []", "target": ""}
{"module": "human_eval.py", "name": "FindPositives:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#30", "sol_bodies": ["    return [i for i in nums if i > 0]"], "sol_header": "def sol(nums=[62, 3, -84]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"", "weight": 1.0, "sat": "def sat(positives: List[int], nums=[62, 3, -84]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []", "input": "def sat(positives: List[int], nums=[62, 3, -84]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []", "target": ""}
{"module": "human_eval.py", "name": "FindPositives:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#30", "sol_bodies": ["    return [i for i in nums if i > 0]"], "sol_header": "def sol(nums=[]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"", "weight": 1.0, "sat": "def sat(positives: List[int], nums=[]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []", "input": "def sat(positives: List[int], nums=[]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []", "target": ""}
{"module": "human_eval.py", "name": "FermatComposites:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#31", "sol_bodies": ["    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]"], "sol_header": "def sol(nums=[1449, 14, 21, 105, 217]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find Fermat composite certificates for a list of numbers > 1\n\n    Sample Input:\n    [1469]\n\n    Sample Output:\n    [3]  # because (3 ** 1468) % 1469 != 1\n    \"\"\"", "weight": 1.0, "sat": "def sat(certificates: List[int], nums=[1449, 14, 21, 105, 217]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)", "input": "def sat(certificates: List[int], nums=[1449, 14, 21, 105, 217]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)", "target": ""}
{"module": "human_eval.py", "name": "FermatComposites:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#31", "sol_bodies": ["    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]"], "sol_header": "def sol(nums=[2299290630, 2051931473, 1592080723, 533977507, 6381433197, 6645010323, 5590359939, 1543343895, 1032597423]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find Fermat composite certificates for a list of numbers > 1\n\n    Sample Input:\n    [1469]\n\n    Sample Output:\n    [3]  # because (3 ** 1468) % 1469 != 1\n    \"\"\"", "weight": 1.0, "sat": "def sat(certificates: List[int], nums=[2299290630, 2051931473, 1592080723, 533977507, 6381433197, 6645010323, 5590359939, 1543343895, 1032597423]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)", "input": "def sat(certificates: List[int], nums=[2299290630, 2051931473, 1592080723, 533977507, 6381433197, 6645010323, 5590359939, 1543343895, 1032597423]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)", "target": ""}
{"module": "human_eval.py", "name": "FermatComposites:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#31", "sol_bodies": ["    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]"], "sol_header": "def sol(nums=[962036141, 941419353, 5954955179, 5140095171, 3027040707, 6069862645, 591197645, 2485033263]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find Fermat composite certificates for a list of numbers > 1\n\n    Sample Input:\n    [1469]\n\n    Sample Output:\n    [3]  # because (3 ** 1468) % 1469 != 1\n    \"\"\"", "weight": 1.0, "sat": "def sat(certificates: List[int], nums=[962036141, 941419353, 5954955179, 5140095171, 3027040707, 6069862645, 591197645, 2485033263]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)", "input": "def sat(certificates: List[int], nums=[962036141, 941419353, 5954955179, 5140095171, 3027040707, 6069862645, 591197645, 2485033263]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)", "target": ""}
{"module": "human_eval.py", "name": "FermatComposites:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#31", "sol_bodies": ["    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]"], "sol_header": "def sol(nums=[99210055, 4171577125, 459354525, 1534026075, 4255533095, 2441396441, 155962261]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find Fermat composite certificates for a list of numbers > 1\n\n    Sample Input:\n    [1469]\n\n    Sample Output:\n    [3]  # because (3 ** 1468) % 1469 != 1\n    \"\"\"", "weight": 1.0, "sat": "def sat(certificates: List[int], nums=[99210055, 4171577125, 459354525, 1534026075, 4255533095, 2441396441, 155962261]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)", "input": "def sat(certificates: List[int], nums=[99210055, 4171577125, 459354525, 1534026075, 4255533095, 2441396441, 155962261]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)", "target": ""}
{"module": "human_eval.py", "name": "FermatComposites:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#31", "sol_bodies": ["    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]"], "sol_header": "def sol(nums=[2629304451, 4885026075, 2283948525, 4145214425]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find Fermat composite certificates for a list of numbers > 1\n\n    Sample Input:\n    [1469]\n\n    Sample Output:\n    [3]  # because (3 ** 1468) % 1469 != 1\n    \"\"\"", "weight": 1.0, "sat": "def sat(certificates: List[int], nums=[2629304451, 4885026075, 2283948525, 4145214425]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)", "input": "def sat(certificates: List[int], nums=[2629304451, 4885026075, 2283948525, 4145214425]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)", "target": ""}
{"module": "human_eval.py", "name": "OddDegreePolynomialRoot:0", "notes": "Polynomials of odd degree always have a real solution.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#32", "sol_bodies": ["    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""], "sol_header": "def sol(coeffs=[1, 2, 3, 17]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"", "weight": 1.0, "sat": "def sat(root: float, coeffs=[1, 2, 3, 17]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4", "input": "def sat(root: float, coeffs=[1, 2, 3, 17]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4", "target": ""}
{"module": "human_eval.py", "name": "OddDegreePolynomialRoot:1", "notes": "Polynomials of odd degree always have a real solution.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#32", "sol_bodies": ["    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""], "sol_header": "def sol(coeffs=[-1, -5, 4, -8, 3, -1, 0, 7]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"", "weight": 1.0, "sat": "def sat(root: float, coeffs=[-1, -5, 4, -8, 3, -1, 0, 7]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4", "input": "def sat(root: float, coeffs=[-1, -5, 4, -8, 3, -1, 0, 7]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4", "target": ""}
{"module": "human_eval.py", "name": "OddDegreePolynomialRoot:2", "notes": "Polynomials of odd degree always have a real solution.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#32", "sol_bodies": ["    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""], "sol_header": "def sol(coeffs=[7, 1]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"", "weight": 1.0, "sat": "def sat(root: float, coeffs=[7, 1]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4", "input": "def sat(root: float, coeffs=[7, 1]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4", "target": ""}
{"module": "human_eval.py", "name": "OddDegreePolynomialRoot:3", "notes": "Polynomials of odd degree always have a real solution.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#32", "sol_bodies": ["    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""], "sol_header": "def sol(coeffs=[1, 4, 1, -7, 5, 0, -10, -9, 4, 9]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"", "weight": 1.0, "sat": "def sat(root: float, coeffs=[1, 4, 1, -7, 5, 0, -10, -9, 4, 9]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4", "input": "def sat(root: float, coeffs=[1, 4, 1, -7, 5, 0, -10, -9, 4, 9]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4", "target": ""}
{"module": "human_eval.py", "name": "OddDegreePolynomialRoot:4", "notes": "Polynomials of odd degree always have a real solution.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#32", "sol_bodies": ["    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""], "sol_header": "def sol(coeffs=[7, 8]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"", "weight": 1.0, "sat": "def sat(root: float, coeffs=[7, 8]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4", "input": "def sat(root: float, coeffs=[7, 8]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4", "target": ""}
{"module": "human_eval.py", "name": "TwoThirdsSorted:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#33", "sol_bodies": ["    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"], "sol_header": "def sol(orig=[1, -2, 3, 17, 8, 4, 12, 3, 18, 5, -29, 0, 0]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[1, -2, 3, 17, 8, 4, 12, 3, 18, 5, -29, 0, 0]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True", "input": "def sat(li: List[int], orig=[1, -2, 3, 17, 8, 4, 12, 3, 18, 5, -29, 0, 0]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True", "target": ""}
{"module": "human_eval.py", "name": "TwoThirdsSorted:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#33", "sol_bodies": ["    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"], "sol_header": "def sol(orig=[-10, 9, 0, -6, 0, -7, -2, 4, 8, 2, 3, -9, -8, 9, -4, -4]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[-10, 9, 0, -6, 0, -7, -2, 4, 8, 2, 3, -9, -8, 9, -4, -4]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True", "input": "def sat(li: List[int], orig=[-10, 9, 0, -6, 0, -7, -2, 4, 8, 2, 3, -9, -8, 9, -4, -4]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True", "target": ""}
{"module": "human_eval.py", "name": "TwoThirdsSorted:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#33", "sol_bodies": ["    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"], "sol_header": "def sol(orig=[0, 7, -3, -3, 2, 2, 5, -9, -9]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[0, 7, -3, -3, 2, 2, 5, -9, -9]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True", "input": "def sat(li: List[int], orig=[0, 7, -3, -3, 2, 2, 5, -9, -9]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True", "target": ""}
{"module": "human_eval.py", "name": "TwoThirdsSorted:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#33", "sol_bodies": ["    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"], "sol_header": "def sol(orig=[-1, -1, 0, 6, 3, -1, 4, -1, 1, 9, -4, -1, 6, 4, -7, -4, 1]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[-1, -1, 0, 6, 3, -1, 4, -1, 1, 9, -4, -1, 6, 4, -7, -4, 1]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True", "input": "def sat(li: List[int], orig=[-1, -1, 0, 6, 3, -1, 4, -1, 1, 9, -4, -1, 6, 4, -7, -4, 1]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True", "target": ""}
{"module": "human_eval.py", "name": "TwoThirdsSorted:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#33", "sol_bodies": ["    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"], "sol_header": "def sol(orig=[]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True", "input": "def sat(li: List[int], orig=[]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True", "target": ""}
{"module": "human_eval.py", "name": "UniqueSorted:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#34", "sol_bodies": ["    my_list = sorted(set(orig))\n    return my_list"], "sol_header": "def sol(orig=[1, 1, 3, 2, 0, 8, 32, -4, 0]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[1, 1, 3, 2, 0, 8, 32, -4, 0]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True", "input": "def sat(li: List[int], orig=[1, 1, 3, 2, 0, 8, 32, -4, 0]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True", "target": ""}
{"module": "human_eval.py", "name": "UniqueSorted:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#34", "sol_bodies": ["    my_list = sorted(set(orig))\n    return my_list"], "sol_header": "def sol(orig=[-9, 1, -5, 6, -1, 3, 5, 8, -10, -2, 3, -9, -10]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[-9, 1, -5, 6, -1, 3, 5, 8, -10, -2, 3, -9, -10]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True", "input": "def sat(li: List[int], orig=[-9, 1, -5, 6, -1, 3, 5, 8, -10, -2, 3, -9, -10]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True", "target": ""}
{"module": "human_eval.py", "name": "UniqueSorted:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#34", "sol_bodies": ["    my_list = sorted(set(orig))\n    return my_list"], "sol_header": "def sol(orig=[-3, 7, 9, -10, -10, 5, 2, 8]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[-3, 7, 9, -10, -10, 5, 2, 8]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True", "input": "def sat(li: List[int], orig=[-3, 7, 9, -10, -10, 5, 2, 8]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True", "target": ""}
{"module": "human_eval.py", "name": "UniqueSorted:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#34", "sol_bodies": ["    my_list = sorted(set(orig))\n    return my_list"], "sol_header": "def sol(orig=[-6]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[-6]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True", "input": "def sat(li: List[int], orig=[-6]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True", "target": ""}
{"module": "human_eval.py", "name": "UniqueSorted:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#34", "sol_bodies": ["    my_list = sorted(set(orig))\n    return my_list"], "sol_header": "def sol(orig=[1, -5, 6, 2, -7, -6, 5, -5, 3, 7, 4, -10, -2, 3, 7, 9, -3, 8, 7]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[1, -5, 6, 2, -7, -6, 5, -5, 3, 7, 4, -10, -2, 3, 7, 9, -3, 8, 7]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True", "input": "def sat(li: List[int], orig=[1, -5, 6, 2, -7, -6, 5, -5, 3, 7, 4, -10, -2, 3, 7, 9, -3, 8, 7]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True", "target": ""}
{"module": "human_eval.py", "name": "MaxInt:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#35", "sol_bodies": ["    return max(hello)"], "sol_header": "def sol(hello=[1, 31, 3, 2, 0, 18, 32, -4, 2, -1000, 3502145, 3502145, 21, 18, 2, 60]):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"", "weight": 1.0, "sat": "def sat(m: int, hello=[1, 31, 3, 2, 0, 18, 32, -4, 2, -1000, 3502145, 3502145, 21, 18, 2, 60]):\n    return m in hello and not any(m < i for i in hello)", "input": "def sat(m: int, hello=[1, 31, 3, 2, 0, 18, 32, -4, 2, -1000, 3502145, 3502145, 21, 18, 2, 60]):\n    return m in hello and not any(m < i for i in hello)", "target": ""}
{"module": "human_eval.py", "name": "MaxInt:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#35", "sol_bodies": ["    return max(hello)"], "sol_header": "def sol(hello=[2, 2, 2, -4, -2, -5, -4, 0, -5, -10, 1, -1, -1, 2]):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"", "weight": 1.0, "sat": "def sat(m: int, hello=[2, 2, 2, -4, -2, -5, -4, 0, -5, -10, 1, -1, -1, 2]):\n    return m in hello and not any(m < i for i in hello)", "input": "def sat(m: int, hello=[2, 2, 2, -4, -2, -5, -4, 0, -5, -10, 1, -1, -1, 2]):\n    return m in hello and not any(m < i for i in hello)", "target": ""}
{"module": "human_eval.py", "name": "MaxInt:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#35", "sol_bodies": ["    return max(hello)"], "sol_header": "def sol(hello=[8, -1, -8, 1, -10]):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"", "weight": 1.0, "sat": "def sat(m: int, hello=[8, -1, -8, 1, -10]):\n    return m in hello and not any(m < i for i in hello)", "input": "def sat(m: int, hello=[8, -1, -8, 1, -10]):\n    return m in hello and not any(m < i for i in hello)", "target": ""}
{"module": "human_eval.py", "name": "MaxInt:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#35", "sol_bodies": ["    return max(hello)"], "sol_header": "def sol(hello=[-8, 1, 9, 4, 4, 0, -1, 8, 2, 3, 5, 9, 2, -1, 9]):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"", "weight": 1.0, "sat": "def sat(m: int, hello=[-8, 1, 9, 4, 4, 0, -1, 8, 2, 3, 5, 9, 2, -1, 9]):\n    return m in hello and not any(m < i for i in hello)", "input": "def sat(m: int, hello=[-8, 1, 9, 4, 4, 0, -1, 8, 2, 3, 5, 9, 2, -1, 9]):\n    return m in hello and not any(m < i for i in hello)", "target": ""}
{"module": "human_eval.py", "name": "MaxInt:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#35", "sol_bodies": ["    return max(hello)"], "sol_header": "def sol(hello=[5, 2, -10, -2, -4, 2, 3, -5, 9, 0]):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"", "weight": 1.0, "sat": "def sat(m: int, hello=[5, 2, -10, -2, -4, 2, 3, -5, 9, 0]):\n    return m in hello and not any(m < i for i in hello)", "input": "def sat(m: int, hello=[5, 2, -10, -2, -4, 2, 3, -5, 9, 0]):\n    return m in hello and not any(m < i for i in hello)", "target": ""}
{"module": "human_eval.py", "name": "SevenElevenThirteen:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#36", "sol_bodies": ["    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"], "sol_header": "def sol(n=19723, lower=1000):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[List[int]], n=19723, lower=1000):\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)", "input": "def sat(li: List[List[int]], n=19723, lower=1000):\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)", "target": ""}
{"module": "human_eval.py", "name": "SevenElevenThirteen:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#36", "sol_bodies": ["    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"], "sol_header": "def sol(n=5, lower=0):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[List[int]], n=5, lower=0):\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)", "input": "def sat(li: List[List[int]], n=5, lower=0):\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)", "target": ""}
{"module": "human_eval.py", "name": "SevenElevenThirteen:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#36", "sol_bodies": ["    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"], "sol_header": "def sol(n=8, lower=0):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[List[int]], n=8, lower=0):\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)", "input": "def sat(li: List[List[int]], n=8, lower=0):\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)", "target": ""}
{"module": "human_eval.py", "name": "SevenElevenThirteen:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#36", "sol_bodies": ["    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"], "sol_header": "def sol(n=11, lower=0):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[List[int]], n=11, lower=0):\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)", "input": "def sat(li: List[List[int]], n=11, lower=0):\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)", "target": ""}
{"module": "human_eval.py", "name": "HalfSorted:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#37", "sol_bodies": ["    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"], "sol_header": "def sol(orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 19521]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 19521]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])", "input": "def sat(li: List[int], orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 19521]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])", "target": ""}
{"module": "human_eval.py", "name": "HalfSorted:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#37", "sol_bodies": ["    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"], "sol_header": "def sol(orig=[-1, -9, 7, 8, -8, 2, -7]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[-1, -9, 7, 8, -8, 2, -7]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])", "input": "def sat(li: List[int], orig=[-1, -9, 7, 8, -8, 2, -7]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])", "target": ""}
{"module": "human_eval.py", "name": "HalfSorted:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#37", "sol_bodies": ["    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"], "sol_header": "def sol(orig=[4, -3, -8]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[4, -3, -8]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])", "input": "def sat(li: List[int], orig=[4, -3, -8]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])", "target": ""}
{"module": "human_eval.py", "name": "HalfSorted:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#37", "sol_bodies": ["    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"], "sol_header": "def sol(orig=[3, 6, -7, 1, 2, -10, 6, -8, -9, -9, 6, -7, 7, -6, 1, 4, -8, -1, 8]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[3, 6, -7, 1, 2, -10, 6, -8, -9, -9, 6, -7, 7, -6, 1, 4, -8, -1, 8]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])", "input": "def sat(li: List[int], orig=[3, 6, -7, 1, 2, -10, 6, -8, -9, -9, 6, -7, 7, -6, 1, 4, -8, -1, 8]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])", "target": ""}
{"module": "human_eval.py", "name": "HalfSorted:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#37", "sol_bodies": ["    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"], "sol_header": "def sol(orig=[-7, 6, 8, 8, -3, -5, -6, -5, 6, 7, 5, 7, -9, 9, -7, 4, -8, 8, -9]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], orig=[-7, 6, 8, 8, -3, -5, -6, -5, 6, 7, 5, 7, -9, 9, -7, 4, -8, 8, -9]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])", "input": "def sat(li: List[int], orig=[-7, 6, 8, 8, -3, -5, -6, -5, 6, 7, 5, 7, -9, 9, -7, 4, -8, 8, -9]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])", "target": ""}
{"module": "human_eval.py", "name": "ThreeCycle:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#38", "sol_bodies": ["    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"], "sol_header": "def sol(target=\"Hello world\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n\n    Sample Input:\n    \"This is a test\"\n\n    Sample Output:\n    'hiT is aste st'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=\"Hello world\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))", "input": "def sat(s: str, target=\"Hello world\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))", "target": ""}
{"module": "human_eval.py", "name": "ThreeCycle:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#38", "sol_bodies": ["    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"], "sol_header": "def sol(target=\"rugetytextirocuterup\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n\n    Sample Input:\n    \"This is a test\"\n\n    Sample Output:\n    'hiT is aste st'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=\"rugetytextirocuterup\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))", "input": "def sat(s: str, target=\"rugetytextirocuterup\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))", "target": ""}
{"module": "human_eval.py", "name": "ThreeCycle:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#38", "sol_bodies": ["    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"], "sol_header": "def sol(target=\"torusajidapaficiretoh\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n\n    Sample Input:\n    \"This is a test\"\n\n    Sample Output:\n    'hiT is aste st'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=\"torusajidapaficiretoh\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))", "input": "def sat(s: str, target=\"torusajidapaficiretoh\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))", "target": ""}
{"module": "human_eval.py", "name": "ThreeCycle:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#38", "sol_bodies": ["    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"], "sol_header": "def sol(target=\"quitextaf\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n\n    Sample Input:\n    \"This is a test\"\n\n    Sample Output:\n    'hiT is aste st'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=\"quitextaf\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))", "input": "def sat(s: str, target=\"quitextaf\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))", "target": ""}
{"module": "human_eval.py", "name": "ThreeCycle:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#38", "sol_bodies": ["    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"], "sol_header": "def sol(target=\"thoqui\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n\n    Sample Input:\n    \"This is a test\"\n\n    Sample Output:\n    'hiT is aste st'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=\"thoqui\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))", "input": "def sat(s: str, target=\"thoqui\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))", "target": ""}
{"module": "human_eval.py", "name": "PrimeFib:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#39\n\nIra Gessel observed that n is a Fibonacci number if and if either 5 n^2 - 4 or 5 n^2 + 4 is a perfect square", "sol_bodies": ["    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"], "sol_header": "def sol(lower=123456):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n\n    Sample Input:\n    10\n\n    Sample Output:\n    11\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, lower=123456):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower", "input": "def sat(n: int, lower=123456):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower", "target": ""}
{"module": "human_eval.py", "name": "PrimeFib:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#39\n\nIra Gessel observed that n is a Fibonacci number if and if either 5 n^2 - 4 or 5 n^2 + 4 is a perfect square", "sol_bodies": ["    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"], "sol_header": "def sol(lower=3):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n\n    Sample Input:\n    10\n\n    Sample Output:\n    11\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, lower=3):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower", "input": "def sat(n: int, lower=3):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower", "target": ""}
{"module": "human_eval.py", "name": "PrimeFib:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#39\n\nIra Gessel observed that n is a Fibonacci number if and if either 5 n^2 - 4 or 5 n^2 + 4 is a perfect square", "sol_bodies": ["    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"], "sol_header": "def sol(lower=458):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n\n    Sample Input:\n    10\n\n    Sample Output:\n    11\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, lower=458):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower", "input": "def sat(n: int, lower=458):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower", "target": ""}
{"module": "human_eval.py", "name": "PrimeFib:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#39\n\nIra Gessel observed that n is a Fibonacci number if and if either 5 n^2 - 4 or 5 n^2 + 4 is a perfect square", "sol_bodies": ["    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"], "sol_header": "def sol(lower=384):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n\n    Sample Input:\n    10\n\n    Sample Output:\n    11\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, lower=384):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower", "input": "def sat(n: int, lower=384):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower", "target": ""}
{"module": "human_eval.py", "name": "PrimeFib:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#39\n\nIra Gessel observed that n is a Fibonacci number if and if either 5 n^2 - 4 or 5 n^2 + 4 is a perfect square", "sol_bodies": ["    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"], "sol_header": "def sol(lower=4):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n\n    Sample Input:\n    10\n\n    Sample Output:\n    11\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, lower=4):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower", "input": "def sat(n: int, lower=4):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower", "target": ""}
{"module": "human_eval.py", "name": "TripleZeroSum:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#40\n    \nSimilar to but harder than PairZeroSum \\#43.\n    \nThis is a version of the classic [3SUM](https://en.wikipedia.org/wiki/3SUM) problem.", "sol_bodies": ["    # \\tilde{O}(n^2) algorithm\n    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries\n    for i, n in enumerate(nums):\n        if inv[n] == i:\n            del inv[n]\n        if any((-m - n) in inv for m in nums[:i]):  # found solution!\n            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)\n            k = inv[-m - n]\n            return sorted([i, j, k])"], "sol_header": "def sol(nums=[12, 6, 41, 15, -10452, 18242, 10440, 6, 6, 6, 6]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[12, 6, 41, 15, -10452, 18242, 10440, 6, 6, 6, 6]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0", "input": "def sat(inds: List[int], nums=[12, 6, 41, 15, -10452, 18242, 10440, 6, 6, 6, 6]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0", "target": ""}
{"module": "human_eval.py", "name": "TripleZeroSum:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#40\n    \nSimilar to but harder than PairZeroSum \\#43.\n    \nThis is a version of the classic [3SUM](https://en.wikipedia.org/wiki/3SUM) problem.", "sol_bodies": ["    # \\tilde{O}(n^2) algorithm\n    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries\n    for i, n in enumerate(nums):\n        if inv[n] == i:\n            del inv[n]\n        if any((-m - n) in inv for m in nums[:i]):  # found solution!\n            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)\n            k = inv[-m - n]\n            return sorted([i, j, k])"], "sol_header": "def sol(nums=[-52, -16, 68, -27, 3]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[-52, -16, 68, -27, 3]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0", "input": "def sat(inds: List[int], nums=[-52, -16, 68, -27, 3]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0", "target": ""}
{"module": "human_eval.py", "name": "TripleZeroSum:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#40\n    \nSimilar to but harder than PairZeroSum \\#43.\n    \nThis is a version of the classic [3SUM](https://en.wikipedia.org/wiki/3SUM) problem.", "sol_bodies": ["    # \\tilde{O}(n^2) algorithm\n    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries\n    for i, n in enumerate(nums):\n        if inv[n] == i:\n            del inv[n]\n        if any((-m - n) in inv for m in nums[:i]):  # found solution!\n            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)\n            k = inv[-m - n]\n            return sorted([i, j, k])"], "sol_header": "def sol(nums=[-64, -74, -18, -57, 89, -14, -25, 11, -60, -78]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[-64, -74, -18, -57, 89, -14, -25, 11, -60, -78]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0", "input": "def sat(inds: List[int], nums=[-64, -74, -18, -57, 89, -14, -25, 11, -60, -78]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0", "target": ""}
{"module": "human_eval.py", "name": "TripleZeroSum:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#40\n    \nSimilar to but harder than PairZeroSum \\#43.\n    \nThis is a version of the classic [3SUM](https://en.wikipedia.org/wiki/3SUM) problem.", "sol_bodies": ["    # \\tilde{O}(n^2) algorithm\n    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries\n    for i, n in enumerate(nums):\n        if inv[n] == i:\n            del inv[n]\n        if any((-m - n) in inv for m in nums[:i]):  # found solution!\n            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)\n            k = inv[-m - n]\n            return sorted([i, j, k])"], "sol_header": "def sol(nums=[-90, 63, 70, 21, 42, 20]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[-90, 63, 70, 21, 42, 20]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0", "input": "def sat(inds: List[int], nums=[-90, 63, 70, 21, 42, 20]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0", "target": ""}
{"module": "human_eval.py", "name": "TripleZeroSum:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#40\n    \nSimilar to but harder than PairZeroSum \\#43.\n    \nThis is a version of the classic [3SUM](https://en.wikipedia.org/wiki/3SUM) problem.", "sol_bodies": ["    # \\tilde{O}(n^2) algorithm\n    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries\n    for i, n in enumerate(nums):\n        if inv[n] == i:\n            del inv[n]\n        if any((-m - n) in inv for m in nums[:i]):  # found solution!\n            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)\n            k = inv[-m - n]\n            return sorted([i, j, k])"], "sol_header": "def sol(nums=[-14, 65, -7, -75, 54, 78, -61, 136, -85, 44]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[-14, 65, -7, -75, 54, 78, -61, 136, -85, 44]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0", "input": "def sat(inds: List[int], nums=[-14, 65, -7, -75, 54, 78, -61, 136, -85, 44]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0", "target": ""}
{"module": "human_eval.py", "name": "NumPasses:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#41", "sol_bodies": ["    return n ** 2"], "sol_header": "def sol(n=981):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n\n    --Sample input--\n    2\n\n    --Sample output--\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(count: int, n=981):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0", "input": "def sat(count: int, n=981):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0", "target": ""}
{"module": "human_eval.py", "name": "NumPasses:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#41", "sol_bodies": ["    return n ** 2"], "sol_header": "def sol(n=123):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n\n    --Sample input--\n    2\n\n    --Sample output--\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(count: int, n=123):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0", "input": "def sat(count: int, n=123):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0", "target": ""}
{"module": "human_eval.py", "name": "NumPasses:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#41", "sol_bodies": ["    return n ** 2"], "sol_header": "def sol(n=239):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n\n    --Sample input--\n    2\n\n    --Sample output--\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(count: int, n=239):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0", "input": "def sat(count: int, n=239):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0", "target": ""}
{"module": "human_eval.py", "name": "NumPasses:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#41", "sol_bodies": ["    return n ** 2"], "sol_header": "def sol(n=378):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n\n    --Sample input--\n    2\n\n    --Sample output--\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(count: int, n=378):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0", "input": "def sat(count: int, n=378):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0", "target": ""}
{"module": "human_eval.py", "name": "NumPasses:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#41", "sol_bodies": ["    return n ** 2"], "sol_header": "def sol(n=501):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n\n    --Sample input--\n    2\n\n    --Sample output--\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(count: int, n=501):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0", "input": "def sat(count: int, n=501):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0", "target": ""}
{"module": "human_eval.py", "name": "ListInc:0", "notes": "Increment each element of a list by 1\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#42", "sol_bodies": ["    return [i + 1 for i in old_list]"], "sol_header": "def sol(old_list=[321, 12, 532, 129, 9, -12, 4, 56, 90, 0]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n\n    Sample Input:\n    [17, 15, 99]\n\n    Sample Output:\n    [18, 16, 100]\n    \"\"\"", "weight": 1.0, "sat": "def sat(new_list: List[int], old_list=[321, 12, 532, 129, 9, -12, 4, 56, 90, 0]):\n    return [i - 1 for i in new_list] == old_list", "input": "def sat(new_list: List[int], old_list=[321, 12, 532, 129, 9, -12, 4, 56, 90, 0]):\n    return [i - 1 for i in new_list] == old_list", "target": ""}
{"module": "human_eval.py", "name": "ListInc:1", "notes": "Increment each element of a list by 1\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#42", "sol_bodies": ["    return [i + 1 for i in old_list]"], "sol_header": "def sol(old_list=[18, 29, 40]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n\n    Sample Input:\n    [17, 15, 99]\n\n    Sample Output:\n    [18, 16, 100]\n    \"\"\"", "weight": 1.0, "sat": "def sat(new_list: List[int], old_list=[18, 29, 40]):\n    return [i - 1 for i in new_list] == old_list", "input": "def sat(new_list: List[int], old_list=[18, 29, 40]):\n    return [i - 1 for i in new_list] == old_list", "target": ""}
{"module": "human_eval.py", "name": "ListInc:2", "notes": "Increment each element of a list by 1\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#42", "sol_bodies": ["    return [i + 1 for i in old_list]"], "sol_header": "def sol(old_list=[43, 64, 73, 30, 47]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n\n    Sample Input:\n    [17, 15, 99]\n\n    Sample Output:\n    [18, 16, 100]\n    \"\"\"", "weight": 1.0, "sat": "def sat(new_list: List[int], old_list=[43, 64, 73, 30, 47]):\n    return [i - 1 for i in new_list] == old_list", "input": "def sat(new_list: List[int], old_list=[43, 64, 73, 30, 47]):\n    return [i - 1 for i in new_list] == old_list", "target": ""}
{"module": "human_eval.py", "name": "ListInc:3", "notes": "Increment each element of a list by 1\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#42", "sol_bodies": ["    return [i + 1 for i in old_list]"], "sol_header": "def sol(old_list=[43, 9, 49, 93, 36, 47, 48, 38, 12]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n\n    Sample Input:\n    [17, 15, 99]\n\n    Sample Output:\n    [18, 16, 100]\n    \"\"\"", "weight": 1.0, "sat": "def sat(new_list: List[int], old_list=[43, 9, 49, 93, 36, 47, 48, 38, 12]):\n    return [i - 1 for i in new_list] == old_list", "input": "def sat(new_list: List[int], old_list=[43, 9, 49, 93, 36, 47, 48, 38, 12]):\n    return [i - 1 for i in new_list] == old_list", "target": ""}
{"module": "human_eval.py", "name": "ListInc:4", "notes": "Increment each element of a list by 1\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#42", "sol_bodies": ["    return [i + 1 for i in old_list]"], "sol_header": "def sol(old_list=[45, 55, 71, 78, 54]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n\n    Sample Input:\n    [17, 15, 99]\n\n    Sample Output:\n    [18, 16, 100]\n    \"\"\"", "weight": 1.0, "sat": "def sat(new_list: List[int], old_list=[45, 55, 71, 78, 54]):\n    return [i - 1 for i in new_list] == old_list", "input": "def sat(new_list: List[int], old_list=[45, 55, 71, 78, 54]):\n    return [i - 1 for i in new_list] == old_list", "target": ""}
{"module": "human_eval.py", "name": "PairZeroSum:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#43\n\nSimilar to TripleZeroSum \\#40", "sol_bodies": ["    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"], "sol_header": "def sol(nums=[12, -10452, 18242, 10440, 81, 241, 525, -18242, 91, 20]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n\n    Sample Input:\n    [1, -4, -4, 7, -3]\n\n    Sample Output:\n    [1, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[12, -10452, 18242, 10440, 81, 241, 525, -18242, 91, 20]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0", "input": "def sat(inds: List[int], nums=[12, -10452, 18242, 10440, 81, 241, 525, -18242, 91, 20]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0", "target": ""}
{"module": "human_eval.py", "name": "PairZeroSum:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#43\n\nSimilar to TripleZeroSum \\#40", "sol_bodies": ["    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"], "sol_header": "def sol(nums=[50, 33, 12, -13, 65, -39, -12, -72, -61, -38, -58, -88, 70, -82, -80, 27, 68, 89, -57, 15, -33, 93, 57, -91, 60, -72, -19, -12, 70, -35, 53, -21, -19, 66, 58, 76, -92, 64, 52, -21, 29, -61, -10, 50, -88, 17, 0, -50, 52, -87, 9, -95, 59, 23, 69, -34, 73, -39, 15, 17, 37, -83, -31, 13, -33, 6, -27, -45, -15, -78, 74, 92, 56, -52, 44, -9, -22, 27, -94, -17, 5, -82, -40, 22, -91, 10, 57, 13, -41, -93, -40, -42, 28, -3, 82]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n\n    Sample Input:\n    [1, -4, -4, 7, -3]\n\n    Sample Output:\n    [1, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[50, 33, 12, -13, 65, -39, -12, -72, -61, -38, -58, -88, 70, -82, -80, 27, 68, 89, -57, 15, -33, 93, 57, -91, 60, -72, -19, -12, 70, -35, 53, -21, -19, 66, 58, 76, -92, 64, 52, -21, 29, -61, -10, 50, -88, 17, 0, -50, 52, -87, 9, -95, 59, 23, 69, -34, 73, -39, 15, 17, 37, -83, -31, 13, -33, 6, -27, -45, -15, -78, 74, 92, 56, -52, 44, -9, -22, 27, -94, -17, 5, -82, -40, 22, -91, 10, 57, 13, -41, -93, -40, -42, 28, -3, 82]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0", "input": "def sat(inds: List[int], nums=[50, 33, 12, -13, 65, -39, -12, -72, -61, -38, -58, -88, 70, -82, -80, 27, 68, 89, -57, 15, -33, 93, 57, -91, 60, -72, -19, -12, 70, -35, 53, -21, -19, 66, 58, 76, -92, 64, 52, -21, 29, -61, -10, 50, -88, 17, 0, -50, 52, -87, 9, -95, 59, 23, 69, -34, 73, -39, 15, 17, 37, -83, -31, 13, -33, 6, -27, -45, -15, -78, 74, 92, 56, -52, 44, -9, -22, 27, -94, -17, 5, -82, -40, 22, -91, 10, 57, 13, -41, -93, -40, -42, 28, -3, 82]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0", "target": ""}
{"module": "human_eval.py", "name": "PairZeroSum:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#43\n\nSimilar to TripleZeroSum \\#40", "sol_bodies": ["    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"], "sol_header": "def sol(nums=[18, -81, 7, -48, -14, 88, -34, 29, 72, 16, 38, -29, 53, -52, 16, 31, 65, 1, -77, 24, -73, 8, 78, -13, -96, 29, -3, 45, -44, 98, 9, -89, -50, 46, -88, 89, -93, 98, -83, -3, -17, 72, 25, 18, 88, -32, -37, -26, 69, -39, 62, 64, 41, 58, 29, 33, -65, -13, 61, 41, -90, -79, -94, -81, 40, 46, -78, -13, -44, 9, 42, -90, 94, -19, 5, -33, 33, -60, 80, -40, -64, 19, -92, 62, -12, -58, 89, -50, -82, -32, 65, 82, -49, 80, -71, 68, -17, 26, 6, -61]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n\n    Sample Input:\n    [1, -4, -4, 7, -3]\n\n    Sample Output:\n    [1, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[18, -81, 7, -48, -14, 88, -34, 29, 72, 16, 38, -29, 53, -52, 16, 31, 65, 1, -77, 24, -73, 8, 78, -13, -96, 29, -3, 45, -44, 98, 9, -89, -50, 46, -88, 89, -93, 98, -83, -3, -17, 72, 25, 18, 88, -32, -37, -26, 69, -39, 62, 64, 41, 58, 29, 33, -65, -13, 61, 41, -90, -79, -94, -81, 40, 46, -78, -13, -44, 9, 42, -90, 94, -19, 5, -33, 33, -60, 80, -40, -64, 19, -92, 62, -12, -58, 89, -50, -82, -32, 65, 82, -49, 80, -71, 68, -17, 26, 6, -61]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0", "input": "def sat(inds: List[int], nums=[18, -81, 7, -48, -14, 88, -34, 29, 72, 16, 38, -29, 53, -52, 16, 31, 65, 1, -77, 24, -73, 8, 78, -13, -96, 29, -3, 45, -44, 98, 9, -89, -50, 46, -88, 89, -93, 98, -83, -3, -17, 72, 25, 18, 88, -32, -37, -26, 69, -39, 62, 64, 41, 58, 29, 33, -65, -13, 61, 41, -90, -79, -94, -81, 40, 46, -78, -13, -44, 9, 42, -90, 94, -19, 5, -33, 33, -60, 80, -40, -64, 19, -92, 62, -12, -58, 89, -50, -82, -32, 65, 82, -49, 80, -71, 68, -17, 26, 6, -61]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0", "target": ""}
{"module": "human_eval.py", "name": "PairZeroSum:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#43\n\nSimilar to TripleZeroSum \\#40", "sol_bodies": ["    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"], "sol_header": "def sol(nums=[61, 13, 32, -67, -29, 6, 65, 82, -36, -90, -3, -53, -80, 52, -20, 14, -58, 1, 14, 88, 90, -76, -83, 47, -20, -26, 5, 71, 29, -51, -6, 38, -42, -48, 9, -74, -37, -86, -31, -63, -45, -74, -40, 23, -16, 24, -6, -93, -46, -42, -4, -85, -91, 71, -72, 11, -33, 33, -82, -67, -34, -60, 89, 60, 26, -12, -92, 42, -92, -58, -37, 9, -38, 54, 34, 25, 85, -65, -79, 33, -52, -72, -80, -76, -39, 24, -2, 40, -53, -14, 8, 21, 7, 46, -88, -67]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n\n    Sample Input:\n    [1, -4, -4, 7, -3]\n\n    Sample Output:\n    [1, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[61, 13, 32, -67, -29, 6, 65, 82, -36, -90, -3, -53, -80, 52, -20, 14, -58, 1, 14, 88, 90, -76, -83, 47, -20, -26, 5, 71, 29, -51, -6, 38, -42, -48, 9, -74, -37, -86, -31, -63, -45, -74, -40, 23, -16, 24, -6, -93, -46, -42, -4, -85, -91, 71, -72, 11, -33, 33, -82, -67, -34, -60, 89, 60, 26, -12, -92, 42, -92, -58, -37, 9, -38, 54, 34, 25, 85, -65, -79, 33, -52, -72, -80, -76, -39, 24, -2, 40, -53, -14, 8, 21, 7, 46, -88, -67]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0", "input": "def sat(inds: List[int], nums=[61, 13, 32, -67, -29, 6, 65, 82, -36, -90, -3, -53, -80, 52, -20, 14, -58, 1, 14, 88, 90, -76, -83, 47, -20, -26, 5, 71, 29, -51, -6, 38, -42, -48, 9, -74, -37, -86, -31, -63, -45, -74, -40, 23, -16, 24, -6, -93, -46, -42, -4, -85, -91, 71, -72, 11, -33, 33, -82, -67, -34, -60, 89, 60, 26, -12, -92, 42, -92, -58, -37, 9, -38, 54, 34, 25, 85, -65, -79, 33, -52, -72, -80, -76, -39, 24, -2, 40, -53, -14, 8, 21, 7, 46, -88, -67]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0", "target": ""}
{"module": "human_eval.py", "name": "PairZeroSum:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#43\n\nSimilar to TripleZeroSum \\#40", "sol_bodies": ["    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"], "sol_header": "def sol(nums=[4, -4, -4, -3, 3, 1]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n\n    Sample Input:\n    [1, -4, -4, 7, -3]\n\n    Sample Output:\n    [1, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], nums=[4, -4, -4, -3, 3, 1]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0", "input": "def sat(inds: List[int], nums=[4, -4, -4, -3, 3, 1]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0", "target": ""}
{"module": "human_eval.py", "name": "ChangeBase:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#44", "sol_bodies": ["    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""], "sol_header": "def sol(n=142, base=7):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Write n in the given base as a string\n\n    Sample Input:\n    n=23, base=12\n\n    Sample Output:\n    '1A'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, n=142, base=7):\n    return int(s, base) == n", "input": "def sat(s: str, n=142, base=7):\n    return int(s, base) == n", "target": ""}
{"module": "human_eval.py", "name": "ChangeBase:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#44", "sol_bodies": ["    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""], "sol_header": "def sol(n=85328, base=2):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Write n in the given base as a string\n\n    Sample Input:\n    n=23, base=12\n\n    Sample Output:\n    '1A'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, n=85328, base=2):\n    return int(s, base) == n", "input": "def sat(s: str, n=85328, base=2):\n    return int(s, base) == n", "target": ""}
{"module": "human_eval.py", "name": "ChangeBase:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#44", "sol_bodies": ["    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""], "sol_header": "def sol(n=9576751, base=10):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Write n in the given base as a string\n\n    Sample Input:\n    n=23, base=12\n\n    Sample Output:\n    '1A'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, n=9576751, base=10):\n    return int(s, base) == n", "input": "def sat(s: str, n=9576751, base=10):\n    return int(s, base) == n", "target": ""}
{"module": "human_eval.py", "name": "ChangeBase:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#44", "sol_bodies": ["    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""], "sol_header": "def sol(n=5160280, base=5):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Write n in the given base as a string\n\n    Sample Input:\n    n=23, base=12\n\n    Sample Output:\n    '1A'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, n=5160280, base=5):\n    return int(s, base) == n", "input": "def sat(s: str, n=5160280, base=5):\n    return int(s, base) == n", "target": ""}
{"module": "human_eval.py", "name": "ChangeBase:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#44", "sol_bodies": ["    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""], "sol_header": "def sol(n=4884658, base=6):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Write n in the given base as a string\n\n    Sample Input:\n    n=23, base=12\n\n    Sample Output:\n    '1A'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, n=4884658, base=6):\n    return int(s, base) == n", "input": "def sat(s: str, n=4884658, base=6):\n    return int(s, base) == n", "target": ""}
{"module": "human_eval.py", "name": "TriangleArea:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#45", "sol_bodies": ["    return (2 * area) // base"], "sol_header": "def sol(area=1319098728582, base=45126):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n\n    Sample Input:\n    area = 6, base = 3\n\n    Sample Output:\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(height: int, area=1319098728582, base=45126):\n    return base * height == 2 * area", "input": "def sat(height: int, area=1319098728582, base=45126):\n    return base * height == 2 * area", "target": ""}
{"module": "human_eval.py", "name": "TriangleArea:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#45", "sol_bodies": ["    return (2 * area) // base"], "sol_header": "def sol(area=2642925075, base=211434006):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n\n    Sample Input:\n    area = 6, base = 3\n\n    Sample Output:\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(height: int, area=2642925075, base=211434006):\n    return base * height == 2 * area", "input": "def sat(height: int, area=2642925075, base=211434006):\n    return base * height == 2 * area", "target": ""}
{"module": "human_eval.py", "name": "TriangleArea:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#45", "sol_bodies": ["    return (2 * area) // base"], "sol_header": "def sol(area=5529468804, base=18936537):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n\n    Sample Input:\n    area = 6, base = 3\n\n    Sample Output:\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(height: int, area=5529468804, base=18936537):\n    return base * height == 2 * area", "input": "def sat(height: int, area=5529468804, base=18936537):\n    return base * height == 2 * area", "target": ""}
{"module": "human_eval.py", "name": "TriangleArea:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#45", "sol_bodies": ["    return (2 * area) // base"], "sol_header": "def sol(area=1238452500, base=600):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n\n    Sample Input:\n    area = 6, base = 3\n\n    Sample Output:\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(height: int, area=1238452500, base=600):\n    return base * height == 2 * area", "input": "def sat(height: int, area=1238452500, base=600):\n    return base * height == 2 * area", "target": ""}
{"module": "human_eval.py", "name": "TriangleArea:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#45", "sol_bodies": ["    return (2 * area) // base"], "sol_header": "def sol(area=32576448, base=147072):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n\n    Sample Input:\n    area = 6, base = 3\n\n    Sample Output:\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(height: int, area=32576448, base=147072):\n    return base * height == 2 * area", "input": "def sat(height: int, area=32576448, base=147072):\n    return base * height == 2 * area", "target": ""}
{"module": "human_eval.py", "name": "Fib4:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#46\n\nAlmost identical to problem 63", "sol_bodies": ["    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"], "sol_header": "def sol(target=2021):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[int], target=2021):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target", "input": "def sat(init: List[int], target=2021):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target", "target": ""}
{"module": "human_eval.py", "name": "Fib4:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#46\n\nAlmost identical to problem 63", "sol_bodies": ["    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"], "sol_header": "def sol(target=56):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[int], target=56):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target", "input": "def sat(init: List[int], target=56):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target", "target": ""}
{"module": "human_eval.py", "name": "Fib4:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#46\n\nAlmost identical to problem 63", "sol_bodies": ["    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"], "sol_header": "def sol(target=58965):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[int], target=58965):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target", "input": "def sat(init: List[int], target=58965):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target", "target": ""}
{"module": "human_eval.py", "name": "Fib4:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#46\n\nAlmost identical to problem 63", "sol_bodies": ["    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"], "sol_header": "def sol(target=501192137):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[int], target=501192137):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target", "input": "def sat(init: List[int], target=501192137):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target", "target": ""}
{"module": "human_eval.py", "name": "Fib4:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#46\n\nAlmost identical to problem 63", "sol_bodies": ["    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"], "sol_header": "def sol(target=0):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[int], target=0):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target", "input": "def sat(init: List[int], target=0):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target", "target": ""}
{"module": "human_eval.py", "name": "Median:0", "notes": "One definition of the median is a number that minimizes the sum of absolute deviations. When there are an\neven number of items, there is an interval of valid solutions.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#47", "sol_bodies": ["    return sorted(nums)[len(nums) // 2] if nums else 0"], "sol_header": "def sol(nums=[132666041, 237412, 28141, -12, 11939, 912414, 17], upper=133658965):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n\n    Sample Input:\n    [3, 6, 1, 2, 5, 4, 100], upper=105\n\n    Sample Output:\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, nums=[132666041, 237412, 28141, -12, 11939, 912414, 17], upper=133658965):\n    dev = sum(n - x for n in nums)\n    return dev <= upper", "input": "def sat(x: int, nums=[132666041, 237412, 28141, -12, 11939, 912414, 17], upper=133658965):\n    dev = sum(n - x for n in nums)\n    return dev <= upper", "target": ""}
{"module": "human_eval.py", "name": "Median:1", "notes": "One definition of the median is a number that minimizes the sum of absolute deviations. When there are an\neven number of items, there is an interval of valid solutions.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#47", "sol_bodies": ["    return sorted(nums)[len(nums) // 2] if nums else 0"], "sol_header": "def sol(nums=[-8813279918, 7464351342, 8037181984, 8564600186, 660800781], upper=-21408102335):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n\n    Sample Input:\n    [3, 6, 1, 2, 5, 4, 100], upper=105\n\n    Sample Output:\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, nums=[-8813279918, 7464351342, 8037181984, 8564600186, 660800781], upper=-21408102335):\n    dev = sum(n - x for n in nums)\n    return dev <= upper", "input": "def sat(x: int, nums=[-8813279918, 7464351342, 8037181984, 8564600186, 660800781], upper=-21408102335):\n    dev = sum(n - x for n in nums)\n    return dev <= upper", "target": ""}
{"module": "human_eval.py", "name": "Median:2", "notes": "One definition of the median is a number that minimizes the sum of absolute deviations. When there are an\neven number of items, there is an interval of valid solutions.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#47", "sol_bodies": ["    return sorted(nums)[len(nums) // 2] if nums else 0"], "sol_header": "def sol(nums=[], upper=0):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n\n    Sample Input:\n    [3, 6, 1, 2, 5, 4, 100], upper=105\n\n    Sample Output:\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, nums=[], upper=0):\n    dev = sum(n - x for n in nums)\n    return dev <= upper", "input": "def sat(x: int, nums=[], upper=0):\n    dev = sum(n - x for n in nums)\n    return dev <= upper", "target": ""}
{"module": "human_eval.py", "name": "Median:3", "notes": "One definition of the median is a number that minimizes the sum of absolute deviations. When there are an\neven number of items, there is an interval of valid solutions.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#47", "sol_bodies": ["    return sorted(nums)[len(nums) // 2] if nums else 0"], "sol_header": "def sol(nums=[-2350083760, -34560579, 3780403495, -9390708907, 2424237816, -6782611896, 624505871], upper=-11486893907):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n\n    Sample Input:\n    [3, 6, 1, 2, 5, 4, 100], upper=105\n\n    Sample Output:\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, nums=[-2350083760, -34560579, 3780403495, -9390708907, 2424237816, -6782611896, 624505871], upper=-11486893907):\n    dev = sum(n - x for n in nums)\n    return dev <= upper", "input": "def sat(x: int, nums=[-2350083760, -34560579, 3780403495, -9390708907, 2424237816, -6782611896, 624505871], upper=-11486893907):\n    dev = sum(n - x for n in nums)\n    return dev <= upper", "target": ""}
{"module": "human_eval.py", "name": "Median:4", "notes": "One definition of the median is a number that minimizes the sum of absolute deviations. When there are an\neven number of items, there is an interval of valid solutions.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#47", "sol_bodies": ["    return sorted(nums)[len(nums) // 2] if nums else 0"], "sol_header": "def sol(nums=[-2410166269, 5887293672], upper=-8297459941):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n\n    Sample Input:\n    [3, 6, 1, 2, 5, 4, 100], upper=105\n\n    Sample Output:\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, nums=[-2410166269, 5887293672], upper=-8297459941):\n    dev = sum(n - x for n in nums)\n    return dev <= upper", "input": "def sat(x: int, nums=[-2410166269, 5887293672], upper=-8297459941):\n    dev = sum(n - x for n in nums)\n    return dev <= upper", "target": ""}
{"module": "human_eval.py", "name": "Palindrome:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#48", "sol_bodies": ["    return [s == s[::-1] for s in strs]"], "sol_header": "def sol(strs=['palindrome', 'madamimadam', '', 'foo', 'eyes', '(-:-)']):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"\n    Test whether the given strings are palindromes\n\n    Sample Input:\n    [\"aba\", \"no\"]\n\n    Sample Output:\n    [True, False]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pals: List[bool], strs=['palindrome', 'madamimadam', '', 'foo', 'eyes', '(-:-)']):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))", "input": "def sat(pals: List[bool], strs=['palindrome', 'madamimadam', '', 'foo', 'eyes', '(-:-)']):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))", "target": ""}
{"module": "human_eval.py", "name": "Palindrome:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#48", "sol_bodies": ["    return [s == s[::-1] for s in strs]"], "sol_header": "def sol(strs=['getuteg', 'quiuq', 'tebetextxetebet', 'quyquykame', 'palimubibibumilap', 'chirowykigollogikyworihc', 'jyt', 'zenoryluchydoquuzohehozuuqodyhculyronez', 'gumizilixogylygoxilizimug']):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"\n    Test whether the given strings are palindromes\n\n    Sample Input:\n    [\"aba\", \"no\"]\n\n    Sample Output:\n    [True, False]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pals: List[bool], strs=['getuteg', 'quiuq', 'tebetextxetebet', 'quyquykame', 'palimubibibumilap', 'chirowykigollogikyworihc', 'jyt', 'zenoryluchydoquuzohehozuuqodyhculyronez', 'gumizilixogylygoxilizimug']):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))", "input": "def sat(pals: List[bool], strs=['getuteg', 'quiuq', 'tebetextxetebet', 'quyquykame', 'palimubibibumilap', 'chirowykigollogikyworihc', 'jyt', 'zenoryluchydoquuzohehozuuqodyhculyronez', 'gumizilixogylygoxilizimug']):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))", "target": ""}
{"module": "human_eval.py", "name": "Palindrome:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#48", "sol_bodies": ["    return [s == s[::-1] for s in strs]"], "sol_header": "def sol(strs=['hahez', 'fuchuwas', 'fatextynuruce', 'wetewotuzoggozutowetew', 'vutot']):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"\n    Test whether the given strings are palindromes\n\n    Sample Input:\n    [\"aba\", \"no\"]\n\n    Sample Output:\n    [True, False]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pals: List[bool], strs=['hahez', 'fuchuwas', 'fatextynuruce', 'wetewotuzoggozutowetew', 'vutot']):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))", "input": "def sat(pals: List[bool], strs=['hahez', 'fuchuwas', 'fatextynuruce', 'wetewotuzoggozutowetew', 'vutot']):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))", "target": ""}
{"module": "human_eval.py", "name": "Palindrome:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#48", "sol_bodies": ["    return [s == s[::-1] for s in strs]"], "sol_header": "def sol(strs=['wexivivixew', 'fyzalagalazyf', 's', 'quizylymaquequqeuqamylyziuq', 'cydilozuthytex', 'quu', 'vygylaf', 'chotexttxetohc', 'hequedipothovof']):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"\n    Test whether the given strings are palindromes\n\n    Sample Input:\n    [\"aba\", \"no\"]\n\n    Sample Output:\n    [True, False]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pals: List[bool], strs=['wexivivixew', 'fyzalagalazyf', 's', 'quizylymaquequqeuqamylyziuq', 'cydilozuthytex', 'quu', 'vygylaf', 'chotexttxetohc', 'hequedipothovof']):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))", "input": "def sat(pals: List[bool], strs=['wexivivixew', 'fyzalagalazyf', 's', 'quizylymaquequqeuqamylyziuq', 'cydilozuthytex', 'quu', 'vygylaf', 'chotexttxetohc', 'hequedipothovof']):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))", "target": ""}
{"module": "human_eval.py", "name": "Palindrome:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#48", "sol_bodies": ["    return [s == s[::-1] for s in strs]"], "sol_header": "def sol(strs=[]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"\n    Test whether the given strings are palindromes\n\n    Sample Input:\n    [\"aba\", \"no\"]\n\n    Sample Output:\n    [True, False]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pals: List[bool], strs=[]):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))", "input": "def sat(pals: List[bool], strs=[]):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))", "target": ""}
{"module": "human_eval.py", "name": "LittleFermat:0", "notes": "Harder but loosely inspired by [HumanEval](https://github.com/openai/human-eval) \\#49", "sol_bodies": ["    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"], "sol_header": "def sol(d=74152093423, poly=[1, 6, 3, 1, 0, 4, 4]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n\n    Sample Input:\n    d=2, poly=[1, 0, 0, 1, 0]  # 1 + x^3\n\n    Sample Output:\n    [1, 0, 1, 2, 0]  # 1+ x^2 + 2x^3 because (1 + x^3)^2 = 1 + 2x^3 + x^6 and x^6 = x^2 (mod 5)\n    \"\"\"", "weight": 1.0, "sat": "def sat(exp_poly: List[int], d=74152093423, poly=[1, 6, 3, 1, 0, 4, 4]):\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))", "input": "def sat(exp_poly: List[int], d=74152093423, poly=[1, 6, 3, 1, 0, 4, 4]):\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))", "target": ""}
{"module": "human_eval.py", "name": "ShiftChars:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#50", "sol_bodies": ["    return \"\".join(chr(ord(c) - shift) for c in result)"], "sol_header": "def sol(result=\"Hello, world!\", shift=7):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n\n    Sample Input:\n    result='very good', shift=-1\n\n    Sample Output:\n    'wfsz!hppe'\n    \"\"\"", "weight": 1.0, "sat": "def sat(orig: str, result=\"Hello, world!\", shift=7):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))", "input": "def sat(orig: str, result=\"Hello, world!\", shift=7):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))", "target": ""}
{"module": "human_eval.py", "name": "ShiftChars:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#50", "sol_bodies": ["    return \"\".join(chr(ord(c) - shift) for c in result)"], "sol_header": "def sol(result=\"rupomykecykynuric\", shift=-9):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n\n    Sample Input:\n    result='very good', shift=-1\n\n    Sample Output:\n    'wfsz!hppe'\n    \"\"\"", "weight": 1.0, "sat": "def sat(orig: str, result=\"rupomykecykynuric\", shift=-9):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))", "input": "def sat(orig: str, result=\"rupomykecykynuric\", shift=-9):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))", "target": ""}
{"module": "human_eval.py", "name": "ShiftChars:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#50", "sol_bodies": ["    return \"\".join(chr(ord(c) - shift) for c in result)"], "sol_header": "def sol(result=\"vicyza\", shift=7):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n\n    Sample Input:\n    result='very good', shift=-1\n\n    Sample Output:\n    'wfsz!hppe'\n    \"\"\"", "weight": 1.0, "sat": "def sat(orig: str, result=\"vicyza\", shift=7):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))", "input": "def sat(orig: str, result=\"vicyza\", shift=7):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))", "target": ""}
{"module": "human_eval.py", "name": "ShiftChars:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#50", "sol_bodies": ["    return \"\".join(chr(ord(c) - shift) for c in result)"], "sol_header": "def sol(result=\"nihyzatijyjoke\", shift=8):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n\n    Sample Input:\n    result='very good', shift=-1\n\n    Sample Output:\n    'wfsz!hppe'\n    \"\"\"", "weight": 1.0, "sat": "def sat(orig: str, result=\"nihyzatijyjoke\", shift=8):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))", "input": "def sat(orig: str, result=\"nihyzatijyjoke\", shift=8):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))", "target": ""}
{"module": "human_eval.py", "name": "ShiftChars:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#50", "sol_bodies": ["    return \"\".join(chr(ord(c) - shift) for c in result)"], "sol_header": "def sol(result=\"tuthijotext\", shift=6):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n\n    Sample Input:\n    result='very good', shift=-1\n\n    Sample Output:\n    'wfsz!hppe'\n    \"\"\"", "weight": 1.0, "sat": "def sat(orig: str, result=\"tuthijotext\", shift=6):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))", "input": "def sat(orig: str, result=\"tuthijotext\", shift=6):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))", "target": ""}
{"module": "human_eval.py", "name": "DiffChars:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#54", "sol_bodies": ["    return sorted(set(a).symmetric_difference(b))[0]"], "sol_header": "def sol(a=\"the quick brown fox jumped over the lazy dog\", b=\"how vexingly quick daft zebras jump\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a character in one string that is not in the other.\n\n    Sample Input:\n    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'\n\n    Sample Output:\n    't'  # or .?yI\n    \"\"\"", "weight": 1.0, "sat": "def sat(c: str, a=\"the quick brown fox jumped over the lazy dog\", b=\"how vexingly quick daft zebras jump\"):\n    return (c in a) != (c in b)", "input": "def sat(c: str, a=\"the quick brown fox jumped over the lazy dog\", b=\"how vexingly quick daft zebras jump\"):\n    return (c in a) != (c in b)", "target": ""}
{"module": "human_eval.py", "name": "DiffChars:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#54", "sol_bodies": ["    return sorted(set(a).symmetric_difference(b))[0]"], "sol_header": "def sol(a=\"jyhud\", b=\"nexysezomevus\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a character in one string that is not in the other.\n\n    Sample Input:\n    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'\n\n    Sample Output:\n    't'  # or .?yI\n    \"\"\"", "weight": 1.0, "sat": "def sat(c: str, a=\"jyhud\", b=\"nexysezomevus\"):\n    return (c in a) != (c in b)", "input": "def sat(c: str, a=\"jyhud\", b=\"nexysezomevus\"):\n    return (c in a) != (c in b)", "target": ""}
{"module": "human_eval.py", "name": "DiffChars:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#54", "sol_bodies": ["    return sorted(set(a).symmetric_difference(b))[0]"], "sol_header": "def sol(a=\"vofawawumovisajuryt\", b=\"t\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a character in one string that is not in the other.\n\n    Sample Input:\n    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'\n\n    Sample Output:\n    't'  # or .?yI\n    \"\"\"", "weight": 1.0, "sat": "def sat(c: str, a=\"vofawawumovisajuryt\", b=\"t\"):\n    return (c in a) != (c in b)", "input": "def sat(c: str, a=\"vofawawumovisajuryt\", b=\"t\"):\n    return (c in a) != (c in b)", "target": ""}
{"module": "human_eval.py", "name": "DiffChars:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#54", "sol_bodies": ["    return sorted(set(a).symmetric_difference(b))[0]"], "sol_header": "def sol(a=\"textuzaxoch\", b=\"acehmottuxxz\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a character in one string that is not in the other.\n\n    Sample Input:\n    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'\n\n    Sample Output:\n    't'  # or .?yI\n    \"\"\"", "weight": 1.0, "sat": "def sat(c: str, a=\"textuzaxoch\", b=\"acehmottuxxz\"):\n    return (c in a) != (c in b)", "input": "def sat(c: str, a=\"textuzaxoch\", b=\"acehmottuxxz\"):\n    return (c in a) != (c in b)", "target": ""}
{"module": "human_eval.py", "name": "DiffChars:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#54", "sol_bodies": ["    return sorted(set(a).symmetric_difference(b))[0]"], "sol_header": "def sol(a=\"quytextila\", b=\"mydyhopakokinavo\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find a character in one string that is not in the other.\n\n    Sample Input:\n    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'\n\n    Sample Output:\n    't'  # or .?yI\n    \"\"\"", "weight": 1.0, "sat": "def sat(c: str, a=\"quytextila\", b=\"mydyhopakokinavo\"):\n    return (c in a) != (c in b)", "input": "def sat(c: str, a=\"quytextila\", b=\"mydyhopakokinavo\"):\n    return (c in a) != (c in b)", "target": ""}
{"module": "human_eval.py", "name": "Fibonacci:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#55", "sol_bodies": ["    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"], "sol_header": "def sol(n=1402):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the first n Fibonacci numbers\n\n    Sample Input:\n    4\n\n    Sample Output:\n    [1, 1, 2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], n=1402):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))", "input": "def sat(nums: List[int], n=1402):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))", "target": ""}
{"module": "human_eval.py", "name": "Fibonacci:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#55", "sol_bodies": ["    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"], "sol_header": "def sol(n=537):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the first n Fibonacci numbers\n\n    Sample Input:\n    4\n\n    Sample Output:\n    [1, 1, 2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], n=537):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))", "input": "def sat(nums: List[int], n=537):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))", "target": ""}
{"module": "human_eval.py", "name": "Fibonacci:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#55", "sol_bodies": ["    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"], "sol_header": "def sol(n=6968):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the first n Fibonacci numbers\n\n    Sample Input:\n    4\n\n    Sample Output:\n    [1, 1, 2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], n=6968):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))", "input": "def sat(nums: List[int], n=6968):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))", "target": ""}
{"module": "human_eval.py", "name": "Fibonacci:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#55", "sol_bodies": ["    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"], "sol_header": "def sol(n=5585):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the first n Fibonacci numbers\n\n    Sample Input:\n    4\n\n    Sample Output:\n    [1, 1, 2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], n=5585):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))", "input": "def sat(nums: List[int], n=5585):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))", "target": ""}
{"module": "human_eval.py", "name": "Fibonacci:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#55", "sol_bodies": ["    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"], "sol_header": "def sol(n=7277):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the first n Fibonacci numbers\n\n    Sample Input:\n    4\n\n    Sample Output:\n    [1, 1, 2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], n=7277):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))", "input": "def sat(nums: List[int], n=7277):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))", "target": ""}
{"module": "human_eval.py", "name": "Monotonic:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#57", "sol_bodies": ["    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""], "sol_header": "def sol(nums=[2, 4, 17, 29, 31, 1000, 416629]):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n\n    Sample Input:\n    [1, 2, 5]\n\n    Sample Output:\n    \"increasing\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(direction: str, nums=[2, 4, 17, 29, 31, 1000, 416629]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))", "input": "def sat(direction: str, nums=[2, 4, 17, 29, 31, 1000, 416629]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))", "target": ""}
{"module": "human_eval.py", "name": "Monotonic:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#57", "sol_bodies": ["    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""], "sol_header": "def sol(nums=[540, 713, 887, 964]):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n\n    Sample Input:\n    [1, 2, 5]\n\n    Sample Output:\n    \"increasing\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(direction: str, nums=[540, 713, 887, 964]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))", "input": "def sat(direction: str, nums=[540, 713, 887, 964]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))", "target": ""}
{"module": "human_eval.py", "name": "Monotonic:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#57", "sol_bodies": ["    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""], "sol_header": "def sol(nums=[764, 291, 171]):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n\n    Sample Input:\n    [1, 2, 5]\n\n    Sample Output:\n    \"increasing\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(direction: str, nums=[764, 291, 171]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))", "input": "def sat(direction: str, nums=[764, 291, 171]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))", "target": ""}
{"module": "human_eval.py", "name": "Monotonic:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#57", "sol_bodies": ["    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""], "sol_header": "def sol(nums=[74, 168, 229, 302, 430, 450, 481, 783]):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n\n    Sample Input:\n    [1, 2, 5]\n\n    Sample Output:\n    \"increasing\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(direction: str, nums=[74, 168, 229, 302, 430, 450, 481, 783]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))", "input": "def sat(direction: str, nums=[74, 168, 229, 302, 430, 450, 481, 783]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))", "target": ""}
{"module": "human_eval.py", "name": "Monotonic:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#57", "sol_bodies": ["    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""], "sol_header": "def sol(nums=[826, 784, 726, 537, 536, 392, 250, 241, 161]):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n\n    Sample Input:\n    [1, 2, 5]\n\n    Sample Output:\n    \"increasing\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(direction: str, nums=[826, 784, 726, 537, 536, 392, 250, 241, 161]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))", "input": "def sat(direction: str, nums=[826, 784, 726, 537, 536, 392, 250, 241, 161]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))", "target": ""}
{"module": "human_eval.py", "name": "CommonNumbers:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#58", "sol_bodies": ["    return sorted(set(a).intersection(set(b)))"], "sol_header": "def sol(a=[2, 416629, 2, 4, 17, 29, 31, 1000], b=[31, 2, 4, 17, 29, 41205]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find numbers common to a and b\n\n    Sample Input:\n    [1, 2, 3], [3, 4, 5]\n\n    Sample Output:\n    [3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(common: List[int], a=[2, 416629, 2, 4, 17, 29, 31, 1000], b=[31, 2, 4, 17, 29, 41205]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)", "input": "def sat(common: List[int], a=[2, 416629, 2, 4, 17, 29, 31, 1000], b=[31, 2, 4, 17, 29, 41205]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)", "target": ""}
{"module": "human_eval.py", "name": "CommonNumbers:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#58", "sol_bodies": ["    return sorted(set(a).intersection(set(b)))"], "sol_header": "def sol(a=[824, 853, 392, 835, 225, 96], b=[73, 534, 705, 376, 376, 965, 404, 976]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find numbers common to a and b\n\n    Sample Input:\n    [1, 2, 3], [3, 4, 5]\n\n    Sample Output:\n    [3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(common: List[int], a=[824, 853, 392, 835, 225, 96], b=[73, 534, 705, 376, 376, 965, 404, 976]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)", "input": "def sat(common: List[int], a=[824, 853, 392, 835, 225, 96], b=[73, 534, 705, 376, 376, 965, 404, 976]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)", "target": ""}
{"module": "human_eval.py", "name": "CommonNumbers:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#58", "sol_bodies": ["    return sorted(set(a).intersection(set(b)))"], "sol_header": "def sol(a=[338, 882, 92, 234], b=[993, 977, 403]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find numbers common to a and b\n\n    Sample Input:\n    [1, 2, 3], [3, 4, 5]\n\n    Sample Output:\n    [3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(common: List[int], a=[338, 882, 92, 234], b=[993, 977, 403]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)", "input": "def sat(common: List[int], a=[338, 882, 92, 234], b=[993, 977, 403]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)", "target": ""}
{"module": "human_eval.py", "name": "CommonNumbers:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#58", "sol_bodies": ["    return sorted(set(a).intersection(set(b)))"], "sol_header": "def sol(a=[950, 299, 581, 222, 490, 758, 58, 76, 808, 814], b=[790, 200, 814, 851, 902, 490, 581, 808, 950, 343, 758]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find numbers common to a and b\n\n    Sample Input:\n    [1, 2, 3], [3, 4, 5]\n\n    Sample Output:\n    [3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(common: List[int], a=[950, 299, 581, 222, 490, 758, 58, 76, 808, 814], b=[790, 200, 814, 851, 902, 490, 581, 808, 950, 343, 758]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)", "input": "def sat(common: List[int], a=[950, 299, 581, 222, 490, 758, 58, 76, 808, 814], b=[790, 200, 814, 851, 902, 490, 581, 808, 950, 343, 758]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)", "target": ""}
{"module": "human_eval.py", "name": "CommonNumbers:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#58", "sol_bodies": ["    return sorted(set(a).intersection(set(b)))"], "sol_header": "def sol(a=[452, 318, 348, 995, 733, 874, 699], b=[733, 348, 614, 874, 699, 995, 318, 167, 452]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find numbers common to a and b\n\n    Sample Input:\n    [1, 2, 3], [3, 4, 5]\n\n    Sample Output:\n    [3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(common: List[int], a=[452, 318, 348, 995, 733, 874, 699], b=[733, 348, 614, 874, 699, 995, 318, 167, 452]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)", "input": "def sat(common: List[int], a=[452, 318, 348, 995, 733, 874, 699], b=[733, 348, 614, 874, 699, 995, 318, 167, 452]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)", "target": ""}
{"module": "human_eval.py", "name": "LargestPrimeFactor:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#59", "sol_bodies": ["    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"], "sol_header": "def sol(n=101076):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest prime factor of n.\n\n    Sample Input:\n    125\n\n    Sample Output:\n    5\n    \"\"\"", "weight": 1.0, "sat": "def sat(p: int, n=101076):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))", "input": "def sat(p: int, n=101076):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))", "target": ""}
{"module": "human_eval.py", "name": "LargestPrimeFactor:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#59", "sol_bodies": ["    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"], "sol_header": "def sol(n=15132):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest prime factor of n.\n\n    Sample Input:\n    125\n\n    Sample Output:\n    5\n    \"\"\"", "weight": 1.0, "sat": "def sat(p: int, n=15132):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))", "input": "def sat(p: int, n=15132):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))", "target": ""}
{"module": "human_eval.py", "name": "LargestPrimeFactor:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#59", "sol_bodies": ["    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"], "sol_header": "def sol(n=22184):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest prime factor of n.\n\n    Sample Input:\n    125\n\n    Sample Output:\n    5\n    \"\"\"", "weight": 1.0, "sat": "def sat(p: int, n=22184):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))", "input": "def sat(p: int, n=22184):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))", "target": ""}
{"module": "human_eval.py", "name": "LargestPrimeFactor:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#59", "sol_bodies": ["    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"], "sol_header": "def sol(n=70875):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest prime factor of n.\n\n    Sample Input:\n    125\n\n    Sample Output:\n    5\n    \"\"\"", "weight": 1.0, "sat": "def sat(p: int, n=70875):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))", "input": "def sat(p: int, n=70875):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))", "target": ""}
{"module": "human_eval.py", "name": "LargestPrimeFactor:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#59", "sol_bodies": ["    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"], "sol_header": "def sol(n=63088):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the largest prime factor of n.\n\n    Sample Input:\n    125\n\n    Sample Output:\n    5\n    \"\"\"", "weight": 1.0, "sat": "def sat(p: int, n=63088):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))", "input": "def sat(p: int, n=63088):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))", "target": ""}
{"module": "human_eval.py", "name": "CumulativeSums:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#60", "sol_bodies": ["    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"], "sol_header": "def sol(n=104):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the sums of the integers from 1 to n\n\n    Sample Input:\n    3\n\n    Sample Output:\n    [0, 1, 3, 6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(sums: List[int], n=104):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0", "input": "def sat(sums: List[int], n=104):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0", "target": ""}
{"module": "human_eval.py", "name": "CumulativeSums:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#60", "sol_bodies": ["    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"], "sol_header": "def sol(n=19891):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the sums of the integers from 1 to n\n\n    Sample Input:\n    3\n\n    Sample Output:\n    [0, 1, 3, 6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(sums: List[int], n=19891):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0", "input": "def sat(sums: List[int], n=19891):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0", "target": ""}
{"module": "human_eval.py", "name": "CumulativeSums:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#60", "sol_bodies": ["    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"], "sol_header": "def sol(n=11023):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the sums of the integers from 1 to n\n\n    Sample Input:\n    3\n\n    Sample Output:\n    [0, 1, 3, 6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(sums: List[int], n=11023):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0", "input": "def sat(sums: List[int], n=11023):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0", "target": ""}
{"module": "human_eval.py", "name": "CumulativeSums:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#60", "sol_bodies": ["    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"], "sol_header": "def sol(n=10840):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the sums of the integers from 1 to n\n\n    Sample Input:\n    3\n\n    Sample Output:\n    [0, 1, 3, 6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(sums: List[int], n=10840):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0", "input": "def sat(sums: List[int], n=10840):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0", "target": ""}
{"module": "human_eval.py", "name": "CumulativeSums:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#60", "sol_bodies": ["    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"], "sol_header": "def sol(n=14049):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the sums of the integers from 1 to n\n\n    Sample Input:\n    3\n\n    Sample Output:\n    [0, 1, 3, 6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(sums: List[int], n=14049):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0", "input": "def sat(sums: List[int], n=14049):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0", "target": ""}
{"module": "human_eval.py", "name": "ParenDepth:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#61\n\nNote that problems 61 and 56 are essentially the same", "sol_bodies": ["    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"], "sol_header": "def sol(parens=\"((())()(()()))(())\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n\n    Sample Input:\n    \"()((()))\"\n\n    Sample Output:\n    [1, 0, 7, 6, 5, 4, 3, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(matches: List[int], parens=\"((())()(()()))(())\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)", "input": "def sat(matches: List[int], parens=\"((())()(()()))(())\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)", "target": ""}
{"module": "human_eval.py", "name": "ParenDepth:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#61\n\nNote that problems 61 and 56 are essentially the same", "sol_bodies": ["    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"], "sol_header": "def sol(parens=\"\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n\n    Sample Input:\n    \"()((()))\"\n\n    Sample Output:\n    [1, 0, 7, 6, 5, 4, 3, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(matches: List[int], parens=\"\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)", "input": "def sat(matches: List[int], parens=\"\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)", "target": ""}
{"module": "human_eval.py", "name": "ParenDepth:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#61\n\nNote that problems 61 and 56 are essentially the same", "sol_bodies": ["    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"], "sol_header": "def sol(parens=\"()\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n\n    Sample Input:\n    \"()((()))\"\n\n    Sample Output:\n    [1, 0, 7, 6, 5, 4, 3, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(matches: List[int], parens=\"()\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)", "input": "def sat(matches: List[int], parens=\"()\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)", "target": ""}
{"module": "human_eval.py", "name": "ParenDepth:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#61\n\nNote that problems 61 and 56 are essentially the same", "sol_bodies": ["    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"], "sol_header": "def sol(parens=\"((()(())))\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n\n    Sample Input:\n    \"()((()))\"\n\n    Sample Output:\n    [1, 0, 7, 6, 5, 4, 3, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(matches: List[int], parens=\"((()(())))\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)", "input": "def sat(matches: List[int], parens=\"((()(())))\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)", "target": ""}
{"module": "human_eval.py", "name": "ParenDepth:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#61\n\nNote that problems 61 and 56 are essentially the same", "sol_bodies": ["    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"], "sol_header": "def sol(parens=\"(())\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n\n    Sample Input:\n    \"()((()))\"\n\n    Sample Output:\n    [1, 0, 7, 6, 5, 4, 3, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(matches: List[int], parens=\"(())\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)", "input": "def sat(matches: List[int], parens=\"(())\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)", "target": ""}
{"module": "human_eval.py", "name": "Derivative:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#62\n\nThis puzzle gives the raw definition of a derivative in terms of small changes in x.", "sol_bodies": ["    return [i * poly[i] for i in range(1, len(poly))]"], "sol_header": "def sol(poly=[2, 1, 0, 4, 19, 231, 0, 5]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n\n    Sample Input:\n    [3, 4, 1] # 3 + 4x + x^2\n\n    Sample Output:\n    [2, 4]   # 4 + 2x^2\n    \"\"\"", "weight": 1.0, "sat": "def sat(derivative: List[int], poly=[2, 1, 0, 4, 19, 231, 0, 5]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))", "input": "def sat(derivative: List[int], poly=[2, 1, 0, 4, 19, 231, 0, 5]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))", "target": ""}
{"module": "human_eval.py", "name": "Derivative:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#62\n\nThis puzzle gives the raw definition of a derivative in terms of small changes in x.", "sol_bodies": ["    return [i * poly[i] for i in range(1, len(poly))]"], "sol_header": "def sol(poly=[6, -7, -8, 3]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n\n    Sample Input:\n    [3, 4, 1] # 3 + 4x + x^2\n\n    Sample Output:\n    [2, 4]   # 4 + 2x^2\n    \"\"\"", "weight": 1.0, "sat": "def sat(derivative: List[int], poly=[6, -7, -8, 3]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))", "input": "def sat(derivative: List[int], poly=[6, -7, -8, 3]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))", "target": ""}
{"module": "human_eval.py", "name": "Derivative:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#62\n\nThis puzzle gives the raw definition of a derivative in terms of small changes in x.", "sol_bodies": ["    return [i * poly[i] for i in range(1, len(poly))]"], "sol_header": "def sol(poly=[-5, 5, -6, 7]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n\n    Sample Input:\n    [3, 4, 1] # 3 + 4x + x^2\n\n    Sample Output:\n    [2, 4]   # 4 + 2x^2\n    \"\"\"", "weight": 1.0, "sat": "def sat(derivative: List[int], poly=[-5, 5, -6, 7]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))", "input": "def sat(derivative: List[int], poly=[-5, 5, -6, 7]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))", "target": ""}
{"module": "human_eval.py", "name": "Derivative:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#62\n\nThis puzzle gives the raw definition of a derivative in terms of small changes in x.", "sol_bodies": ["    return [i * poly[i] for i in range(1, len(poly))]"], "sol_header": "def sol(poly=[-8, 2, 1, -8, 9, -10, -2, -7, -10]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n\n    Sample Input:\n    [3, 4, 1] # 3 + 4x + x^2\n\n    Sample Output:\n    [2, 4]   # 4 + 2x^2\n    \"\"\"", "weight": 1.0, "sat": "def sat(derivative: List[int], poly=[-8, 2, 1, -8, 9, -10, -2, -7, -10]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))", "input": "def sat(derivative: List[int], poly=[-8, 2, 1, -8, 9, -10, -2, -7, -10]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))", "target": ""}
{"module": "human_eval.py", "name": "Derivative:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#62\n\nThis puzzle gives the raw definition of a derivative in terms of small changes in x.", "sol_bodies": ["    return [i * poly[i] for i in range(1, len(poly))]"], "sol_header": "def sol(poly=[5, -1, -4, -2, 7, -9, 3, 9]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n\n    Sample Input:\n    [3, 4, 1] # 3 + 4x + x^2\n\n    Sample Output:\n    [2, 4]   # 4 + 2x^2\n    \"\"\"", "weight": 1.0, "sat": "def sat(derivative: List[int], poly=[5, -1, -4, -2, 7, -9, 3, 9]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))", "input": "def sat(derivative: List[int], poly=[5, -1, -4, -2, 7, -9, 3, 9]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))", "target": ""}
{"module": "human_eval.py", "name": "Fib3:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#63\n\nAlmost identical to problem 46", "sol_bodies": ["    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"], "sol_header": "def sol(target=124156):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[int], target=124156):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target", "input": "def sat(init: List[int], target=124156):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target", "target": ""}
{"module": "human_eval.py", "name": "Fib3:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#63\n\nAlmost identical to problem 46", "sol_bodies": ["    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"], "sol_header": "def sol(target=4050):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[int], target=4050):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target", "input": "def sat(init: List[int], target=4050):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target", "target": ""}
{"module": "human_eval.py", "name": "Fib3:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#63\n\nAlmost identical to problem 46", "sol_bodies": ["    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"], "sol_header": "def sol(target=0):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[int], target=0):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target", "input": "def sat(init: List[int], target=0):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target", "target": ""}
{"module": "human_eval.py", "name": "Fib3:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#63\n\nAlmost identical to problem 46", "sol_bodies": ["    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"], "sol_header": "def sol(target=4644):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[int], target=4644):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target", "input": "def sat(init: List[int], target=4644):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target", "target": ""}
{"module": "human_eval.py", "name": "Fib3:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#63\n\nAlmost identical to problem 46", "sol_bodies": ["    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"], "sol_header": "def sol(target=3):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[int], target=3):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target", "input": "def sat(init: List[int], target=3):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target", "target": ""}
{"module": "human_eval.py", "name": "FindVowels:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#64\n\nVery similar to RemoveVowels \\#51", "sol_bodies": ["    return [\"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")\n            for text in texts]"], "sol_header": "def sol(texts=['Hello, world!', 'Goodbye, world!']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)\n\n    Sample Input:\n    [\"You can do it!\", \"CAT\"]\n\n    Sample Output:\n    [\"ouaoi\", \"A\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(vowels: List[str], texts=['Hello, world!', 'Goodbye, world!']):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)", "input": "def sat(vowels: List[str], texts=['Hello, world!', 'Goodbye, world!']):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)", "target": ""}
{"module": "human_eval.py", "name": "FindVowels:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#64\n\nVery similar to RemoveVowels \\#51", "sol_bodies": ["    return [\"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")\n            for text in texts]"], "sol_header": "def sol(texts=['kelUthI', 'RoRu', 'JuKEBesYtIcHakEQuala', 'TIzEXOtExTyJASiNiKi', 'tEWIFObesY', 'KyxySe', 'kEboWulOfEZEFuMYCH', 'XAPIFYS']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)\n\n    Sample Input:\n    [\"You can do it!\", \"CAT\"]\n\n    Sample Output:\n    [\"ouaoi\", \"A\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(vowels: List[str], texts=['kelUthI', 'RoRu', 'JuKEBesYtIcHakEQuala', 'TIzEXOtExTyJASiNiKi', 'tEWIFObesY', 'KyxySe', 'kEboWulOfEZEFuMYCH', 'XAPIFYS']):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)", "input": "def sat(vowels: List[str], texts=['kelUthI', 'RoRu', 'JuKEBesYtIcHakEQuala', 'TIzEXOtExTyJASiNiKi', 'tEWIFObesY', 'KyxySe', 'kEboWulOfEZEFuMYCH', 'XAPIFYS']):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)", "target": ""}
{"module": "human_eval.py", "name": "FindVowels:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#64\n\nVery similar to RemoveVowels \\#51", "sol_bodies": ["    return [\"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")\n            for text in texts]"], "sol_header": "def sol(texts=['sATExtIjopEJOWIvU', 'v', 'teXTOGOzetEX', 'CAMe', 'SApiQuUzISYG', 'NaV']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)\n\n    Sample Input:\n    [\"You can do it!\", \"CAT\"]\n\n    Sample Output:\n    [\"ouaoi\", \"A\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(vowels: List[str], texts=['sATExtIjopEJOWIvU', 'v', 'teXTOGOzetEX', 'CAMe', 'SApiQuUzISYG', 'NaV']):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)", "input": "def sat(vowels: List[str], texts=['sATExtIjopEJOWIvU', 'v', 'teXTOGOzetEX', 'CAMe', 'SApiQuUzISYG', 'NaV']):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)", "target": ""}
{"module": "human_eval.py", "name": "FindVowels:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#64\n\nVery similar to RemoveVowels \\#51", "sol_bodies": ["    return [\"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")\n            for text in texts]"], "sol_header": "def sol(texts=[]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)\n\n    Sample Input:\n    [\"You can do it!\", \"CAT\"]\n\n    Sample Output:\n    [\"ouaoi\", \"A\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(vowels: List[str], texts=[]):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)", "input": "def sat(vowels: List[str], texts=[]):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)", "target": ""}
{"module": "human_eval.py", "name": "FindVowels:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#64\n\nVery similar to RemoveVowels \\#51", "sol_bodies": ["    return [\"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")\n            for text in texts]"], "sol_header": "def sol(texts=['mAloCyBOSAwUg', 'W', 'BEsICHeCeLoNO']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)\n\n    Sample Input:\n    [\"You can do it!\", \"CAT\"]\n\n    Sample Output:\n    [\"ouaoi\", \"A\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(vowels: List[str], texts=['mAloCyBOSAwUg', 'W', 'BEsICHeCeLoNO']):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)", "input": "def sat(vowels: List[str], texts=['mAloCyBOSAwUg', 'W', 'BEsICHeCeLoNO']):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)", "target": ""}
{"module": "human_eval.py", "name": "CharSum:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#66", "sol_bodies": ["    return sum(ord(c) for c in s if c.isupper())"], "sol_header": "def sol(s=\"Add ME uP AND YOU WILL GET A BIG NUMBER!\"):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n\n    Sample Input:\n    ARt\n\n    Sample Output:\n    147 # = 65 + 82\n    \"\"\"", "weight": 1.0, "sat": "def sat(tot: int, s=\"Add ME uP AND YOU WILL GET A BIG NUMBER!\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0", "input": "def sat(tot: int, s=\"Add ME uP AND YOU WILL GET A BIG NUMBER!\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0", "target": ""}
{"module": "human_eval.py", "name": "CharSum:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#66", "sol_bodies": ["    return sum(ord(c) for c in s if c.isupper())"], "sol_header": "def sol(s=\"VRkmX=(1oF#l\"):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n\n    Sample Input:\n    ARt\n\n    Sample Output:\n    147 # = 65 + 82\n    \"\"\"", "weight": 1.0, "sat": "def sat(tot: int, s=\"VRkmX=(1oF#l\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0", "input": "def sat(tot: int, s=\"VRkmX=(1oF#l\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0", "target": ""}
{"module": "human_eval.py", "name": "CharSum:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#66", "sol_bodies": ["    return sum(ord(c) for c in s if c.isupper())"], "sol_header": "def sol(s=\"*?sAJJ;FY8c!7zFwA\"):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n\n    Sample Input:\n    ARt\n\n    Sample Output:\n    147 # = 65 + 82\n    \"\"\"", "weight": 1.0, "sat": "def sat(tot: int, s=\"*?sAJJ;FY8c!7zFwA\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0", "input": "def sat(tot: int, s=\"*?sAJJ;FY8c!7zFwA\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0", "target": ""}
{"module": "human_eval.py", "name": "CharSum:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#66", "sol_bodies": ["    return sum(ord(c) for c in s if c.isupper())"], "sol_header": "def sol(s=\"Vmv%e8d3P\"):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n\n    Sample Input:\n    ARt\n\n    Sample Output:\n    147 # = 65 + 82\n    \"\"\"", "weight": 1.0, "sat": "def sat(tot: int, s=\"Vmv%e8d3P\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0", "input": "def sat(tot: int, s=\"Vmv%e8d3P\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0", "target": ""}
{"module": "human_eval.py", "name": "CharSum:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#66", "sol_bodies": ["    return sum(ord(c) for c in s if c.isupper())"], "sol_header": "def sol(s=\"K8B\"):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n\n    Sample Input:\n    ARt\n\n    Sample Output:\n    147 # = 65 + 82\n    \"\"\"", "weight": 1.0, "sat": "def sat(tot: int, s=\"K8B\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0", "input": "def sat(tot: int, s=\"K8B\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0", "target": ""}
{"module": "human_eval.py", "name": "MissingBananas:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#67", "sol_bodies": ["    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"], "sol_header": "def sol(bowl=\"5024 apples and 12189 oranges\", total=12491241):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n\n    bowl=\"3 apples and 4 oranges\", total=12 => 5\n    \"\"\"", "weight": 1.0, "sat": "def sat(bananas: int, bowl=\"5024 apples and 12189 oranges\", total=12491241):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total", "input": "def sat(bananas: int, bowl=\"5024 apples and 12189 oranges\", total=12491241):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total", "target": ""}
{"module": "human_eval.py", "name": "MissingBananas:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#67", "sol_bodies": ["    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"], "sol_header": "def sol(bowl=\"7 apples and 9 oranges\", total=21):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n\n    bowl=\"3 apples and 4 oranges\", total=12 => 5\n    \"\"\"", "weight": 1.0, "sat": "def sat(bananas: int, bowl=\"7 apples and 9 oranges\", total=21):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total", "input": "def sat(bananas: int, bowl=\"7 apples and 9 oranges\", total=21):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total", "target": ""}
{"module": "human_eval.py", "name": "MissingBananas:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#67", "sol_bodies": ["    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"], "sol_header": "def sol(bowl=\"508738582 apples and 346410095 oranges\", total=1452490389):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n\n    bowl=\"3 apples and 4 oranges\", total=12 => 5\n    \"\"\"", "weight": 1.0, "sat": "def sat(bananas: int, bowl=\"508738582 apples and 346410095 oranges\", total=1452490389):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total", "input": "def sat(bananas: int, bowl=\"508738582 apples and 346410095 oranges\", total=1452490389):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total", "target": ""}
{"module": "human_eval.py", "name": "MissingBananas:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#67", "sol_bodies": ["    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"], "sol_header": "def sol(bowl=\"28767 apples and 49488 oranges\", total=112303):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n\n    bowl=\"3 apples and 4 oranges\", total=12 => 5\n    \"\"\"", "weight": 1.0, "sat": "def sat(bananas: int, bowl=\"28767 apples and 49488 oranges\", total=112303):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total", "input": "def sat(bananas: int, bowl=\"28767 apples and 49488 oranges\", total=112303):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total", "target": ""}
{"module": "human_eval.py", "name": "MissingBananas:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#67", "sol_bodies": ["    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"], "sol_header": "def sol(bowl=\"29991 apples and 99737 oranges\", total=155600):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n\n    bowl=\"3 apples and 4 oranges\", total=12 => 5\n    \"\"\"", "weight": 1.0, "sat": "def sat(bananas: int, bowl=\"29991 apples and 99737 oranges\", total=155600):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total", "input": "def sat(bananas: int, bowl=\"29991 apples and 99737 oranges\", total=155600):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total", "target": ""}
{"module": "human_eval.py", "name": "SmallestEven:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#68", "sol_bodies": ["    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"], "sol_header": "def sol(nums=[125123, 422323, 141, 5325, 812152, 9, 42145, 5313, 421, 812152]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n\n    Sample Input:\n    [1, 7, 4, 6, 10, 11, 14]\n\n    Sample Output:\n    [4, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(val_index: List[int], nums=[125123, 422323, 141, 5325, 812152, 9, 42145, 5313, 421, 812152]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])", "input": "def sat(val_index: List[int], nums=[125123, 422323, 141, 5325, 812152, 9, 42145, 5313, 421, 812152]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])", "target": ""}
{"module": "human_eval.py", "name": "SmallestEven:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#68", "sol_bodies": ["    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"], "sol_header": "def sol(nums=[38940, 7988, 78915]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n\n    Sample Input:\n    [1, 7, 4, 6, 10, 11, 14]\n\n    Sample Output:\n    [4, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(val_index: List[int], nums=[38940, 7988, 78915]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])", "input": "def sat(val_index: List[int], nums=[38940, 7988, 78915]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])", "target": ""}
{"module": "human_eval.py", "name": "SmallestEven:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#68", "sol_bodies": ["    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"], "sol_header": "def sol(nums=[26392632, 33805163]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n\n    Sample Input:\n    [1, 7, 4, 6, 10, 11, 14]\n\n    Sample Output:\n    [4, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(val_index: List[int], nums=[26392632, 33805163]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])", "input": "def sat(val_index: List[int], nums=[26392632, 33805163]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])", "target": ""}
{"module": "human_eval.py", "name": "SmallestEven:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#68", "sol_bodies": ["    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"], "sol_header": "def sol(nums=[744557286]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n\n    Sample Input:\n    [1, 7, 4, 6, 10, 11, 14]\n\n    Sample Output:\n    [4, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(val_index: List[int], nums=[744557286]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])", "input": "def sat(val_index: List[int], nums=[744557286]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])", "target": ""}
{"module": "human_eval.py", "name": "SmallestEven:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#68", "sol_bodies": ["    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"], "sol_header": "def sol(nums=[4512821, 7022753, 5506558]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n\n    Sample Input:\n    [1, 7, 4, 6, 10, 11, 14]\n\n    Sample Output:\n    [4, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(val_index: List[int], nums=[4512821, 7022753, 5506558]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])", "input": "def sat(val_index: List[int], nums=[4512821, 7022753, 5506558]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])", "target": ""}
{"module": "human_eval.py", "name": "GreatestHIndex:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#69", "sol_bodies": ["    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"], "sol_header": "def sol(seq=[3, 1, 4, 17, 5, 17, 2, 1, 41, 32, 2, 5, 5, 5, 5]):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n\n    Sample Input:\n    [1, 2, 2, 3, 3, 3, 4, 4]\n\n    Sample Output:\n    3\n    \"\"\"", "weight": 1.0, "sat": "def sat(h: int, seq=[3, 1, 4, 17, 5, 17, 2, 1, 41, 32, 2, 5, 5, 5, 5]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0", "input": "def sat(h: int, seq=[3, 1, 4, 17, 5, 17, 2, 1, 41, 32, 2, 5, 5, 5, 5]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0", "target": ""}
{"module": "human_eval.py", "name": "GreatestHIndex:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#69", "sol_bodies": ["    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"], "sol_header": "def sol(seq=[5, 5, 4, 4, 0, 1, 3, 7, 2, 1, 0, 1, 8, 7, 2, 7, 4, 5, 2, 7, 5, 1, 9, 4, 7, 6, 3, 0, 1, 0, 6, 8, 0, 8, 9, 8, 3, 9, 4, 4, 4, 3, 8, 9, 5, 2, 5, 7, 9, 6, 2, 3, 0, 6, 0, 7, 8, 2, 2, 5, 1, 6, 1, 7, 8, 7, 6, 7]):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n\n    Sample Input:\n    [1, 2, 2, 3, 3, 3, 4, 4]\n\n    Sample Output:\n    3\n    \"\"\"", "weight": 1.0, "sat": "def sat(h: int, seq=[5, 5, 4, 4, 0, 1, 3, 7, 2, 1, 0, 1, 8, 7, 2, 7, 4, 5, 2, 7, 5, 1, 9, 4, 7, 6, 3, 0, 1, 0, 6, 8, 0, 8, 9, 8, 3, 9, 4, 4, 4, 3, 8, 9, 5, 2, 5, 7, 9, 6, 2, 3, 0, 6, 0, 7, 8, 2, 2, 5, 1, 6, 1, 7, 8, 7, 6, 7]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0", "input": "def sat(h: int, seq=[5, 5, 4, 4, 0, 1, 3, 7, 2, 1, 0, 1, 8, 7, 2, 7, 4, 5, 2, 7, 5, 1, 9, 4, 7, 6, 3, 0, 1, 0, 6, 8, 0, 8, 9, 8, 3, 9, 4, 4, 4, 3, 8, 9, 5, 2, 5, 7, 9, 6, 2, 3, 0, 6, 0, 7, 8, 2, 2, 5, 1, 6, 1, 7, 8, 7, 6, 7]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0", "target": ""}
{"module": "human_eval.py", "name": "GreatestHIndex:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#69", "sol_bodies": ["    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"], "sol_header": "def sol(seq=[3, 9, 0, 8, 2, 9, 6, 1, 8, 3, 5, 5, 4, 9, 0, 1, 0, 3, 4, 8, 7, 2, 4, 7, 1, 1, 7, 2, 1, 4, 1, 0]):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n\n    Sample Input:\n    [1, 2, 2, 3, 3, 3, 4, 4]\n\n    Sample Output:\n    3\n    \"\"\"", "weight": 1.0, "sat": "def sat(h: int, seq=[3, 9, 0, 8, 2, 9, 6, 1, 8, 3, 5, 5, 4, 9, 0, 1, 0, 3, 4, 8, 7, 2, 4, 7, 1, 1, 7, 2, 1, 4, 1, 0]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0", "input": "def sat(h: int, seq=[3, 9, 0, 8, 2, 9, 6, 1, 8, 3, 5, 5, 4, 9, 0, 1, 0, 3, 4, 8, 7, 2, 4, 7, 1, 1, 7, 2, 1, 4, 1, 0]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0", "target": ""}
{"module": "human_eval.py", "name": "GreatestHIndex:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#69", "sol_bodies": ["    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"], "sol_header": "def sol(seq=[7, 4, 1, 8, 6, 6, 6, 8, 5, 5, 8, 3, 0, 7, 2, 7, 2, 4, 5, 8, 6, 1, 1, 0, 0, 8, 8, 1, 5, 2, 1, 1, 7, 1, 3, 5, 6, 1, 7, 9, 6, 2, 6, 4, 7, 4, 3, 1, 2, 3, 9, 7, 7, 1, 7, 8, 6, 5, 9, 1, 6, 3, 4, 2, 4, 1, 7, 6, 3, 2, 5, 6, 1, 3, 9, 4, 9, 6, 9, 8, 1, 2, 3, 8]):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n\n    Sample Input:\n    [1, 2, 2, 3, 3, 3, 4, 4]\n\n    Sample Output:\n    3\n    \"\"\"", "weight": 1.0, "sat": "def sat(h: int, seq=[7, 4, 1, 8, 6, 6, 6, 8, 5, 5, 8, 3, 0, 7, 2, 7, 2, 4, 5, 8, 6, 1, 1, 0, 0, 8, 8, 1, 5, 2, 1, 1, 7, 1, 3, 5, 6, 1, 7, 9, 6, 2, 6, 4, 7, 4, 3, 1, 2, 3, 9, 7, 7, 1, 7, 8, 6, 5, 9, 1, 6, 3, 4, 2, 4, 1, 7, 6, 3, 2, 5, 6, 1, 3, 9, 4, 9, 6, 9, 8, 1, 2, 3, 8]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0", "input": "def sat(h: int, seq=[7, 4, 1, 8, 6, 6, 6, 8, 5, 5, 8, 3, 0, 7, 2, 7, 2, 4, 5, 8, 6, 1, 1, 0, 0, 8, 8, 1, 5, 2, 1, 1, 7, 1, 3, 5, 6, 1, 7, 9, 6, 2, 6, 4, 7, 4, 3, 1, 2, 3, 9, 7, 7, 1, 7, 8, 6, 5, 9, 1, 6, 3, 4, 2, 4, 1, 7, 6, 3, 2, 5, 6, 1, 3, 9, 4, 9, 6, 9, 8, 1, 2, 3, 8]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0", "target": ""}
{"module": "human_eval.py", "name": "GreatestHIndex:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#69", "sol_bodies": ["    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"], "sol_header": "def sol(seq=[1, 2, 6, 2]):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n\n    Sample Input:\n    [1, 2, 2, 3, 3, 3, 4, 4]\n\n    Sample Output:\n    3\n    \"\"\"", "weight": 1.0, "sat": "def sat(h: int, seq=[1, 2, 6, 2]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0", "input": "def sat(h: int, seq=[1, 2, 6, 2]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0", "target": ""}
{"module": "human_eval.py", "name": "WildSort:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#70", "sol_bodies": ["    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"], "sol_header": "def sol(li=[30, 12, 42, 717, 45, 317, 200, -1, 491, 32, 15]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n\n    Sample Input:\n    [1, 2, 7, 3, 4, 5, 6]\n\n    Sample Output:\n    [1, 7, 2, 6, 3, 5, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(strange: List[int], li=[30, 12, 42, 717, 45, 317, 200, -1, 491, 32, 15]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))", "input": "def sat(strange: List[int], li=[30, 12, 42, 717, 45, 317, 200, -1, 491, 32, 15]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))", "target": ""}
{"module": "human_eval.py", "name": "WildSort:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#70", "sol_bodies": ["    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"], "sol_header": "def sol(li=[8, 1, 0, 8, 1, 5, 2, 1, 7, 3, 0, 4, 0, 3, 8, 0, 9, 0, 7]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n\n    Sample Input:\n    [1, 2, 7, 3, 4, 5, 6]\n\n    Sample Output:\n    [1, 7, 2, 6, 3, 5, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(strange: List[int], li=[8, 1, 0, 8, 1, 5, 2, 1, 7, 3, 0, 4, 0, 3, 8, 0, 9, 0, 7]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))", "input": "def sat(strange: List[int], li=[8, 1, 0, 8, 1, 5, 2, 1, 7, 3, 0, 4, 0, 3, 8, 0, 9, 0, 7]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))", "target": ""}
{"module": "human_eval.py", "name": "WildSort:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#70", "sol_bodies": ["    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"], "sol_header": "def sol(li=[2, 0, 2, 4, 7, 6, 9]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n\n    Sample Input:\n    [1, 2, 7, 3, 4, 5, 6]\n\n    Sample Output:\n    [1, 7, 2, 6, 3, 5, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(strange: List[int], li=[2, 0, 2, 4, 7, 6, 9]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))", "input": "def sat(strange: List[int], li=[2, 0, 2, 4, 7, 6, 9]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))", "target": ""}
{"module": "human_eval.py", "name": "WildSort:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#70", "sol_bodies": ["    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"], "sol_header": "def sol(li=[5, 3, 9, 9, 5, 2, 9, 7, 0, 5, 7, 1, 2]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n\n    Sample Input:\n    [1, 2, 7, 3, 4, 5, 6]\n\n    Sample Output:\n    [1, 7, 2, 6, 3, 5, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(strange: List[int], li=[5, 3, 9, 9, 5, 2, 9, 7, 0, 5, 7, 1, 2]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))", "input": "def sat(strange: List[int], li=[5, 3, 9, 9, 5, 2, 9, 7, 0, 5, 7, 1, 2]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))", "target": ""}
{"module": "human_eval.py", "name": "WildSort:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#70", "sol_bodies": ["    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"], "sol_header": "def sol(li=[7, 1, 3]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n\n    Sample Input:\n    [1, 2, 7, 3, 4, 5, 6]\n\n    Sample Output:\n    [1, 7, 2, 6, 3, 5, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(strange: List[int], li=[7, 1, 3]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))", "input": "def sat(strange: List[int], li=[7, 1, 3]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))", "target": ""}
{"module": "human_eval.py", "name": "HeronTriangle:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#71\n\nThat problem essentially asks for Heron's formula for the area of a triangle in terms of its three sides.\nIn our version, we consider the related problem (also solved by Heron's formula) of finding 2d coordinates\nof a triangle with the given sides. If one knows the area, this is a straightforward calculation.", "sol_bodies": ["    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"], "sol_header": "def sol(sides=[8.9, 10.8, 17.0]):", "ans_type": "List[List[float]]", "sol_docstring": "    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n\n    Sample Input:\n    [3.0, 4.0, 5.0\n\n    Sample Output:\n    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(coords: List[List[float]], sides=[8.9, 10.8, 17.0]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))", "input": "def sat(coords: List[List[float]], sides=[8.9, 10.8, 17.0]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))", "target": ""}
{"module": "human_eval.py", "name": "HeronTriangle:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#71\n\nThat problem essentially asks for Heron's formula for the area of a triangle in terms of its three sides.\nIn our version, we consider the related problem (also solved by Heron's formula) of finding 2d coordinates\nof a triangle with the given sides. If one knows the area, this is a straightforward calculation.", "sol_bodies": ["    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"], "sol_header": "def sol(sides=[24.408110376178705, 32.72365349973282, 48.81696744586911]):", "ans_type": "List[List[float]]", "sol_docstring": "    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n\n    Sample Input:\n    [3.0, 4.0, 5.0\n\n    Sample Output:\n    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(coords: List[List[float]], sides=[24.408110376178705, 32.72365349973282, 48.81696744586911]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))", "input": "def sat(coords: List[List[float]], sides=[24.408110376178705, 32.72365349973282, 48.81696744586911]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))", "target": ""}
{"module": "human_eval.py", "name": "HeronTriangle:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#71\n\nThat problem essentially asks for Heron's formula for the area of a triangle in terms of its three sides.\nIn our version, we consider the related problem (also solved by Heron's formula) of finding 2d coordinates\nof a triangle with the given sides. If one knows the area, this is a straightforward calculation.", "sol_bodies": ["    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"], "sol_header": "def sol(sides=[27.451864724831378, 71.73620497337176, 72.2364568008756]):", "ans_type": "List[List[float]]", "sol_docstring": "    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n\n    Sample Input:\n    [3.0, 4.0, 5.0\n\n    Sample Output:\n    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(coords: List[List[float]], sides=[27.451864724831378, 71.73620497337176, 72.2364568008756]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))", "input": "def sat(coords: List[List[float]], sides=[27.451864724831378, 71.73620497337176, 72.2364568008756]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))", "target": ""}
{"module": "human_eval.py", "name": "HeronTriangle:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#71\n\nThat problem essentially asks for Heron's formula for the area of a triangle in terms of its three sides.\nIn our version, we consider the related problem (also solved by Heron's formula) of finding 2d coordinates\nof a triangle with the given sides. If one knows the area, this is a straightforward calculation.", "sol_bodies": ["    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"], "sol_header": "def sol(sides=[22.39325953731467, 22.640876224877417, 32.23640648363397]):", "ans_type": "List[List[float]]", "sol_docstring": "    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n\n    Sample Input:\n    [3.0, 4.0, 5.0\n\n    Sample Output:\n    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(coords: List[List[float]], sides=[22.39325953731467, 22.640876224877417, 32.23640648363397]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))", "input": "def sat(coords: List[List[float]], sides=[22.39325953731467, 22.640876224877417, 32.23640648363397]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))", "target": ""}
{"module": "human_eval.py", "name": "HeronTriangle:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#71\n\nThat problem essentially asks for Heron's formula for the area of a triangle in terms of its three sides.\nIn our version, we consider the related problem (also solved by Heron's formula) of finding 2d coordinates\nof a triangle with the given sides. If one knows the area, this is a straightforward calculation.", "sol_bodies": ["    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"], "sol_header": "def sol(sides=[45.986905476840235, 79.97976343909342, 86.26149779271437]):", "ans_type": "List[List[float]]", "sol_docstring": "    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n\n    Sample Input:\n    [3.0, 4.0, 5.0\n\n    Sample Output:\n    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(coords: List[List[float]], sides=[45.986905476840235, 79.97976343909342, 86.26149779271437]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))", "input": "def sat(coords: List[List[float]], sides=[45.986905476840235, 79.97976343909342, 86.26149779271437]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))", "target": ""}
{"module": "human_eval.py", "name": "InvestigateCrash:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#72", "sol_bodies": ["    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"], "sol_header": "def sol(weights=[1, 2, 5, 2, 1, 17], max_weight=100):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n\n    weights=[77, 40], max_weight=100 => -1\n\n    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(problem: int, weights=[1, 2, 5, 2, 1, 17], max_weight=100):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]", "input": "def sat(problem: int, weights=[1, 2, 5, 2, 1, 17], max_weight=100):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]", "target": ""}
{"module": "human_eval.py", "name": "InvestigateCrash:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#72", "sol_bodies": ["    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"], "sol_header": "def sol(weights=[17, 97, 77, 13, 13, 77, 13, 17], max_weight=314):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n\n    weights=[77, 40], max_weight=100 => -1\n\n    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(problem: int, weights=[17, 97, 77, 13, 13, 77, 13, 17], max_weight=314):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]", "input": "def sat(problem: int, weights=[17, 97, 77, 13, 13, 77, 13, 17], max_weight=314):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]", "target": ""}
{"module": "human_eval.py", "name": "InvestigateCrash:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#72", "sol_bodies": ["    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"], "sol_header": "def sol(weights=[51, 23, 10, 4, 7, 56, 12, 4, 10, 23, 51], max_weight=276):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n\n    weights=[77, 40], max_weight=100 => -1\n\n    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(problem: int, weights=[51, 23, 10, 4, 7, 56, 12, 4, 10, 23, 51], max_weight=276):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]", "input": "def sat(problem: int, weights=[51, 23, 10, 4, 7, 56, 12, 4, 10, 23, 51], max_weight=276):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]", "target": ""}
{"module": "human_eval.py", "name": "InvestigateCrash:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#72", "sol_bodies": ["    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"], "sol_header": "def sol(weights=[22, 81, 93, 22], max_weight=222):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n\n    weights=[77, 40], max_weight=100 => -1\n\n    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(problem: int, weights=[22, 81, 93, 22], max_weight=222):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]", "input": "def sat(problem: int, weights=[22, 81, 93, 22], max_weight=222):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]", "target": ""}
{"module": "human_eval.py", "name": "InvestigateCrash:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#72", "sol_bodies": ["    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"], "sol_header": "def sol(weights=[43, 37, 79, 37, 20], max_weight=222):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n\n    weights=[77, 40], max_weight=100 => -1\n\n    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(problem: int, weights=[43, 37, 79, 37, 20], max_weight=222):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]", "input": "def sat(problem: int, weights=[43, 37, 79, 37, 20], max_weight=222):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]", "target": ""}
{"module": "human_eval.py", "name": "ClosestPalindrome:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#73", "sol_bodies": ["    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"], "sol_header": "def sol(s=\"palindromordinals\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find the closest palindrome\n\n    Sample Input:\n    \"cat\"\n\n    Sample Output:\n    \"tat\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(pal: str, s=\"palindromordinals\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2", "input": "def sat(pal: str, s=\"palindromordinals\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2", "target": ""}
{"module": "human_eval.py", "name": "ClosestPalindrome:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#73", "sol_bodies": ["    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"], "sol_header": "def sol(s=\"ti=\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find the closest palindrome\n\n    Sample Input:\n    \"cat\"\n\n    Sample Output:\n    \"tat\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(pal: str, s=\"ti=\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2", "input": "def sat(pal: str, s=\"ti=\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2", "target": ""}
{"module": "human_eval.py", "name": "ClosestPalindrome:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#73", "sol_bodies": ["    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"], "sol_header": "def sol(s=\"bC\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find the closest palindrome\n\n    Sample Input:\n    \"cat\"\n\n    Sample Output:\n    \"tat\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(pal: str, s=\"bC\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2", "input": "def sat(pal: str, s=\"bC\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2", "target": ""}
{"module": "human_eval.py", "name": "ClosestPalindrome:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#73", "sol_bodies": ["    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"], "sol_header": "def sol(s=\"chachatexc0vchX)e1\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find the closest palindrome\n\n    Sample Input:\n    \"cat\"\n\n    Sample Output:\n    \"tat\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(pal: str, s=\"chachatexc0vchX)e1\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2", "input": "def sat(pal: str, s=\"chachatexc0vchX)e1\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2", "target": ""}
{"module": "human_eval.py", "name": "ClosestPalindrome:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#73", "sol_bodies": ["    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"], "sol_header": "def sol(s=\"w\"):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    Find the closest palindrome\n\n    Sample Input:\n    \"cat\"\n\n    Sample Output:\n    \"tat\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(pal: str, s=\"w\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2", "input": "def sat(pal: str, s=\"w\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2", "target": ""}
{"module": "human_eval.py", "name": "NarrowerList:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#74", "sol_bodies": ["    return min(lists, key=lambda x: sum(len(i) for i in x))"], "sol_header": "def sol(lists=[['this', 'list', 'is', 'narrow'], ['I', 'am', 'shorter but wider']]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n\n    Sample Input:\n    [[\"sh\", \"ort\"], [\"longest\"]]\n\n    Sample Output:\n    [[\"sh\", \"ort\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[str], lists=[['this', 'list', 'is', 'narrow'], ['I', 'am', 'shorter but wider']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists", "input": "def sat(li: List[str], lists=[['this', 'list', 'is', 'narrow'], ['I', 'am', 'shorter but wider']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists", "target": ""}
{"module": "human_eval.py", "name": "NarrowerList:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#74", "sol_bodies": ["    return min(lists, key=lambda x: sum(len(i) for i in x))"], "sol_header": "def sol(lists=[['gefypo', 'gomecythib'], ['vicowodasyhifeme', 'mojowu', 'poxuchuchacyweth']]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n\n    Sample Input:\n    [[\"sh\", \"ort\"], [\"longest\"]]\n\n    Sample Output:\n    [[\"sh\", \"ort\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[str], lists=[['gefypo', 'gomecythib'], ['vicowodasyhifeme', 'mojowu', 'poxuchuchacyweth']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists", "input": "def sat(li: List[str], lists=[['gefypo', 'gomecythib'], ['vicowodasyhifeme', 'mojowu', 'poxuchuchacyweth']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists", "target": ""}
{"module": "human_eval.py", "name": "NarrowerList:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#74", "sol_bodies": ["    return min(lists, key=lambda x: sum(len(i) for i in x))"], "sol_header": "def sol(lists=[['cil', 'vesic', 'gaquedane'], ['machetyt', 'pumepywotatofo'], ['zatex', 'gilygyxejimagiquav']]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n\n    Sample Input:\n    [[\"sh\", \"ort\"], [\"longest\"]]\n\n    Sample Output:\n    [[\"sh\", \"ort\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[str], lists=[['cil', 'vesic', 'gaquedane'], ['machetyt', 'pumepywotatofo'], ['zatex', 'gilygyxejimagiquav']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists", "input": "def sat(li: List[str], lists=[['cil', 'vesic', 'gaquedane'], ['machetyt', 'pumepywotatofo'], ['zatex', 'gilygyxejimagiquav']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists", "target": ""}
{"module": "human_eval.py", "name": "NarrowerList:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#74", "sol_bodies": ["    return min(lists, key=lambda x: sum(len(i) for i in x))"], "sol_header": "def sol(lists=[['hubibexuratezixekyl', 'todot'], ['mochokyhyzylethy', 'we'], ['sygymithajyhu', 'byziruchocetextyram', 'thizupesakocami']]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n\n    Sample Input:\n    [[\"sh\", \"ort\"], [\"longest\"]]\n\n    Sample Output:\n    [[\"sh\", \"ort\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[str], lists=[['hubibexuratezixekyl', 'todot'], ['mochokyhyzylethy', 'we'], ['sygymithajyhu', 'byziruchocetextyram', 'thizupesakocami']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists", "input": "def sat(li: List[str], lists=[['hubibexuratezixekyl', 'todot'], ['mochokyhyzylethy', 'we'], ['sygymithajyhu', 'byziruchocetextyram', 'thizupesakocami']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists", "target": ""}
{"module": "human_eval.py", "name": "NarrowerList:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#74", "sol_bodies": ["    return min(lists, key=lambda x: sum(len(i) for i in x))"], "sol_header": "def sol(lists=[['r', 'datucykokegyquazyta', 'gytextevavasochub'], ['faryjav', 'textebyquyho']]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n\n    Sample Input:\n    [[\"sh\", \"ort\"], [\"longest\"]]\n\n    Sample Output:\n    [[\"sh\", \"ort\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[str], lists=[['r', 'datucykokegyquazyta', 'gytextevavasochub'], ['faryjav', 'textebyquyho']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists", "input": "def sat(li: List[str], lists=[['r', 'datucykokegyquazyta', 'gytextevavasochub'], ['faryjav', 'textebyquyho']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists", "target": ""}
{"module": "human_eval.py", "name": "ThreePrimes:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#75", "sol_bodies": ["    primes = set(range(2, 1000))\n    for n in range(2, 1000):\n        if n in primes:\n            primes.difference_update(range(2 * n, 1000, n))\n    return [[p, q, r] for p in primes for q in primes if p <= q for r in primes if q <= r and p * q * r < 1000]"], "sol_header": "def sol():", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find all 247 integers <= 1000 that are the product of exactly three primes.\n    Each integer should represented as the list of its three prime factors.\n    [[2, 2, 2], [2, 2, 3],  [2, 2, 5], ...\n    \"\"\"", "weight": 1.0, "sat": "def sat(factors: List[List[int]]):\n    primes = set(range(2, 1000))\n    for n in range(2, 1000):\n        if n in primes:\n            primes.difference_update(range(2 * n, 1000, n))\n    assert all(p in primes for f in factors for p in f), \"all factors must be prime\"\n    nums = {p * q * r for p, q, r in factors}\n    return max(nums) < 1000 and len(nums) == 247", "input": "def sat(factors: List[List[int]]):\n    primes = set(range(2, 1000))\n    for n in range(2, 1000):\n        if n in primes:\n            primes.difference_update(range(2 * n, 1000, n))\n    assert all(p in primes for f in factors for p in f), \"all factors must be prime\"\n    nums = {p * q * r for p, q, r in factors}\n    return max(nums) < 1000 and len(nums) == 247", "target": ""}
{"module": "human_eval.py", "name": "IntegerLog:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#76", "sol_bodies": ["    m = 1\n    x = 0\n    while m != n:\n        x += 1\n        m *= a\n    return x"], "sol_header": "def sol(a=3, n=1290070078170102666248196035845070394933441741644993085810116441344597492642263849):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer exponent x such that a^x = n\n    Sample Input:\n    a=2, n=1024\n\n    Sample Output:\n    x = 10\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=3, n=1290070078170102666248196035845070394933441741644993085810116441344597492642263849):\n    return a ** x == n", "input": "def sat(x: int, a=3, n=1290070078170102666248196035845070394933441741644993085810116441344597492642263849):\n    return a ** x == n", "target": ""}
{"module": "human_eval.py", "name": "IntegerLog:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#76", "sol_bodies": ["    m = 1\n    x = 0\n    while m != n:\n        x += 1\n        m *= a\n    return x"], "sol_header": "def sol(a=4, n=49947976805055875702105555676690660891977570282639538413746511354005947821116249921924897649015871538557230897942505966327167610868612564900642816):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer exponent x such that a^x = n\n    Sample Input:\n    a=2, n=1024\n\n    Sample Output:\n    x = 10\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=4, n=49947976805055875702105555676690660891977570282639538413746511354005947821116249921924897649015871538557230897942505966327167610868612564900642816):\n    return a ** x == n", "input": "def sat(x: int, a=4, n=49947976805055875702105555676690660891977570282639538413746511354005947821116249921924897649015871538557230897942505966327167610868612564900642816):\n    return a ** x == n", "target": ""}
{"module": "human_eval.py", "name": "IntegerLog:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#76", "sol_bodies": ["    m = 1\n    x = 0\n    while m != n:\n        x += 1\n        m *= a\n    return x"], "sol_header": "def sol(a=2, n=4611686018427387904):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer exponent x such that a^x = n\n    Sample Input:\n    a=2, n=1024\n\n    Sample Output:\n    x = 10\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=2, n=4611686018427387904):\n    return a ** x == n", "input": "def sat(x: int, a=2, n=4611686018427387904):\n    return a ** x == n", "target": ""}
{"module": "human_eval.py", "name": "IntegerLog:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#76", "sol_bodies": ["    m = 1\n    x = 0\n    while m != n:\n        x += 1\n        m *= a\n    return x"], "sol_header": "def sol(a=7, n=619664992585427611791050679609026893099690427802915014534984716820652776102999166869953170315965558474401):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer exponent x such that a^x = n\n    Sample Input:\n    a=2, n=1024\n\n    Sample Output:\n    x = 10\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=7, n=619664992585427611791050679609026893099690427802915014534984716820652776102999166869953170315965558474401):\n    return a ** x == n", "input": "def sat(x: int, a=7, n=619664992585427611791050679609026893099690427802915014534984716820652776102999166869953170315965558474401):\n    return a ** x == n", "target": ""}
{"module": "human_eval.py", "name": "IntegerLog:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#76", "sol_bodies": ["    m = 1\n    x = 0\n    while m != n:\n        x += 1\n        m *= a\n    return x"], "sol_header": "def sol(a=3, n=273892744995340833777347939263771534786080723599733441):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer exponent x such that a^x = n\n    Sample Input:\n    a=2, n=1024\n\n    Sample Output:\n    x = 10\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=3, n=273892744995340833777347939263771534786080723599733441):\n    return a ** x == n", "input": "def sat(x: int, a=3, n=273892744995340833777347939263771534786080723599733441):\n    return a ** x == n", "target": ""}
{"module": "human_eval.py", "name": "CubeRoot:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#77\n\nWe made it harder by giving very large n for which `round(n ** (1/3))`", "sol_bodies": ["    # Using Newton's method\n    m = abs(n)\n    x = round(abs(n) ** (1 / 3))\n    while x ** 3 != m:\n        x += (m - x ** 3) // (3 * x ** 2)\n    return -x if n < 0 else x"], "sol_header": "def sol(n=42714774173606970182754018064350848294149432972747296768):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer that when cubed is n\n\n    Sample Input:\n    21\n\n    Sample Output:\n    3\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, n=42714774173606970182754018064350848294149432972747296768):\n    return x ** 3 == n", "input": "def sat(x: int, n=42714774173606970182754018064350848294149432972747296768):\n    return x ** 3 == n", "target": ""}
{"module": "human_eval.py", "name": "CubeRoot:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#77\n\nWe made it harder by giving very large n for which `round(n ** (1/3))`", "sol_bodies": ["    # Using Newton's method\n    m = abs(n)\n    x = round(abs(n) ** (1 / 3))\n    while x ** 3 != m:\n        x += (m - x ** 3) // (3 * x ** 2)\n    return -x if n < 0 else x"], "sol_header": "def sol(n=-469541313747981125):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer that when cubed is n\n\n    Sample Input:\n    21\n\n    Sample Output:\n    3\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, n=-469541313747981125):\n    return x ** 3 == n", "input": "def sat(x: int, n=-469541313747981125):\n    return x ** 3 == n", "target": ""}
{"module": "human_eval.py", "name": "CubeRoot:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#77\n\nWe made it harder by giving very large n for which `round(n ** (1/3))`", "sol_bodies": ["    # Using Newton's method\n    m = abs(n)\n    x = round(abs(n) ** (1 / 3))\n    while x ** 3 != m:\n        x += (m - x ** 3) // (3 * x ** 2)\n    return -x if n < 0 else x"], "sol_header": "def sol(n=963966660871383014273727008911874274513660721639801945125024924885086622296):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer that when cubed is n\n\n    Sample Input:\n    21\n\n    Sample Output:\n    3\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, n=963966660871383014273727008911874274513660721639801945125024924885086622296):\n    return x ** 3 == n", "input": "def sat(x: int, n=963966660871383014273727008911874274513660721639801945125024924885086622296):\n    return x ** 3 == n", "target": ""}
{"module": "human_eval.py", "name": "CubeRoot:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#77\n\nWe made it harder by giving very large n for which `round(n ** (1/3))`", "sol_bodies": ["    # Using Newton's method\n    m = abs(n)\n    x = round(abs(n) ** (1 / 3))\n    while x ** 3 != m:\n        x += (m - x ** 3) // (3 * x ** 2)\n    return -x if n < 0 else x"], "sol_header": "def sol(n=-858580967744947820888627092732831059532555665642825043140896515384975483968):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer that when cubed is n\n\n    Sample Input:\n    21\n\n    Sample Output:\n    3\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, n=-858580967744947820888627092732831059532555665642825043140896515384975483968):\n    return x ** 3 == n", "input": "def sat(x: int, n=-858580967744947820888627092732831059532555665642825043140896515384975483968):\n    return x ** 3 == n", "target": ""}
{"module": "human_eval.py", "name": "CubeRoot:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#77\n\nWe made it harder by giving very large n for which `round(n ** (1/3))`", "sol_bodies": ["    # Using Newton's method\n    m = abs(n)\n    x = round(abs(n) ** (1 / 3))\n    while x ** 3 != m:\n        x += (m - x ** 3) // (3 * x ** 2)\n    return -x if n < 0 else x"], "sol_header": "def sol(n=-1649412660748961726580117293638546881248424191676176072):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer that when cubed is n\n\n    Sample Input:\n    21\n\n    Sample Output:\n    3\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, n=-1649412660748961726580117293638546881248424191676176072):\n    return x ** 3 == n", "input": "def sat(x: int, n=-1649412660748961726580117293638546881248424191676176072):\n    return x ** 3 == n", "target": ""}
{"module": "human_eval.py", "name": "HexPrimes:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#78", "sol_bodies": ["    return [c in \"2357BD\" for c in n]"], "sol_header": "def sol(n=\"A4D4455214122CE192CCBE3\"):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine which characters of a hexidecimal correspond to prime numbers\n\n    Sample Input:\n    \"123ABCD\"\n\n    Sample Output:\n    [False, True, True, False, True, False True]\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: List[bool], n=\"A4D4455214122CE192CCBE3\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))", "input": "def sat(primes: List[bool], n=\"A4D4455214122CE192CCBE3\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))", "target": ""}
{"module": "human_eval.py", "name": "HexPrimes:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#78", "sol_bodies": ["    return [c in \"2357BD\" for c in n]"], "sol_header": "def sol(n=\"a0eebda812c4c27a97d35f1\"):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine which characters of a hexidecimal correspond to prime numbers\n\n    Sample Input:\n    \"123ABCD\"\n\n    Sample Output:\n    [False, True, True, False, True, False True]\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: List[bool], n=\"a0eebda812c4c27a97d35f1\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))", "input": "def sat(primes: List[bool], n=\"a0eebda812c4c27a97d35f1\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))", "target": ""}
{"module": "human_eval.py", "name": "HexPrimes:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#78", "sol_bodies": ["    return [c in \"2357BD\" for c in n]"], "sol_header": "def sol(n=\"4a4a5904aaa94eb2\"):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine which characters of a hexidecimal correspond to prime numbers\n\n    Sample Input:\n    \"123ABCD\"\n\n    Sample Output:\n    [False, True, True, False, True, False True]\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: List[bool], n=\"4a4a5904aaa94eb2\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))", "input": "def sat(primes: List[bool], n=\"4a4a5904aaa94eb2\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))", "target": ""}
{"module": "human_eval.py", "name": "HexPrimes:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#78", "sol_bodies": ["    return [c in \"2357BD\" for c in n]"], "sol_header": "def sol(n=\"b696e7352d58ee\"):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine which characters of a hexidecimal correspond to prime numbers\n\n    Sample Input:\n    \"123ABCD\"\n\n    Sample Output:\n    [False, True, True, False, True, False True]\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: List[bool], n=\"b696e7352d58ee\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))", "input": "def sat(primes: List[bool], n=\"b696e7352d58ee\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))", "target": ""}
{"module": "human_eval.py", "name": "HexPrimes:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#78", "sol_bodies": ["    return [c in \"2357BD\" for c in n]"], "sol_header": "def sol(n=\"1a8dcd03abe2cdc\"):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine which characters of a hexidecimal correspond to prime numbers\n\n    Sample Input:\n    \"123ABCD\"\n\n    Sample Output:\n    [False, True, True, False, True, False True]\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: List[bool], n=\"1a8dcd03abe2cdc\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))", "input": "def sat(primes: List[bool], n=\"1a8dcd03abe2cdc\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))", "target": ""}
{"module": "human_eval.py", "name": "Binarize:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#79", "sol_bodies": ["    s = bin(n)[2:]\n    return f'bits{s}bits'"], "sol_header": "def sol(n=5324680297138495285):", "ans_type": "str", "sol_docstring": "    \"\"\"Write n base 2 followed and preceded by 'bits'\n    Sample Input:\n    2\n\n    Sample Output:\n    bits10bits\n    \"\"\"", "weight": 1.0, "sat": "def sat(b: str, n=5324680297138495285):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n", "input": "def sat(b: str, n=5324680297138495285):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n", "target": ""}
{"module": "human_eval.py", "name": "Binarize:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#79", "sol_bodies": ["    s = bin(n)[2:]\n    return f'bits{s}bits'"], "sol_header": "def sol(n=88465169532890):", "ans_type": "str", "sol_docstring": "    \"\"\"Write n base 2 followed and preceded by 'bits'\n    Sample Input:\n    2\n\n    Sample Output:\n    bits10bits\n    \"\"\"", "weight": 1.0, "sat": "def sat(b: str, n=88465169532890):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n", "input": "def sat(b: str, n=88465169532890):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n", "target": ""}
{"module": "human_eval.py", "name": "Binarize:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#79", "sol_bodies": ["    s = bin(n)[2:]\n    return f'bits{s}bits'"], "sol_header": "def sol(n=0):", "ans_type": "str", "sol_docstring": "    \"\"\"Write n base 2 followed and preceded by 'bits'\n    Sample Input:\n    2\n\n    Sample Output:\n    bits10bits\n    \"\"\"", "weight": 1.0, "sat": "def sat(b: str, n=0):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n", "input": "def sat(b: str, n=0):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n", "target": ""}
{"module": "human_eval.py", "name": "Binarize:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#79", "sol_bodies": ["    s = bin(n)[2:]\n    return f'bits{s}bits'"], "sol_header": "def sol(n=16655679678386282):", "ans_type": "str", "sol_docstring": "    \"\"\"Write n base 2 followed and preceded by 'bits'\n    Sample Input:\n    2\n\n    Sample Output:\n    bits10bits\n    \"\"\"", "weight": 1.0, "sat": "def sat(b: str, n=16655679678386282):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n", "input": "def sat(b: str, n=16655679678386282):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n", "target": ""}
{"module": "human_eval.py", "name": "Binarize:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#79", "sol_bodies": ["    s = bin(n)[2:]\n    return f'bits{s}bits'"], "sol_header": "def sol(n=2900):", "ans_type": "str", "sol_docstring": "    \"\"\"Write n base 2 followed and preceded by 'bits'\n    Sample Input:\n    2\n\n    Sample Output:\n    bits10bits\n    \"\"\"", "weight": 1.0, "sat": "def sat(b: str, n=2900):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n", "input": "def sat(b: str, n=2900):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n", "target": ""}
{"module": "human_eval.py", "name": "NearbyDuplicates:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#80", "sol_bodies": ["    for i in range(len(s) - 2):\n        if s[i] == s[i + 1]:\n            return [i, i + 1]\n        if s[i] == s[i + 2]:\n            return [i, i + 2]"], "sol_header": "def sol(s=\"I am an unhappy string!\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.\n    Sample Input:\n    \"street\"\n\n    Sample Output:\n    [3, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[int], s=\"I am an unhappy string!\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3", "input": "def sat(indices: List[int], s=\"I am an unhappy string!\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3", "target": ""}
{"module": "human_eval.py", "name": "NearbyDuplicates:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#80", "sol_bodies": ["    for i in range(len(s) - 2):\n        if s[i] == s[i + 1]:\n            return [i, i + 1]\n        if s[i] == s[i + 2]:\n            return [i, i + 2]"], "sol_header": "def sol(s=\"aeEm%%uIV0imR&xUvQvZf#1z4\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.\n    Sample Input:\n    \"street\"\n\n    Sample Output:\n    [3, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[int], s=\"aeEm%%uIV0imR&xUvQvZf#1z4\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3", "input": "def sat(indices: List[int], s=\"aeEm%%uIV0imR&xUvQvZf#1z4\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3", "target": ""}
{"module": "human_eval.py", "name": "NearbyDuplicates:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#80", "sol_bodies": ["    for i in range(len(s) - 2):\n        if s[i] == s[i + 1]:\n            return [i, i + 1]\n        if s[i] == s[i + 2]:\n            return [i, i + 2]"], "sol_header": "def sol(s=\"e&S|C;;b1Nf[mmsQrQY\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.\n    Sample Input:\n    \"street\"\n\n    Sample Output:\n    [3, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[int], s=\"e&S|C;;b1Nf[mmsQrQY\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3", "input": "def sat(indices: List[int], s=\"e&S|C;;b1Nf[mmsQrQY\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3", "target": ""}
{"module": "human_eval.py", "name": "NearbyDuplicates:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#80", "sol_bodies": ["    for i in range(len(s) - 2):\n        if s[i] == s[i + 1]:\n            return [i, i + 1]\n        if s[i] == s[i + 2]:\n            return [i, i + 2]"], "sol_header": "def sol(s=\"?EaEc/oDAm(i gP\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.\n    Sample Input:\n    \"street\"\n\n    Sample Output:\n    [3, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[int], s=\"?EaEc/oDAm(i gP\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3", "input": "def sat(indices: List[int], s=\"?EaEc/oDAm(i gP\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3", "target": ""}
{"module": "human_eval.py", "name": "NearbyDuplicates:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#80", "sol_bodies": ["    for i in range(len(s) - 2):\n        if s[i] == s[i + 1]:\n            return [i, i + 1]\n        if s[i] == s[i + 2]:\n            return [i, i + 2]"], "sol_header": "def sol(s=\"pXw|EEcTKZ;:n[-tBME[[sn%fR37l;bM,t%!\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.\n    Sample Input:\n    \"street\"\n\n    Sample Output:\n    [3, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[int], s=\"pXw|EEcTKZ;:n[-tBME[[sn%fR37l;bM,t%!\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3", "input": "def sat(indices: List[int], s=\"pXw|EEcTKZ;:n[-tBME[[sn%fR37l;bM,t%!\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3", "target": ""}
{"module": "human_eval.py", "name": "Grader:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#81", "sol_bodies": ["    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    ans = []\n    for gpa in gpas:\n        i = 0\n        while gpa < scores[i]:\n            i += 1\n        ans.append(letters[i])\n    return ans"], "sol_header": "def sol(gpas=[2.8, 3.1, 4.0, 2.2, 3.1, 2.5, 0.9]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Convert GPAs to letter grades according to the following table:\n    4.0: A+\n    3.7: A\n    3.4: A-\n    3.0: B+\n    2.7: B\n    2.4: B-\n    2.0: C+\n    1.7: C\n    1.4: C-\n    below: F\n\n    Sample input: [4.0, 3.5, 3.8]\n    Sample output: ['A+', 'A-', 'A']\n    \"\"\"", "weight": 1.0, "sat": "def sat(grades: List[str], gpas=[2.8, 3.1, 4.0, 2.2, 3.1, 2.5, 0.9]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True", "input": "def sat(grades: List[str], gpas=[2.8, 3.1, 4.0, 2.2, 3.1, 2.5, 0.9]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True", "target": ""}
{"module": "human_eval.py", "name": "Grader:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#81", "sol_bodies": ["    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    ans = []\n    for gpa in gpas:\n        i = 0\n        while gpa < scores[i]:\n            i += 1\n        ans.append(letters[i])\n    return ans"], "sol_header": "def sol(gpas=[3.9759656717898215, 2.532507032264099, 3.695549189812313, 2.492545757546573, 0.9653857771911838, 1.619680869536884]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Convert GPAs to letter grades according to the following table:\n    4.0: A+\n    3.7: A\n    3.4: A-\n    3.0: B+\n    2.7: B\n    2.4: B-\n    2.0: C+\n    1.7: C\n    1.4: C-\n    below: F\n\n    Sample input: [4.0, 3.5, 3.8]\n    Sample output: ['A+', 'A-', 'A']\n    \"\"\"", "weight": 1.0, "sat": "def sat(grades: List[str], gpas=[3.9759656717898215, 2.532507032264099, 3.695549189812313, 2.492545757546573, 0.9653857771911838, 1.619680869536884]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True", "input": "def sat(grades: List[str], gpas=[3.9759656717898215, 2.532507032264099, 3.695549189812313, 2.492545757546573, 0.9653857771911838, 1.619680869536884]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True", "target": ""}
{"module": "human_eval.py", "name": "Grader:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#81", "sol_bodies": ["    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    ans = []\n    for gpa in gpas:\n        i = 0\n        while gpa < scores[i]:\n            i += 1\n        ans.append(letters[i])\n    return ans"], "sol_header": "def sol(gpas=[1.0670062946539565]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Convert GPAs to letter grades according to the following table:\n    4.0: A+\n    3.7: A\n    3.4: A-\n    3.0: B+\n    2.7: B\n    2.4: B-\n    2.0: C+\n    1.7: C\n    1.4: C-\n    below: F\n\n    Sample input: [4.0, 3.5, 3.8]\n    Sample output: ['A+', 'A-', 'A']\n    \"\"\"", "weight": 1.0, "sat": "def sat(grades: List[str], gpas=[1.0670062946539565]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True", "input": "def sat(grades: List[str], gpas=[1.0670062946539565]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True", "target": ""}
{"module": "human_eval.py", "name": "Grader:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#81", "sol_bodies": ["    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    ans = []\n    for gpa in gpas:\n        i = 0\n        while gpa < scores[i]:\n            i += 1\n        ans.append(letters[i])\n    return ans"], "sol_header": "def sol(gpas=[]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Convert GPAs to letter grades according to the following table:\n    4.0: A+\n    3.7: A\n    3.4: A-\n    3.0: B+\n    2.7: B\n    2.4: B-\n    2.0: C+\n    1.7: C\n    1.4: C-\n    below: F\n\n    Sample input: [4.0, 3.5, 3.8]\n    Sample output: ['A+', 'A-', 'A']\n    \"\"\"", "weight": 1.0, "sat": "def sat(grades: List[str], gpas=[]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True", "input": "def sat(grades: List[str], gpas=[]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True", "target": ""}
{"module": "human_eval.py", "name": "Grader:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#81", "sol_bodies": ["    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    ans = []\n    for gpa in gpas:\n        i = 0\n        while gpa < scores[i]:\n            i += 1\n        ans.append(letters[i])\n    return ans"], "sol_header": "def sol(gpas=[2.7731700871871414, 0.5127907383392896]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Convert GPAs to letter grades according to the following table:\n    4.0: A+\n    3.7: A\n    3.4: A-\n    3.0: B+\n    2.7: B\n    2.4: B-\n    2.0: C+\n    1.7: C\n    1.4: C-\n    below: F\n\n    Sample input: [4.0, 3.5, 3.8]\n    Sample output: ['A+', 'A-', 'A']\n    \"\"\"", "weight": 1.0, "sat": "def sat(grades: List[str], gpas=[2.7731700871871414, 0.5127907383392896]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True", "input": "def sat(grades: List[str], gpas=[2.7731700871871414, 0.5127907383392896]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FactorString:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#82", "sol_bodies": ["    n = len(s)\n    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))"], "sol_header": "def sol(s=\"catscatcatscatcatscat\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string which when repeated more than once gives s\n    Sample Input:\n    \"haha\"\n\n    Sample Output:\n    \"ha\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(factor: str, s=\"catscatcatscatcatscat\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))", "input": "def sat(factor: str, s=\"catscatcatscatcatscat\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))", "target": ""}
{"module": "human_eval.py", "name": "FactorString:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#82", "sol_bodies": ["    n = len(s)\n    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))"], "sol_header": "def sol(s=\"pamithelozefefitextpamithelozefefitext\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string which when repeated more than once gives s\n    Sample Input:\n    \"haha\"\n\n    Sample Output:\n    \"ha\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(factor: str, s=\"pamithelozefefitextpamithelozefefitext\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))", "input": "def sat(factor: str, s=\"pamithelozefefitextpamithelozefefitext\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))", "target": ""}
{"module": "human_eval.py", "name": "FactorString:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#82", "sol_bodies": ["    n = len(s)\n    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))"], "sol_header": "def sol(s=\"mahermahermahermahermahermahermahermaher\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string which when repeated more than once gives s\n    Sample Input:\n    \"haha\"\n\n    Sample Output:\n    \"ha\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(factor: str, s=\"mahermahermahermahermahermahermahermaher\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))", "input": "def sat(factor: str, s=\"mahermahermahermahermahermahermahermaher\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))", "target": ""}
{"module": "human_eval.py", "name": "FactorString:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#82", "sol_bodies": ["    n = len(s)\n    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))"], "sol_header": "def sol(s=\"mapychysmapychysmapychysmapychysmapychysmapychys\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string which when repeated more than once gives s\n    Sample Input:\n    \"haha\"\n\n    Sample Output:\n    \"ha\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(factor: str, s=\"mapychysmapychysmapychysmapychysmapychysmapychys\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))", "input": "def sat(factor: str, s=\"mapychysmapychysmapychysmapychysmapychysmapychys\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))", "target": ""}
{"module": "human_eval.py", "name": "FactorString:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#82", "sol_bodies": ["    n = len(s)\n    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))"], "sol_header": "def sol(s=\"thihathihathihathihathihathiha\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string which when repeated more than once gives s\n    Sample Input:\n    \"haha\"\n\n    Sample Output:\n    \"ha\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(factor: str, s=\"thihathihathihathihathihathiha\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))", "input": "def sat(factor: str, s=\"thihathihathihathihathihathiha\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))", "target": ""}
{"module": "human_eval.py", "name": "OneEnded:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#83", "sol_bodies": ["    ans = []\n    for i in range(10 ** (n - 1), 10 ** n):\n        assert len(str(i)) == n\n        if str(i).startswith(\"1\") or str(i).endswith(\"1\"):\n            ans.append(i)\n    return ans"], "sol_header": "def sol(n=5):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all n-digit integers that start or end with 1\n\n    1 => [1]\"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], n=5):\n    count = 18 * (10 ** (n - 2)) if n > 1 else 1\n    strs = {str(n) for n in nums}\n    return len(strs) == count and all(s.startswith(\"1\") or s.endswith(\"1\") and len(s) == n for s in strs)", "input": "def sat(nums: List[int], n=5):\n    count = 18 * (10 ** (n - 2)) if n > 1 else 1\n    strs = {str(n) for n in nums}\n    return len(strs) == count and all(s.startswith(\"1\") or s.endswith(\"1\") and len(s) == n for s in strs)", "target": ""}
{"module": "human_eval.py", "name": "BitSum:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#84", "sol_bodies": ["    return int(\"1\" * s + \"0\" * (b - s), 2)"], "sol_header": "def sol(b=107, s=25):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an b-bit integer with a bit-sum of s\n\n    b=3, s=2 => 5 # 5 is 101 in binary\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, b=107, s=25):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s", "input": "def sat(n: int, b=107, s=25):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s", "target": ""}
{"module": "human_eval.py", "name": "BitSum:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#84", "sol_bodies": ["    return int(\"1\" * s + \"0\" * (b - s), 2)"], "sol_header": "def sol(b=59, s=51):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an b-bit integer with a bit-sum of s\n\n    b=3, s=2 => 5 # 5 is 101 in binary\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, b=59, s=51):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s", "input": "def sat(n: int, b=59, s=51):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s", "target": ""}
{"module": "human_eval.py", "name": "BitSum:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#84", "sol_bodies": ["    return int(\"1\" * s + \"0\" * (b - s), 2)"], "sol_header": "def sol(b=825, s=653):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an b-bit integer with a bit-sum of s\n\n    b=3, s=2 => 5 # 5 is 101 in binary\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, b=825, s=653):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s", "input": "def sat(n: int, b=825, s=653):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s", "target": ""}
{"module": "human_eval.py", "name": "BitSum:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#84", "sol_bodies": ["    return int(\"1\" * s + \"0\" * (b - s), 2)"], "sol_header": "def sol(b=354, s=287):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an b-bit integer with a bit-sum of s\n\n    b=3, s=2 => 5 # 5 is 101 in binary\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, b=354, s=287):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s", "input": "def sat(n: int, b=354, s=287):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s", "target": ""}
{"module": "human_eval.py", "name": "BitSum:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#84", "sol_bodies": ["    return int(\"1\" * s + \"0\" * (b - s), 2)"], "sol_header": "def sol(b=256, s=1):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an b-bit integer with a bit-sum of s\n\n    b=3, s=2 => 5 # 5 is 101 in binary\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, b=256, s=1):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s", "input": "def sat(n: int, b=256, s=1):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s", "target": ""}
{"module": "human_eval.py", "name": "EvenOddSum:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#85\n\nVery similar to OddEvenSum \\#121", "sol_bodies": ["    return sum(i for i in nums[1::2] if i % 2 == 0)"], "sol_header": "def sol(nums=[2341, 125146894, 12521, -12451293476325, 535284623934, 132974693614350]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the even elements that are at odd indices\n\n    [1, 2, 8, 3, 9, 4] => 6\n    \"\"\"", "weight": 1.0, "sat": "def sat(even_odd_sum: int, nums=[2341, 125146894, 12521, -12451293476325, 535284623934, 132974693614350]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0", "input": "def sat(even_odd_sum: int, nums=[2341, 125146894, 12521, -12451293476325, 535284623934, 132974693614350]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0", "target": ""}
{"module": "human_eval.py", "name": "EvenOddSum:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#85\n\nVery similar to OddEvenSum \\#121", "sol_bodies": ["    return sum(i for i in nums[1::2] if i % 2 == 0)"], "sol_header": "def sol(nums=[63, 11, -95, 69, 73, -43, 69, -26, -49, 36, 83, 21, -26, 11]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the even elements that are at odd indices\n\n    [1, 2, 8, 3, 9, 4] => 6\n    \"\"\"", "weight": 1.0, "sat": "def sat(even_odd_sum: int, nums=[63, 11, -95, 69, 73, -43, 69, -26, -49, 36, 83, 21, -26, 11]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0", "input": "def sat(even_odd_sum: int, nums=[63, 11, -95, 69, 73, -43, 69, -26, -49, 36, 83, 21, -26, 11]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0", "target": ""}
{"module": "human_eval.py", "name": "EvenOddSum:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#85\n\nVery similar to OddEvenSum \\#121", "sol_bodies": ["    return sum(i for i in nums[1::2] if i % 2 == 0)"], "sol_header": "def sol(nums=[29, -100, 94, -10, -97, -70, 86, 69, -61, 44, 48, -12, 92]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the even elements that are at odd indices\n\n    [1, 2, 8, 3, 9, 4] => 6\n    \"\"\"", "weight": 1.0, "sat": "def sat(even_odd_sum: int, nums=[29, -100, 94, -10, -97, -70, 86, 69, -61, 44, 48, -12, 92]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0", "input": "def sat(even_odd_sum: int, nums=[29, -100, 94, -10, -97, -70, 86, 69, -61, 44, 48, -12, 92]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0", "target": ""}
{"module": "human_eval.py", "name": "EvenOddSum:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#85\n\nVery similar to OddEvenSum \\#121", "sol_bodies": ["    return sum(i for i in nums[1::2] if i % 2 == 0)"], "sol_header": "def sol(nums=[-75, -2, 68, 36, -4, 58, -42, -92, 28, 59, -66, 52]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the even elements that are at odd indices\n\n    [1, 2, 8, 3, 9, 4] => 6\n    \"\"\"", "weight": 1.0, "sat": "def sat(even_odd_sum: int, nums=[-75, -2, 68, 36, -4, 58, -42, -92, 28, 59, -66, 52]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0", "input": "def sat(even_odd_sum: int, nums=[-75, -2, 68, 36, -4, 58, -42, -92, 28, 59, -66, 52]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0", "target": ""}
{"module": "human_eval.py", "name": "EvenOddSum:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#85\n\nVery similar to OddEvenSum \\#121", "sol_bodies": ["    return sum(i for i in nums[1::2] if i % 2 == 0)"], "sol_header": "def sol(nums=[48, -42, -19, -82, -71, -57, -85, 61, 61, -86]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the even elements that are at odd indices\n\n    [1, 2, 8, 3, 9, 4] => 6\n    \"\"\"", "weight": 1.0, "sat": "def sat(even_odd_sum: int, nums=[48, -42, -19, -82, -71, -57, -85, 61, 61, -86]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0", "input": "def sat(even_odd_sum: int, nums=[48, -42, -19, -82, -71, -57, -85, 61, 61, -86]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0", "target": ""}
{"module": "human_eval.py", "name": "AntiShuffle:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#86", "sol_bodies": ["    return \" \".join(\"\".join(sorted(w)) for w in orig.split(' '))"], "sol_header": "def sol(orig=\"Hello world!!!\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Create a new string by taking s, and word by word rearranging its characters in ascii order\n    Sample input:\n    'maltos wow'\n\n    Sample output:\n    'almost oww'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, orig=\"Hello world!!!\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)", "input": "def sat(s: str, orig=\"Hello world!!!\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)", "target": ""}
{"module": "human_eval.py", "name": "AntiShuffle:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#86", "sol_bodies": ["    return \" \".join(\"\".join(sorted(w)) for w in orig.split(' '))"], "sol_header": "def sol(orig=\"YOU CAN rearrange my letters, yes you can!\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Create a new string by taking s, and word by word rearranging its characters in ascii order\n    Sample input:\n    'maltos wow'\n\n    Sample output:\n    'almost oww'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, orig=\"YOU CAN rearrange my letters, yes you can!\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)", "input": "def sat(s: str, orig=\"YOU CAN rearrange my letters, yes you can!\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)", "target": ""}
{"module": "human_eval.py", "name": "AntiShuffle:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#86", "sol_bodies": ["    return \" \".join(\"\".join(sorted(w)) for w in orig.split(' '))"], "sol_header": "def sol(orig=\"caN you handlE LONGGGGGGGGGGGG strings?\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Create a new string by taking s, and word by word rearranging its characters in ascii order\n    Sample input:\n    'maltos wow'\n\n    Sample output:\n    'almost oww'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, orig=\"caN you handlE LONGGGGGGGGGGGG strings?\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)", "input": "def sat(s: str, orig=\"caN you handlE LONGGGGGGGGGGGG strings?\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)", "target": ""}
{"module": "human_eval.py", "name": "AntiShuffle:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#86", "sol_bodies": ["    return \" \".join(\"\".join(sorted(w)) for w in orig.split(' '))"], "sol_header": "def sol(orig=\"how bout    spaces and weird punctuation!?$%@#%\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Create a new string by taking s, and word by word rearranging its characters in ascii order\n    Sample input:\n    'maltos wow'\n\n    Sample output:\n    'almost oww'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, orig=\"how bout    spaces and weird punctuation!?$%@#%\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)", "input": "def sat(s: str, orig=\"how bout    spaces and weird punctuation!?$%@#%\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)", "target": ""}
{"module": "human_eval.py", "name": "AntiShuffle:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#86", "sol_bodies": ["    return \" \".join(\"\".join(sorted(w)) for w in orig.split(' '))"], "sol_header": "def sol(orig=\"ruhixuthuciji kebelobawitextythuch quozo\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Create a new string by taking s, and word by word rearranging its characters in ascii order\n    Sample input:\n    'maltos wow'\n\n    Sample output:\n    'almost oww'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, orig=\"ruhixuthuciji kebelobawitextythuch quozo\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)", "input": "def sat(s: str, orig=\"ruhixuthuciji kebelobawitextythuch quozo\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)", "target": ""}
{"module": "human_eval.py", "name": "UnevenFind:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#87", "sol_bodies": ["    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]"], "sol_header": "def sol(uneven=[[1, 3, 2, 32, 17], [17, 2, 48, 17], [], [9, 35, 4], [3, 17]], target=17):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find the indices of all occurrences of target in the uneven matrix\n    Sample input:\n    uneven=[[2, 3, 2], [], [9, 2]], target=2\n\n    Sample output:\n    [[0, 0], [0, 2], [2, 1]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[List[int]], uneven=[[1, 3, 2, 32, 17], [17, 2, 48, 17], [], [9, 35, 4], [3, 17]], target=17):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True", "input": "def sat(indices: List[List[int]], uneven=[[1, 3, 2, 32, 17], [17, 2, 48, 17], [], [9, 35, 4], [3, 17]], target=17):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True", "target": ""}
{"module": "human_eval.py", "name": "UnevenFind:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#87", "sol_bodies": ["    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]"], "sol_header": "def sol(uneven=[[64, 7, 64, 64, 20], [72, 64, 22, 64, 64], [21, 35], [64, 0, 96, 27]], target=64):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find the indices of all occurrences of target in the uneven matrix\n    Sample input:\n    uneven=[[2, 3, 2], [], [9, 2]], target=2\n\n    Sample output:\n    [[0, 0], [0, 2], [2, 1]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[List[int]], uneven=[[64, 7, 64, 64, 20], [72, 64, 22, 64, 64], [21, 35], [64, 0, 96, 27]], target=64):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True", "input": "def sat(indices: List[List[int]], uneven=[[64, 7, 64, 64, 20], [72, 64, 22, 64, 64], [21, 35], [64, 0, 96, 27]], target=64):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True", "target": ""}
{"module": "human_eval.py", "name": "UnevenFind:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#87", "sol_bodies": ["    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]"], "sol_header": "def sol(uneven=[[16, 87]], target=87):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find the indices of all occurrences of target in the uneven matrix\n    Sample input:\n    uneven=[[2, 3, 2], [], [9, 2]], target=2\n\n    Sample output:\n    [[0, 0], [0, 2], [2, 1]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[List[int]], uneven=[[16, 87]], target=87):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True", "input": "def sat(indices: List[List[int]], uneven=[[16, 87]], target=87):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True", "target": ""}
{"module": "human_eval.py", "name": "UnevenFind:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#87", "sol_bodies": ["    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]"], "sol_header": "def sol(uneven=[], target=30):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find the indices of all occurrences of target in the uneven matrix\n    Sample input:\n    uneven=[[2, 3, 2], [], [9, 2]], target=2\n\n    Sample output:\n    [[0, 0], [0, 2], [2, 1]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[List[int]], uneven=[], target=30):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True", "input": "def sat(indices: List[List[int]], uneven=[], target=30):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True", "target": ""}
{"module": "human_eval.py", "name": "UnevenFind:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#87", "sol_bodies": ["    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]"], "sol_header": "def sol(uneven=[[5, 30, 18], [53, 64, 87, 69, 64, 64, 64], [], [44], [64, 88, 68, 64, 64, 84, 64, 64, 64], [31], [64, 5, 64, 71, 42, 64, 48, 64, 27], [64, 80, 11, 64]], target=64):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find the indices of all occurrences of target in the uneven matrix\n    Sample input:\n    uneven=[[2, 3, 2], [], [9, 2]], target=2\n\n    Sample output:\n    [[0, 0], [0, 2], [2, 1]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[List[int]], uneven=[[5, 30, 18], [53, 64, 87, 69, 64, 64, 64], [], [44], [64, 88, 68, 64, 64, 84, 64, 64, 64], [31], [64, 5, 64, 71, 42, 64, 48, 64, 27], [64, 80, 11, 64]], target=64):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True", "input": "def sat(indices: List[List[int]], uneven=[[5, 30, 18], [53, 64, 87, 69, 64, 64, 64], [], [44], [64, 88, 68, 64, 64, 84, 64, 64, 64], [31], [64, 5, 64, 71, 42, 64, 48, 64, 27], [64, 80, 11, 64]], target=64):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True", "target": ""}
{"module": "human_eval.py", "name": "UpDownSort:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#88", "sol_bodies": ["    return sorted(nums, reverse=(False if (nums[0] + nums[-1]) % 2 else True))"], "sol_header": "def sol(nums=[17, 2, 3, 523, 18, -2, 0, 2, -1]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Reorder nums in increasing/decreasing order based on whether the first plus last element is even/odd\n\n    Sample input:\n    [1, 7, 4]\n\n    Sample output:\n    [1, 4, 7] # because 1 + 4 is odd\n\n    Sample input:\n    [1, 7, 5]\n\n    Sample output:\n    [8, 5, 1] # because 1 + 5 is even\n    \"\"\"", "weight": 1.0, "sat": "def sat(up_down: List[int], nums=[17, 2, 3, 523, 18, -2, 0, 2, -1]):\n    assert all(up_down.count(i) == nums.count(i) for i in set(up_down + nums)), \"not a reordering\"\n    increasing_sign = 1 if ((nums[0] + nums[-1]) % 2 == 1) else -1\n    return all((up_down[i + 1] - up_down[i]) * increasing_sign >= 0 for i in range(len(up_down) - 1))", "input": "def sat(up_down: List[int], nums=[17, 2, 3, 523, 18, -2, 0, 2, -1]):\n    assert all(up_down.count(i) == nums.count(i) for i in set(up_down + nums)), \"not a reordering\"\n    increasing_sign = 1 if ((nums[0] + nums[-1]) % 2 == 1) else -1\n    return all((up_down[i + 1] - up_down[i]) * increasing_sign >= 0 for i in range(len(up_down) - 1))", "target": ""}
{"module": "human_eval.py", "name": "SubstitutionCypher:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#89", "sol_bodies": ["    return \"\".join(chr(ord(b) + 2 * 2) for b in orig)"], "sol_header": "def sol(orig=\"Hello, world!\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Apply a substitution cypher in which each character is advanced by two multiplied by two places.\n\n    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'\n    \"\"\"", "weight": 1.0, "sat": "def sat(encrypted: str, orig=\"Hello, world!\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))", "input": "def sat(encrypted: str, orig=\"Hello, world!\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))", "target": ""}
{"module": "human_eval.py", "name": "SubstitutionCypher:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#89", "sol_bodies": ["    return \"\".join(chr(ord(b) + 2 * 2) for b in orig)"], "sol_header": "def sol(orig=\"\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Apply a substitution cypher in which each character is advanced by two multiplied by two places.\n\n    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'\n    \"\"\"", "weight": 1.0, "sat": "def sat(encrypted: str, orig=\"\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))", "input": "def sat(encrypted: str, orig=\"\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))", "target": ""}
{"module": "human_eval.py", "name": "SubstitutionCypher:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#89", "sol_bodies": ["    return \"\".join(chr(ord(b) + 2 * 2) for b in orig)"], "sol_header": "def sol(orig=\"byfykovevuvyxanofi lygolono pyzuh t\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Apply a substitution cypher in which each character is advanced by two multiplied by two places.\n\n    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'\n    \"\"\"", "weight": 1.0, "sat": "def sat(encrypted: str, orig=\"byfykovevuvyxanofi lygolono pyzuh t\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))", "input": "def sat(encrypted: str, orig=\"byfykovevuvyxanofi lygolono pyzuh t\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))", "target": ""}
{"module": "human_eval.py", "name": "SubstitutionCypher:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#89", "sol_bodies": ["    return \"\".join(chr(ord(b) + 2 * 2) for b in orig)"], "sol_header": "def sol(orig=\"dogyvotitonucuxecequ jahuzowiz jyna\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Apply a substitution cypher in which each character is advanced by two multiplied by two places.\n\n    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'\n    \"\"\"", "weight": 1.0, "sat": "def sat(encrypted: str, orig=\"dogyvotitonucuxecequ jahuzowiz jyna\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))", "input": "def sat(encrypted: str, orig=\"dogyvotitonucuxecequ jahuzowiz jyna\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))", "target": ""}
{"module": "human_eval.py", "name": "SubstitutionCypher:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#89", "sol_bodies": ["    return \"\".join(chr(ord(b) + 2 * 2) for b in orig)"], "sol_header": "def sol(orig=\"chodatext quycimoquytunek\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Apply a substitution cypher in which each character is advanced by two multiplied by two places.\n\n    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'\n    \"\"\"", "weight": 1.0, "sat": "def sat(encrypted: str, orig=\"chodatext quycimoquytunek\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))", "input": "def sat(encrypted: str, orig=\"chodatext quycimoquytunek\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))", "target": ""}
{"module": "human_eval.py", "name": "SecondSmallestUnique:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#90", "sol_bodies": ["    return sorted(set(nums))[1]"], "sol_header": "def sol(nums=[17, -1023589211, -293485382500, 31, -293485382500, 105762, 94328103589]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the second smallest unique number in the list nums.\n\n    Sample input:\n    [2, 5, 2, 7, 9]\n\n    Sample output:\n    5\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, nums=[17, -1023589211, -293485382500, 31, -293485382500, 105762, 94328103589]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2", "input": "def sat(n: int, nums=[17, -1023589211, -293485382500, 31, -293485382500, 105762, 94328103589]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2", "target": ""}
{"module": "human_eval.py", "name": "SecondSmallestUnique:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#90", "sol_bodies": ["    return sorted(set(nums))[1]"], "sol_header": "def sol(nums=[-3, -4, -3, 8, -9]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the second smallest unique number in the list nums.\n\n    Sample input:\n    [2, 5, 2, 7, 9]\n\n    Sample output:\n    5\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, nums=[-3, -4, -3, 8, -9]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2", "input": "def sat(n: int, nums=[-3, -4, -3, 8, -9]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2", "target": ""}
{"module": "human_eval.py", "name": "SecondSmallestUnique:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#90", "sol_bodies": ["    return sorted(set(nums))[1]"], "sol_header": "def sol(nums=[0, -5, -7, -5, 0, -2, 6, -8]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the second smallest unique number in the list nums.\n\n    Sample input:\n    [2, 5, 2, 7, 9]\n\n    Sample output:\n    5\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, nums=[0, -5, -7, -5, 0, -2, 6, -8]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2", "input": "def sat(n: int, nums=[0, -5, -7, -5, 0, -2, 6, -8]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2", "target": ""}
{"module": "human_eval.py", "name": "SecondSmallestUnique:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#90", "sol_bodies": ["    return sorted(set(nums))[1]"], "sol_header": "def sol(nums=[6, 5]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the second smallest unique number in the list nums.\n\n    Sample input:\n    [2, 5, 2, 7, 9]\n\n    Sample output:\n    5\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, nums=[6, 5]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2", "input": "def sat(n: int, nums=[6, 5]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2", "target": ""}
{"module": "human_eval.py", "name": "SecondSmallestUnique:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#90", "sol_bodies": ["    return sorted(set(nums))[1]"], "sol_header": "def sol(nums=[4, -8, 8, 4]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the second smallest unique number in the list nums.\n\n    Sample input:\n    [2, 5, 2, 7, 9]\n\n    Sample output:\n    5\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, nums=[4, -8, 8, 4]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2", "input": "def sat(n: int, nums=[4, -8, 8, 4]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2", "target": ""}
{"module": "human_eval.py", "name": "FindBored:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#91", "sol_bodies": ["    return [s for s in text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\") if s.split()[:1] == [\"I\"]]"], "sol_header": "def sol(text=\"This is not boring. I am boring! I am sooo tired.\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"A bored sentence starts with the word \"I\". Find all bored sentences in s. Sentence delimiters are '.!?'\n\n    --- Example input ---\n    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'\n\n    --- Example output ---\n    ['I wrote this', ' I think I am so cool']\n\n    \"\"\"", "weight": 1.0, "sat": "def sat(boring: List[str], text=\"This is not boring. I am boring! I am sooo tired.\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)", "input": "def sat(boring: List[str], text=\"This is not boring. I am boring! I am sooo tired.\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)", "target": ""}
{"module": "human_eval.py", "name": "FindBored:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#91", "sol_bodies": ["    return [s for s in text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\") if s.split()[:1] == [\"I\"]]"], "sol_header": "def sol(text=\"dexuzuhyfac lifugerimosiwybot.hesukawycat!hawymemof pa text z.nuquyt weminubadithikanat gejetextipafex vobenekothob.reraxithechaquipapav wexamew lobihus zygijehequesatextacy jucyth?I?I wevymicygequipi cicemyte tha cetexti vuhoxadivelabyduxix?I lanusutho kuzit?nathor sopati myjamygukiwyhuje.I kacuquedewapojedu thulocho?I chezeri.thubitozogukenejugox.cytonoc tex tobaquy wiwithij!vinam rarile sibizytexta notaxithyzu?\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"A bored sentence starts with the word \"I\". Find all bored sentences in s. Sentence delimiters are '.!?'\n\n    --- Example input ---\n    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'\n\n    --- Example output ---\n    ['I wrote this', ' I think I am so cool']\n\n    \"\"\"", "weight": 1.0, "sat": "def sat(boring: List[str], text=\"dexuzuhyfac lifugerimosiwybot.hesukawycat!hawymemof pa text z.nuquyt weminubadithikanat gejetextipafex vobenekothob.reraxithechaquipapav wexamew lobihus zygijehequesatextacy jucyth?I?I wevymicygequipi cicemyte tha cetexti vuhoxadivelabyduxix?I lanusutho kuzit?nathor sopati myjamygukiwyhuje.I kacuquedewapojedu thulocho?I chezeri.thubitozogukenejugox.cytonoc tex tobaquy wiwithij!vinam rarile sibizytexta notaxithyzu?\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)", "input": "def sat(boring: List[str], text=\"dexuzuhyfac lifugerimosiwybot.hesukawycat!hawymemof pa text z.nuquyt weminubadithikanat gejetextipafex vobenekothob.reraxithechaquipapav wexamew lobihus zygijehequesatextacy jucyth?I?I wevymicygequipi cicemyte tha cetexti vuhoxadivelabyduxix?I lanusutho kuzit?nathor sopati myjamygukiwyhuje.I kacuquedewapojedu thulocho?I chezeri.thubitozogukenejugox.cytonoc tex tobaquy wiwithij!vinam rarile sibizytexta notaxithyzu?\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)", "target": ""}
{"module": "human_eval.py", "name": "FindBored:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#91", "sol_bodies": ["    return [s for s in text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\") if s.split()[:1] == [\"I\"]]"], "sol_header": "def sol(text=\"\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"A bored sentence starts with the word \"I\". Find all bored sentences in s. Sentence delimiters are '.!?'\n\n    --- Example input ---\n    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'\n\n    --- Example output ---\n    ['I wrote this', ' I think I am so cool']\n\n    \"\"\"", "weight": 1.0, "sat": "def sat(boring: List[str], text=\"\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)", "input": "def sat(boring: List[str], text=\"\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)", "target": ""}
{"module": "human_eval.py", "name": "FindBored:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#91", "sol_bodies": ["    return [s for s in text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\") if s.split()[:1] == [\"I\"]]"], "sol_header": "def sol(text=\"nysydajywigi vefusivechucirochuw tipeko pogofinifyk.I textovugythecodo ruwatekat dane wachikechanequi matupisofunehac.tubicetofalat colawuhemedexeq lurytext?\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"A bored sentence starts with the word \"I\". Find all bored sentences in s. Sentence delimiters are '.!?'\n\n    --- Example input ---\n    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'\n\n    --- Example output ---\n    ['I wrote this', ' I think I am so cool']\n\n    \"\"\"", "weight": 1.0, "sat": "def sat(boring: List[str], text=\"nysydajywigi vefusivechucirochuw tipeko pogofinifyk.I textovugythecodo ruwatekat dane wachikechanequi matupisofunehac.tubicetofalat colawuhemedexeq lurytext?\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)", "input": "def sat(boring: List[str], text=\"nysydajywigi vefusivechucirochuw tipeko pogofinifyk.I textovugythecodo ruwatekat dane wachikechanequi matupisofunehac.tubicetofalat colawuhemedexeq lurytext?\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)", "target": ""}
{"module": "human_eval.py", "name": "FindBored:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#91", "sol_bodies": ["    return [s for s in text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\") if s.split()[:1] == [\"I\"]]"], "sol_header": "def sol(text=\"?zihithi ch chithe vuluzuquidawyquo.I?I chypufomiwylojen ziwuwygawyfyg makatex?textidigefoc nyjav.I gujyduvafe gykizubam cofurythoc.coc thohifycepy tex kybiwulatextux.\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"A bored sentence starts with the word \"I\". Find all bored sentences in s. Sentence delimiters are '.!?'\n\n    --- Example input ---\n    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'\n\n    --- Example output ---\n    ['I wrote this', ' I think I am so cool']\n\n    \"\"\"", "weight": 1.0, "sat": "def sat(boring: List[str], text=\"?zihithi ch chithe vuluzuquidawyquo.I?I chypufomiwylojen ziwuwygawyfyg makatex?textidigefoc nyjav.I gujyduvafe gykizubam cofurythoc.coc thohifycepy tex kybiwulatextux.\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)", "input": "def sat(boring: List[str], text=\"?zihithi ch chithe vuluzuquidawyquo.I?I chypufomiwylojen ziwuwygawyfyg makatex?textidigefoc nyjav.I gujyduvafe gykizubam cofurythoc.coc thohifycepy tex kybiwulatextux.\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)", "target": ""}
{"module": "human_eval.py", "name": "IdentifyZeroTrips:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#92", "sol_bodies": ["    return [sum(t) == 0 for t in trips]"], "sol_header": "def sol(trips=[[1253532, -3920635, 332], [-24, 18, 6], [0, 5, -5], [1, 1, 1], [-20, 17, 4]]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine which triples sum to zero\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(zero_sums: List[bool], trips=[[1253532, -3920635, 332], [-24, 18, 6], [0, 5, -5], [1, 1, 1], [-20, 17, 4]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))", "input": "def sat(zero_sums: List[bool], trips=[[1253532, -3920635, 332], [-24, 18, 6], [0, 5, -5], [1, 1, 1], [-20, 17, 4]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))", "target": ""}
{"module": "human_eval.py", "name": "IdentifyZeroTrips:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#92", "sol_bodies": ["    return [sum(t) == 0 for t in trips]"], "sol_header": "def sol(trips=[[7, -5, -4], [-7, 1, -6], [-2, 10, 3], [-9, -1, 10]]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine which triples sum to zero\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(zero_sums: List[bool], trips=[[7, -5, -4], [-7, 1, -6], [-2, 10, 3], [-9, -1, 10]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))", "input": "def sat(zero_sums: List[bool], trips=[[7, -5, -4], [-7, 1, -6], [-2, 10, 3], [-9, -1, 10]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))", "target": ""}
{"module": "human_eval.py", "name": "IdentifyZeroTrips:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#92", "sol_bodies": ["    return [sum(t) == 0 for t in trips]"], "sol_header": "def sol(trips=[[-9, 9, -1], [-3, -7, -10], [0, -8, 5], [-8, -3, 3], [4, 8, 2], [-10, 8, 3]]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine which triples sum to zero\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(zero_sums: List[bool], trips=[[-9, 9, -1], [-3, -7, -10], [0, -8, 5], [-8, -3, 3], [4, 8, 2], [-10, 8, 3]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))", "input": "def sat(zero_sums: List[bool], trips=[[-9, 9, -1], [-3, -7, -10], [0, -8, 5], [-8, -3, 3], [4, 8, 2], [-10, 8, 3]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))", "target": ""}
{"module": "human_eval.py", "name": "IdentifyZeroTrips:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#92", "sol_bodies": ["    return [sum(t) == 0 for t in trips]"], "sol_header": "def sol(trips=[[-9, 3, 5], [-2, 8, 6], [1, 7, 8], [-4, 3, 4], [1, -6, 10], [-5, -8, -13], [-4, 10, -8], [1, -2, -4], [7, 2, 9], [4, -4, 0], [8, -1, 2], [-6, 0, -7], [-10, -4, 8], [-2, 6, 4], [-6, 8, 2]]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine which triples sum to zero\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(zero_sums: List[bool], trips=[[-9, 3, 5], [-2, 8, 6], [1, 7, 8], [-4, 3, 4], [1, -6, 10], [-5, -8, -13], [-4, 10, -8], [1, -2, -4], [7, 2, 9], [4, -4, 0], [8, -1, 2], [-6, 0, -7], [-10, -4, 8], [-2, 6, 4], [-6, 8, 2]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))", "input": "def sat(zero_sums: List[bool], trips=[[-9, 3, 5], [-2, 8, 6], [1, 7, 8], [-4, 3, 4], [1, -6, 10], [-5, -8, -13], [-4, 10, -8], [1, -2, -4], [7, 2, 9], [4, -4, 0], [8, -1, 2], [-6, 0, -7], [-10, -4, 8], [-2, 6, 4], [-6, 8, 2]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))", "target": ""}
{"module": "human_eval.py", "name": "IdentifyZeroTrips:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#92", "sol_bodies": ["    return [sum(t) == 0 for t in trips]"], "sol_header": "def sol(trips=[[7, -10, -3], [2, 9, 11], [-3, -10, -1], [-10, -5, 2], [-4, -5, -9], [-10, 5, -5], [1, 7, -6], [-3, -9, -12], [-5, -2, -7], [8, 10, 2], [-5, -2, 0], [-1, -6, -7], [8, 6, 2], [-8, 0, 7], [5, -5, 10], [-8, -6, -1], [-1, 1, 0], [-10, 9, -7]]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine which triples sum to zero\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(zero_sums: List[bool], trips=[[7, -10, -3], [2, 9, 11], [-3, -10, -1], [-10, -5, 2], [-4, -5, -9], [-10, 5, -5], [1, 7, -6], [-3, -9, -12], [-5, -2, -7], [8, 10, 2], [-5, -2, 0], [-1, -6, -7], [8, 6, 2], [-8, 0, 7], [5, -5, 10], [-8, -6, -1], [-1, 1, 0], [-10, 9, -7]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))", "input": "def sat(zero_sums: List[bool], trips=[[7, -10, -3], [2, 9, 11], [-3, -10, -1], [-10, -5, 2], [-4, -5, -9], [-10, 5, -5], [1, 7, -6], [-3, -9, -12], [-5, -2, -7], [8, 10, 2], [-5, -2, 0], [-1, -6, -7], [8, 6, 2], [-8, 0, 7], [5, -5, 10], [-8, -6, -1], [-1, 1, 0], [-10, 9, -7]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))", "target": ""}
{"module": "human_eval.py", "name": "WeirdDecodeVowels:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#93", "sol_bodies": ["    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return target.translate(subs).swapcase()"], "sol_header": "def sol(target=\"Hello, world!\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find string s that, when case is flipped gives target where vowels are replaced by chars two later.\n    --- Example input ---\n    'THIS is a TEST'\n\n    --- Example output ---\n    'thks KS C tgst'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=\"Hello, world!\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)", "input": "def sat(s: str, target=\"Hello, world!\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)", "target": ""}
{"module": "human_eval.py", "name": "WeirdDecodeVowels:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#93", "sol_bodies": ["    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return target.translate(subs).swapcase()"], "sol_header": "def sol(target=\"This is a good test\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find string s that, when case is flipped gives target where vowels are replaced by chars two later.\n    --- Example input ---\n    'THIS is a TEST'\n\n    --- Example output ---\n    'thks KS C tgst'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=\"This is a good test\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)", "input": "def sat(s: str, target=\"This is a good test\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)", "target": ""}
{"module": "human_eval.py", "name": "WeirdDecodeVowels:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#93", "sol_bodies": ["    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return target.translate(subs).swapcase()"], "sol_header": "def sol(target=\"\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find string s that, when case is flipped gives target where vowels are replaced by chars two later.\n    --- Example input ---\n    'THIS is a TEST'\n\n    --- Example output ---\n    'thks KS C tgst'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=\"\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)", "input": "def sat(s: str, target=\"\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)", "target": ""}
{"module": "human_eval.py", "name": "WeirdDecodeVowels:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#93", "sol_bodies": ["    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return target.translate(subs).swapcase()"], "sol_header": "def sol(target=\"That last test was a bad test!\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find string s that, when case is flipped gives target where vowels are replaced by chars two later.\n    --- Example input ---\n    'THIS is a TEST'\n\n    --- Example output ---\n    'thks KS C tgst'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=\"That last test was a bad test!\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)", "input": "def sat(s: str, target=\"That last test was a bad test!\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)", "target": ""}
{"module": "human_eval.py", "name": "WeirdDecodeVowels:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#93", "sol_bodies": ["    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return target.translate(subs).swapcase()"], "sol_header": "def sol(target=\"pneumonoultramicroscopicsilicovolanoconiosis\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find string s that, when case is flipped gives target where vowels are replaced by chars two later.\n    --- Example input ---\n    'THIS is a TEST'\n\n    --- Example output ---\n    'thks KS C tgst'\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=\"pneumonoultramicroscopicsilicovolanoconiosis\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)", "input": "def sat(s: str, target=\"pneumonoultramicroscopicsilicovolanoconiosis\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)", "target": ""}
{"module": "human_eval.py", "name": "LargestPrimeDigitSum:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#94", "sol_bodies": ["    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))\n    return [i, sum(int(c) for c in str(n))]"], "sol_header": "def sol(nums=[23, 17, 201, 14, 10473, 43225, 421, 423, 11, 10, 2022, 342157]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the index of the largest prime in the list and the sum of its digits\n\n    --- Example input ---\n    [2, 4, 7, 19, 21]\n\n    --- Example output ---\n    [3, 10]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], nums=[23, 17, 201, 14, 10473, 43225, 421, 423, 11, 10, 2022, 342157]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))", "input": "def sat(ans: List[int], nums=[23, 17, 201, 14, 10473, 43225, 421, 423, 11, 10, 2022, 342157]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))", "target": ""}
{"module": "human_eval.py", "name": "LargestPrimeDigitSum:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#94", "sol_bodies": ["    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))\n    return [i, sum(int(c) for c in str(n))]"], "sol_header": "def sol(nums=[84545, 52, 5755523, 666, 1984, 97315, 7, 3, 789, 427]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the index of the largest prime in the list and the sum of its digits\n\n    --- Example input ---\n    [2, 4, 7, 19, 21]\n\n    --- Example output ---\n    [3, 10]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], nums=[84545, 52, 5755523, 666, 1984, 97315, 7, 3, 789, 427]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))", "input": "def sat(ans: List[int], nums=[84545, 52, 5755523, 666, 1984, 97315, 7, 3, 789, 427]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))", "target": ""}
{"module": "human_eval.py", "name": "LargestPrimeDigitSum:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#94", "sol_bodies": ["    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))\n    return [i, sum(int(c) for c in str(n))]"], "sol_header": "def sol(nums=[5, 7151804, 432154, 5700, 9, 8, 253, 29062, 960, 721]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the index of the largest prime in the list and the sum of its digits\n\n    --- Example input ---\n    [2, 4, 7, 19, 21]\n\n    --- Example output ---\n    [3, 10]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], nums=[5, 7151804, 432154, 5700, 9, 8, 253, 29062, 960, 721]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))", "input": "def sat(ans: List[int], nums=[5, 7151804, 432154, 5700, 9, 8, 253, 29062, 960, 721]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))", "target": ""}
{"module": "human_eval.py", "name": "LargestPrimeDigitSum:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#94", "sol_bodies": ["    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))\n    return [i, sum(int(c) for c in str(n))]"], "sol_header": "def sol(nums=[233804, 41, 6149533, 79, 956, 317909, 8628, 248, 35086, 79]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the index of the largest prime in the list and the sum of its digits\n\n    --- Example input ---\n    [2, 4, 7, 19, 21]\n\n    --- Example output ---\n    [3, 10]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], nums=[233804, 41, 6149533, 79, 956, 317909, 8628, 248, 35086, 79]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))", "input": "def sat(ans: List[int], nums=[233804, 41, 6149533, 79, 956, 317909, 8628, 248, 35086, 79]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))", "target": ""}
{"module": "human_eval.py", "name": "LargestPrimeDigitSum:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#94", "sol_bodies": ["    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))\n    return [i, sum(int(c) for c in str(n))]"], "sol_header": "def sol(nums=[87, 2, 2883, 32665, 26115, 32, 77, 97, 717, 674175]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the index of the largest prime in the list and the sum of its digits\n\n    --- Example input ---\n    [2, 4, 7, 19, 21]\n\n    --- Example output ---\n    [3, 10]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ans: List[int], nums=[87, 2, 2883, 32665, 26115, 32, 77, 97, 717, 674175]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))", "input": "def sat(ans: List[int], nums=[87, 2, 2883, 32665, 26115, 32, 77, 97, 717, 674175]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))", "target": ""}
{"module": "human_eval.py", "name": "OddCase:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#95", "sol_bodies": ["    for different in d:\n        if all(k.islower() != different.islower() for k in d if k != different):\n            return different"], "sol_header": "def sol(d={'cat': 'CAT', 'tree': 'T', 'pick me': 'not', 'OK': 'red', 'blah': 'blah', 'z': 'Z'}):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the dictionary key whose case is different than all other keys\n\n    --- Example input ---\n    {\"red\": \"\", \"GREEN\": \"\", \"blue\": \"orange\"}\n\n    --- Example output ---\n    \"GREEN\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(different: str, d={'cat': 'CAT', 'tree': 'T', 'pick me': 'not', 'OK': 'red', 'blah': 'blah', 'z': 'Z'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)", "input": "def sat(different: str, d={'cat': 'CAT', 'tree': 'T', 'pick me': 'not', 'OK': 'red', 'blah': 'blah', 'z': 'Z'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)", "target": ""}
{"module": "human_eval.py", "name": "OddCase:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#95", "sol_bodies": ["    for different in d:\n        if all(k.islower() != different.islower() for k in d if k != different):\n            return different"], "sol_header": "def sol(d={'den': 'fymehihyxuro', 'madufitextuthohyv': 'sofekuhepokosixyzoza', 'xechygo': 'kythubehuzagu', 'xukefulete': 'hugevybelypyrer', 'maw': 'vaveraral', 'hichaquidyto': 'quisi', 'remenidasohijetybah': 'bukomegewisevoxoz', 'kyte': 'fonecohynipesewyth', 'cax': 'bilesequ', 'caduquetextan': 'juzedabaz', 'THEMITOTH': 'xotugythuzu'}):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the dictionary key whose case is different than all other keys\n\n    --- Example input ---\n    {\"red\": \"\", \"GREEN\": \"\", \"blue\": \"orange\"}\n\n    --- Example output ---\n    \"GREEN\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(different: str, d={'den': 'fymehihyxuro', 'madufitextuthohyv': 'sofekuhepokosixyzoza', 'xechygo': 'kythubehuzagu', 'xukefulete': 'hugevybelypyrer', 'maw': 'vaveraral', 'hichaquidyto': 'quisi', 'remenidasohijetybah': 'bukomegewisevoxoz', 'kyte': 'fonecohynipesewyth', 'cax': 'bilesequ', 'caduquetextan': 'juzedabaz', 'THEMITOTH': 'xotugythuzu'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)", "input": "def sat(different: str, d={'den': 'fymehihyxuro', 'madufitextuthohyv': 'sofekuhepokosixyzoza', 'xechygo': 'kythubehuzagu', 'xukefulete': 'hugevybelypyrer', 'maw': 'vaveraral', 'hichaquidyto': 'quisi', 'remenidasohijetybah': 'bukomegewisevoxoz', 'kyte': 'fonecohynipesewyth', 'cax': 'bilesequ', 'caduquetextan': 'juzedabaz', 'THEMITOTH': 'xotugythuzu'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)", "target": ""}
{"module": "human_eval.py", "name": "OddCase:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#95", "sol_bodies": ["    for different in d:\n        if all(k.islower() != different.islower() for k in d if k != different):\n            return different"], "sol_header": "def sol(d={'CHIRATICHUHUQUYZYPYW': 'kopakyquotyhaquome', 'QUEBYTEXTEXUROBEK': 'tituxa', 'ZUVU': 'xupovutexti', 'NATEXTESYTUBUMY': 'ponusewaquufot', 'THUK': 'gyvy', 'CETEXTOFENAXIXANEKA': 'xyjytextecywykoquo', 'SEKAMIWEHYTHYTEXTUCU': 'jehu', 'H': 'quicyquohofowejivun', 'KYTEXTIBAXUTAV': 'nygutextin', 'LYQUA': 'biruji', 'tizenyry': 'xavyquukoc'}):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the dictionary key whose case is different than all other keys\n\n    --- Example input ---\n    {\"red\": \"\", \"GREEN\": \"\", \"blue\": \"orange\"}\n\n    --- Example output ---\n    \"GREEN\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(different: str, d={'CHIRATICHUHUQUYZYPYW': 'kopakyquotyhaquome', 'QUEBYTEXTEXUROBEK': 'tituxa', 'ZUVU': 'xupovutexti', 'NATEXTESYTUBUMY': 'ponusewaquufot', 'THUK': 'gyvy', 'CETEXTOFENAXIXANEKA': 'xyjytextecywykoquo', 'SEKAMIWEHYTHYTEXTUCU': 'jehu', 'H': 'quicyquohofowejivun', 'KYTEXTIBAXUTAV': 'nygutextin', 'LYQUA': 'biruji', 'tizenyry': 'xavyquukoc'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)", "input": "def sat(different: str, d={'CHIRATICHUHUQUYZYPYW': 'kopakyquotyhaquome', 'QUEBYTEXTEXUROBEK': 'tituxa', 'ZUVU': 'xupovutexti', 'NATEXTESYTUBUMY': 'ponusewaquufot', 'THUK': 'gyvy', 'CETEXTOFENAXIXANEKA': 'xyjytextecywykoquo', 'SEKAMIWEHYTHYTEXTUCU': 'jehu', 'H': 'quicyquohofowejivun', 'KYTEXTIBAXUTAV': 'nygutextin', 'LYQUA': 'biruji', 'tizenyry': 'xavyquukoc'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)", "target": ""}
{"module": "human_eval.py", "name": "OddCase:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#95", "sol_bodies": ["    for different in d:\n        if all(k.islower() != different.islower() for k in d if k != different):\n            return different"], "sol_header": "def sol(d={'CHEWA': 'geratenegafa', 'WATHYHUVOTEXTINO': 'th', 'DIFUS': 'zetextatasohunibathe', 'TUBEZA': 'rajytextar', 'NEZALEQUAZAHEKAGUPU': 'bequexucoxy', 'SEBOLIZEDUL': 'wyxufyhodymube', 'ZU': 'conuhywumychogije', 'DE': 'lebemypovoke', 'DEBURUGINOC': 'gequilithyjyvymufi', 'TEXTURAFA': 'textejesyko', 'rixechy': 'fate'}):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the dictionary key whose case is different than all other keys\n\n    --- Example input ---\n    {\"red\": \"\", \"GREEN\": \"\", \"blue\": \"orange\"}\n\n    --- Example output ---\n    \"GREEN\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(different: str, d={'CHEWA': 'geratenegafa', 'WATHYHUVOTEXTINO': 'th', 'DIFUS': 'zetextatasohunibathe', 'TUBEZA': 'rajytextar', 'NEZALEQUAZAHEKAGUPU': 'bequexucoxy', 'SEBOLIZEDUL': 'wyxufyhodymube', 'ZU': 'conuhywumychogije', 'DE': 'lebemypovoke', 'DEBURUGINOC': 'gequilithyjyvymufi', 'TEXTURAFA': 'textejesyko', 'rixechy': 'fate'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)", "input": "def sat(different: str, d={'CHEWA': 'geratenegafa', 'WATHYHUVOTEXTINO': 'th', 'DIFUS': 'zetextatasohunibathe', 'TUBEZA': 'rajytextar', 'NEZALEQUAZAHEKAGUPU': 'bequexucoxy', 'SEBOLIZEDUL': 'wyxufyhodymube', 'ZU': 'conuhywumychogije', 'DE': 'lebemypovoke', 'DEBURUGINOC': 'gequilithyjyvymufi', 'TEXTURAFA': 'textejesyko', 'rixechy': 'fate'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)", "target": ""}
{"module": "human_eval.py", "name": "OddCase:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#95", "sol_bodies": ["    for different in d:\n        if all(k.islower() != different.islower() for k in d if k != different):\n            return different"], "sol_header": "def sol(d={'quicaboguc': 'su', 'sacylir': 'tholubakypynythiryr', 'vijuchox': 'matextyquorewetytefy', 'lechi': 'nuch', 'viz': 'cheferopa', 'textowikalihehupyxi': 'quuchonasufexi', 'wuhujasi': 'f', 'tytextedoma': 'zifehabumabocate', 'gaviquolaxagihisice': 'sulywuzoquo', 'muvequo': 'juxachameje', 'B': 'quanesyfeku'}):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the dictionary key whose case is different than all other keys\n\n    --- Example input ---\n    {\"red\": \"\", \"GREEN\": \"\", \"blue\": \"orange\"}\n\n    --- Example output ---\n    \"GREEN\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(different: str, d={'quicaboguc': 'su', 'sacylir': 'tholubakypynythiryr', 'vijuchox': 'matextyquorewetytefy', 'lechi': 'nuch', 'viz': 'cheferopa', 'textowikalihehupyxi': 'quuchonasufexi', 'wuhujasi': 'f', 'tytextedoma': 'zifehabumabocate', 'gaviquolaxagihisice': 'sulywuzoquo', 'muvequo': 'juxachameje', 'B': 'quanesyfeku'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)", "input": "def sat(different: str, d={'quicaboguc': 'su', 'sacylir': 'tholubakypynythiryr', 'vijuchox': 'matextyquorewetytefy', 'lechi': 'nuch', 'viz': 'cheferopa', 'textowikalihehupyxi': 'quuchonasufexi', 'wuhujasi': 'f', 'tytextedoma': 'zifehabumabocate', 'gaviquolaxagihisice': 'sulywuzoquo', 'muvequo': 'juxachameje', 'B': 'quanesyfeku'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)", "target": ""}
{"module": "human_eval.py", "name": "PrimesUpTo:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#96", "sol_bodies": ["    primes = []\n    candidates = set(range(2, n))\n    for i in range(2, n):\n        if i in candidates:\n            primes.append(i)\n            candidates.difference_update(range(i, n, i))\n    return primes"], "sol_header": "def sol(n=1234):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all primes up to n\n\n    --- Example input ---\n    9\n\n    --- Example output ---\n    [2, 3, 5, 7]\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: List[int], n=1234):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)", "input": "def sat(primes: List[int], n=1234):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)", "target": ""}
{"module": "human_eval.py", "name": "PrimesUpTo:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#96", "sol_bodies": ["    primes = []\n    candidates = set(range(2, n))\n    for i in range(2, n):\n        if i in candidates:\n            primes.append(i)\n            candidates.difference_update(range(i, n, i))\n    return primes"], "sol_header": "def sol(n=10):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all primes up to n\n\n    --- Example input ---\n    9\n\n    --- Example output ---\n    [2, 3, 5, 7]\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: List[int], n=10):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)", "input": "def sat(primes: List[int], n=10):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)", "target": ""}
{"module": "human_eval.py", "name": "PrimesUpTo:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#96", "sol_bodies": ["    primes = []\n    candidates = set(range(2, n))\n    for i in range(2, n):\n        if i in candidates:\n            primes.append(i)\n            candidates.difference_update(range(i, n, i))\n    return primes"], "sol_header": "def sol(n=1000):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all primes up to n\n\n    --- Example input ---\n    9\n\n    --- Example output ---\n    [2, 3, 5, 7]\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: List[int], n=1000):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)", "input": "def sat(primes: List[int], n=1000):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)", "target": ""}
{"module": "human_eval.py", "name": "PrimesUpTo:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#96", "sol_bodies": ["    primes = []\n    candidates = set(range(2, n))\n    for i in range(2, n):\n        if i in candidates:\n            primes.append(i)\n            candidates.difference_update(range(i, n, i))\n    return primes"], "sol_header": "def sol(n=-1):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all primes up to n\n\n    --- Example input ---\n    9\n\n    --- Example output ---\n    [2, 3, 5, 7]\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: List[int], n=-1):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)", "input": "def sat(primes: List[int], n=-1):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)", "target": ""}
{"module": "human_eval.py", "name": "PrimesUpTo:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#96", "sol_bodies": ["    primes = []\n    candidates = set(range(2, n))\n    for i in range(2, n):\n        if i in candidates:\n            primes.append(i)\n            candidates.difference_update(range(i, n, i))\n    return primes"], "sol_header": "def sol(n=10000):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all primes up to n\n\n    --- Example input ---\n    9\n\n    --- Example output ---\n    [2, 3, 5, 7]\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: List[int], n=10000):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)", "input": "def sat(primes: List[int], n=10000):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)", "target": ""}
{"module": "human_eval.py", "name": "UnitsProduct:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#97", "sol_bodies": ["    prod = 1\n    for n in nums:\n        prod *= abs(n % 10)\n    return prod"], "sol_header": "def sol(nums=[17, 24, 39, 15, 11, 201, 97, 65, 18]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the product of the units digits in the numbers\n\n    [12, 34] => 8\n    \"\"\"", "weight": 1.0, "sat": "def sat(prod: int, nums=[17, 24, 39, 15, 11, 201, 97, 65, 18]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1", "input": "def sat(prod: int, nums=[17, 24, 39, 15, 11, 201, 97, 65, 18]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1", "target": ""}
{"module": "human_eval.py", "name": "UnitsProduct:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#97", "sol_bodies": ["    prod = 1\n    for n in nums:\n        prod *= abs(n % 10)\n    return prod"], "sol_header": "def sol(nums=[1, 9, 96, 79, 86, -30, -33, 63, 39, 35]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the product of the units digits in the numbers\n\n    [12, 34] => 8\n    \"\"\"", "weight": 1.0, "sat": "def sat(prod: int, nums=[1, 9, 96, 79, 86, -30, -33, 63, 39, 35]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1", "input": "def sat(prod: int, nums=[1, 9, 96, 79, 86, -30, -33, 63, 39, 35]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1", "target": ""}
{"module": "human_eval.py", "name": "UnitsProduct:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#97", "sol_bodies": ["    prod = 1\n    for n in nums:\n        prod *= abs(n % 10)\n    return prod"], "sol_header": "def sol(nums=[-29, -50, -4, 79, 2, 19, 34, 9, 27, -42]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the product of the units digits in the numbers\n\n    [12, 34] => 8\n    \"\"\"", "weight": 1.0, "sat": "def sat(prod: int, nums=[-29, -50, -4, 79, 2, 19, 34, 9, 27, -42]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1", "input": "def sat(prod: int, nums=[-29, -50, -4, 79, 2, 19, 34, 9, 27, -42]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1", "target": ""}
{"module": "human_eval.py", "name": "UnitsProduct:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#97", "sol_bodies": ["    prod = 1\n    for n in nums:\n        prod *= abs(n % 10)\n    return prod"], "sol_header": "def sol(nums=[-28, -34, 90, 0, -38, -39, -13, 13, 56, 50]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the product of the units digits in the numbers\n\n    [12, 34] => 8\n    \"\"\"", "weight": 1.0, "sat": "def sat(prod: int, nums=[-28, -34, 90, 0, -38, -39, -13, 13, 56, 50]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1", "input": "def sat(prod: int, nums=[-28, -34, 90, 0, -38, -39, -13, 13, 56, 50]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1", "target": ""}
{"module": "human_eval.py", "name": "UnitsProduct:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#97", "sol_bodies": ["    prod = 1\n    for n in nums:\n        prod *= abs(n % 10)\n    return prod"], "sol_header": "def sol(nums=[81, 36, -53, 17, 40, -30, -20, 13, -16, -18]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the product of the units digits in the numbers\n\n    [12, 34] => 8\n    \"\"\"", "weight": 1.0, "sat": "def sat(prod: int, nums=[81, 36, -53, 17, 40, -30, -20, 13, -16, -18]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1", "input": "def sat(prod: int, nums=[81, 36, -53, 17, 40, -30, -20, 13, -16, -18]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1", "target": ""}
{"module": "human_eval.py", "name": "UppercaseEven:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#98", "sol_bodies": ["    return [i for i, c in enumerate(s) if i % 2 == 0 and c in \"AEIOU\"]"], "sol_header": "def sol(s=\"ThIs is A tEsT, Or *IS* iT?\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the positions of all uppercase vowels (not counting Y) in even indices\n\n    \"EAT here NOW\" => [0, 10]\n    \"\"\"", "weight": 1.0, "sat": "def sat(positions: List[int], s=\"ThIs is A tEsT, Or *IS* iT?\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))", "input": "def sat(positions: List[int], s=\"ThIs is A tEsT, Or *IS* iT?\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))", "target": ""}
{"module": "human_eval.py", "name": "UppercaseEven:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#98", "sol_bodies": ["    return [i for i, c in enumerate(s) if i % 2 == 0 and c in \"AEIOU\"]"], "sol_header": "def sol(s=\"j\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the positions of all uppercase vowels (not counting Y) in even indices\n\n    \"EAT here NOW\" => [0, 10]\n    \"\"\"", "weight": 1.0, "sat": "def sat(positions: List[int], s=\"j\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))", "input": "def sat(positions: List[int], s=\"j\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))", "target": ""}
{"module": "human_eval.py", "name": "UppercaseEven:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#98", "sol_bodies": ["    return [i for i, c in enumerate(s) if i % 2 == 0 and c in \"AEIOU\"]"], "sol_header": "def sol(s=\"FYZuLOLYcoduHUSA\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the positions of all uppercase vowels (not counting Y) in even indices\n\n    \"EAT here NOW\" => [0, 10]\n    \"\"\"", "weight": 1.0, "sat": "def sat(positions: List[int], s=\"FYZuLOLYcoduHUSA\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))", "input": "def sat(positions: List[int], s=\"FYZuLOLYcoduHUSA\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))", "target": ""}
{"module": "human_eval.py", "name": "UppercaseEven:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#98", "sol_bodies": ["    return [i for i, c in enumerate(s) if i % 2 == 0 and c in \"AEIOU\"]"], "sol_header": "def sol(s=\"vEWUquyCo\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the positions of all uppercase vowels (not counting Y) in even indices\n\n    \"EAT here NOW\" => [0, 10]\n    \"\"\"", "weight": 1.0, "sat": "def sat(positions: List[int], s=\"vEWUquyCo\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))", "input": "def sat(positions: List[int], s=\"vEWUquyCo\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))", "target": ""}
{"module": "human_eval.py", "name": "UppercaseEven:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#98", "sol_bodies": ["    return [i for i, c in enumerate(s) if i % 2 == 0 and c in \"AEIOU\"]"], "sol_header": "def sol(s=\"JUtARefAzeVyruJEvAKy\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the positions of all uppercase vowels (not counting Y) in even indices\n\n    \"EAT here NOW\" => [0, 10]\n    \"\"\"", "weight": 1.0, "sat": "def sat(positions: List[int], s=\"JUtARefAzeVyruJEvAKy\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))", "input": "def sat(positions: List[int], s=\"JUtARefAzeVyruJEvAKy\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))", "target": ""}
{"module": "human_eval.py", "name": "ClosestInteger:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#99\n\nSince we can tolerate more than one answer per puzzle, we do not need to specify a tie-breaking rule.", "sol_bodies": ["    return round(x)"], "sol_header": "def sol(x=329437923.5):", "ans_type": "int", "sol_docstring": "    \"\"\"Round to nearest integer\n\n    --- input ---\n    3.7\n\n    --- output ---\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, x=329437923.5):\n    return abs(n - x) <= 0.5", "input": "def sat(n: int, x=329437923.5):\n    return abs(n - x) <= 0.5", "target": ""}
{"module": "human_eval.py", "name": "ClosestInteger:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#99\n\nSince we can tolerate more than one answer per puzzle, we do not need to specify a tie-breaking rule.", "sol_bodies": ["    return round(x)"], "sol_header": "def sol(x=3557710970.9527555):", "ans_type": "int", "sol_docstring": "    \"\"\"Round to nearest integer\n\n    --- input ---\n    3.7\n\n    --- output ---\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, x=3557710970.9527555):\n    return abs(n - x) <= 0.5", "input": "def sat(n: int, x=3557710970.9527555):\n    return abs(n - x) <= 0.5", "target": ""}
{"module": "human_eval.py", "name": "ClosestInteger:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#99\n\nSince we can tolerate more than one answer per puzzle, we do not need to specify a tie-breaking rule.", "sol_bodies": ["    return round(x)"], "sol_header": "def sol(x=-250406.87146656853):", "ans_type": "int", "sol_docstring": "    \"\"\"Round to nearest integer\n\n    --- input ---\n    3.7\n\n    --- output ---\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, x=-250406.87146656853):\n    return abs(n - x) <= 0.5", "input": "def sat(n: int, x=-250406.87146656853):\n    return abs(n - x) <= 0.5", "target": ""}
{"module": "human_eval.py", "name": "ClosestInteger:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#99\n\nSince we can tolerate more than one answer per puzzle, we do not need to specify a tie-breaking rule.", "sol_bodies": ["    return round(x)"], "sol_header": "def sol(x=346686.79646634863):", "ans_type": "int", "sol_docstring": "    \"\"\"Round to nearest integer\n\n    --- input ---\n    3.7\n\n    --- output ---\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, x=346686.79646634863):\n    return abs(n - x) <= 0.5", "input": "def sat(n: int, x=346686.79646634863):\n    return abs(n - x) <= 0.5", "target": ""}
{"module": "human_eval.py", "name": "ClosestInteger:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#99\n\nSince we can tolerate more than one answer per puzzle, we do not need to specify a tie-breaking rule.", "sol_bodies": ["    return round(x)"], "sol_header": "def sol(x=1087254.523941833):", "ans_type": "int", "sol_docstring": "    \"\"\"Round to nearest integer\n\n    --- input ---\n    3.7\n\n    --- output ---\n    4\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, x=1087254.523941833):\n    return abs(n - x) <= 0.5", "input": "def sat(n: int, x=1087254.523941833):\n    return abs(n - x) <= 0.5", "target": ""}
{"module": "human_eval.py", "name": "StonePiles:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#100", "sol_bodies": ["    return [n + 2 * i for i in range(n)]"], "sol_header": "def sol(n=909):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even\n    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones\n    than the previous pile but as few as possible. Return the number of stones in each pile.\n\n    2 => [2, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=909):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))", "input": "def sat(li: List[int], n=909):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))", "target": ""}
{"module": "human_eval.py", "name": "StonePiles:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#100", "sol_bodies": ["    return [n + 2 * i for i in range(n)]"], "sol_header": "def sol(n=28694):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even\n    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones\n    than the previous pile but as few as possible. Return the number of stones in each pile.\n\n    2 => [2, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=28694):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))", "input": "def sat(li: List[int], n=28694):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))", "target": ""}
{"module": "human_eval.py", "name": "StonePiles:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#100", "sol_bodies": ["    return [n + 2 * i for i in range(n)]"], "sol_header": "def sol(n=97916):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even\n    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones\n    than the previous pile but as few as possible. Return the number of stones in each pile.\n\n    2 => [2, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=97916):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))", "input": "def sat(li: List[int], n=97916):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))", "target": ""}
{"module": "human_eval.py", "name": "StonePiles:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#100", "sol_bodies": ["    return [n + 2 * i for i in range(n)]"], "sol_header": "def sol(n=57991):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even\n    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones\n    than the previous pile but as few as possible. Return the number of stones in each pile.\n\n    2 => [2, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=57991):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))", "input": "def sat(li: List[int], n=57991):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))", "target": ""}
{"module": "human_eval.py", "name": "StonePiles:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#100", "sol_bodies": ["    return [n + 2 * i for i in range(n)]"], "sol_header": "def sol(n=24997):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even\n    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones\n    than the previous pile but as few as possible. Return the number of stones in each pile.\n\n    2 => [2, 4]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=24997):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))", "input": "def sat(li: List[int], n=24997):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))", "target": ""}
{"module": "human_eval.py", "name": "CompleteSplit:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#101", "sol_bodies": ["    import re\n    merged = re.split(r\"([ ,]+)\", string)\n    return [merged[::2], merged[1::2]]"], "sol_header": "def sol(string=\"Hello, world!  You look like you're on turtles.\"):", "ans_type": "List[List[str]]", "sol_docstring": "    \"\"\"\n    Split a string of words separated by commas and spaces into 2 lists: words and separators\n\n    Sample input: \"Hi there, Anna\"\n    Sample output: [[\"Hi\", \"there\", \"Anna\"], [\" \", \", \"]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(splits: List[List[str]], string=\"Hello, world!  You look like you're on turtles.\"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string", "input": "def sat(splits: List[List[str]], string=\"Hello, world!  You look like you're on turtles.\"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string", "target": ""}
{"module": "human_eval.py", "name": "CompleteSplit:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#101", "sol_bodies": ["    import re\n    merged = re.split(r\"([ ,]+)\", string)\n    return [merged[::2], merged[1::2]]"], "sol_header": "def sol(string=\"    This is     a valley, so, so so,,,,\"):", "ans_type": "List[List[str]]", "sol_docstring": "    \"\"\"\n    Split a string of words separated by commas and spaces into 2 lists: words and separators\n\n    Sample input: \"Hi there, Anna\"\n    Sample output: [[\"Hi\", \"there\", \"Anna\"], [\" \", \", \"]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(splits: List[List[str]], string=\"    This is     a valley, so, so so,,,,\"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string", "input": "def sat(splits: List[List[str]], string=\"    This is     a valley, so, so so,,,,\"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string", "target": ""}
{"module": "human_eval.py", "name": "CompleteSplit:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#101", "sol_bodies": ["    import re\n    merged = re.split(r\"([ ,]+)\", string)\n    return [merged[::2], merged[1::2]]"], "sol_header": "def sol(string=\"\"):", "ans_type": "List[List[str]]", "sol_docstring": "    \"\"\"\n    Split a string of words separated by commas and spaces into 2 lists: words and separators\n\n    Sample input: \"Hi there, Anna\"\n    Sample output: [[\"Hi\", \"there\", \"Anna\"], [\" \", \", \"]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(splits: List[List[str]], string=\"\"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string", "input": "def sat(splits: List[List[str]], string=\"\"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string", "target": ""}
{"module": "human_eval.py", "name": "CompleteSplit:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#101", "sol_bodies": ["    import re\n    merged = re.split(r\"([ ,]+)\", string)\n    return [merged[::2], merged[1::2]]"], "sol_header": "def sol(string=\" ,,,,, , , \"):", "ans_type": "List[List[str]]", "sol_docstring": "    \"\"\"\n    Split a string of words separated by commas and spaces into 2 lists: words and separators\n\n    Sample input: \"Hi there, Anna\"\n    Sample output: [[\"Hi\", \"there\", \"Anna\"], [\" \", \", \"]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(splits: List[List[str]], string=\" ,,,,, , , \"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string", "input": "def sat(splits: List[List[str]], string=\" ,,,,, , , \"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string", "target": ""}
{"module": "human_eval.py", "name": "CompleteSplit:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#101", "sol_bodies": ["    import re\n    merged = re.split(r\"([ ,]+)\", string)\n    return [merged[::2], merged[1::2]]"], "sol_header": "def sol(string=\"Do not worry\\nabout newlines\\n!\"):", "ans_type": "List[List[str]]", "sol_docstring": "    \"\"\"\n    Split a string of words separated by commas and spaces into 2 lists: words and separators\n\n    Sample input: \"Hi there, Anna\"\n    Sample output: [[\"Hi\", \"there\", \"Anna\"], [\" \", \", \"]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(splits: List[List[str]], string=\"Do not worry\\nabout newlines\\n!\"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string", "input": "def sat(splits: List[List[str]], string=\"Do not worry\\nabout newlines\\n!\"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string", "target": ""}
{"module": "human_eval.py", "name": "BiggestEven:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#102", "sol_bodies": ["    if a > b or (a == b and a % 2 == 1):\n        return -1\n    return b if b % 2 == 0 else b - 1"], "sol_header": "def sol(a=145, b=24126846790974):", "ans_type": "int", "sol_docstring": "    \"\"\"Return the biggest even number between a and b inclusive, or -1 if there is no such number\n\n    Example input:\n    a=20, b=99\n\n    Example output:\n    98\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=145, b=24126846790974):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))", "input": "def sat(x: int, a=145, b=24126846790974):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))", "target": ""}
{"module": "human_eval.py", "name": "BiggestEven:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#102", "sol_bodies": ["    if a > b or (a == b and a % 2 == 1):\n        return -1\n    return b if b % 2 == 0 else b - 1"], "sol_header": "def sol(a=17, b=17):", "ans_type": "int", "sol_docstring": "    \"\"\"Return the biggest even number between a and b inclusive, or -1 if there is no such number\n\n    Example input:\n    a=20, b=99\n\n    Example output:\n    98\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=17, b=17):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))", "input": "def sat(x: int, a=17, b=17):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))", "target": ""}
{"module": "human_eval.py", "name": "BiggestEven:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#102", "sol_bodies": ["    if a > b or (a == b and a % 2 == 1):\n        return -1\n    return b if b % 2 == 0 else b - 1"], "sol_header": "def sol(a=-10, b=-6):", "ans_type": "int", "sol_docstring": "    \"\"\"Return the biggest even number between a and b inclusive, or -1 if there is no such number\n\n    Example input:\n    a=20, b=99\n\n    Example output:\n    98\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=-10, b=-6):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))", "input": "def sat(x: int, a=-10, b=-6):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))", "target": ""}
{"module": "human_eval.py", "name": "BiggestEven:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#102", "sol_bodies": ["    if a > b or (a == b and a % 2 == 1):\n        return -1\n    return b if b % 2 == 0 else b - 1"], "sol_header": "def sol(a=100, b=84):", "ans_type": "int", "sol_docstring": "    \"\"\"Return the biggest even number between a and b inclusive, or -1 if there is no such number\n\n    Example input:\n    a=20, b=99\n\n    Example output:\n    98\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=100, b=84):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))", "input": "def sat(x: int, a=100, b=84):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))", "target": ""}
{"module": "human_eval.py", "name": "BiggestEven:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#102", "sol_bodies": ["    if a > b or (a == b and a % 2 == 1):\n        return -1\n    return b if b % 2 == 0 else b - 1"], "sol_header": "def sol(a=0, b=323523571223):", "ans_type": "int", "sol_docstring": "    \"\"\"Return the biggest even number between a and b inclusive, or -1 if there is no such number\n\n    Example input:\n    a=20, b=99\n\n    Example output:\n    98\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=0, b=323523571223):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))", "input": "def sat(x: int, a=0, b=323523571223):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))", "target": ""}
{"module": "human_eval.py", "name": "BinaryAverage:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#103", "sol_bodies": ["    r = range(a, b)\n    if len(r) == 0:\n        return \"-1\"\n    return bin(round(sum(r) / len(r)))"], "sol_header": "def sol(a=-103252, b=10657):", "ans_type": "str", "sol_docstring": "    \"\"\"Return the average of the numbers a through b rounded to nearest integer, in binary\n    (or -1 if there are no such numbers)\n\n    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, a=-103252, b=10657):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))", "input": "def sat(s: str, a=-103252, b=10657):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))", "target": ""}
{"module": "human_eval.py", "name": "BinaryAverage:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#103", "sol_bodies": ["    r = range(a, b)\n    if len(r) == 0:\n        return \"-1\"\n    return bin(round(sum(r) / len(r)))"], "sol_header": "def sol(a=70421, b=70421):", "ans_type": "str", "sol_docstring": "    \"\"\"Return the average of the numbers a through b rounded to nearest integer, in binary\n    (or -1 if there are no such numbers)\n\n    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, a=70421, b=70421):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))", "input": "def sat(s: str, a=70421, b=70421):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))", "target": ""}
{"module": "human_eval.py", "name": "BinaryAverage:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#103", "sol_bodies": ["    r = range(a, b)\n    if len(r) == 0:\n        return \"-1\"\n    return bin(round(sum(r) / len(r)))"], "sol_header": "def sol(a=-10299, b=-10300):", "ans_type": "str", "sol_docstring": "    \"\"\"Return the average of the numbers a through b rounded to nearest integer, in binary\n    (or -1 if there are no such numbers)\n\n    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, a=-10299, b=-10300):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))", "input": "def sat(s: str, a=-10299, b=-10300):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))", "target": ""}
{"module": "human_eval.py", "name": "BinaryAverage:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#103", "sol_bodies": ["    r = range(a, b)\n    if len(r) == 0:\n        return \"-1\"\n    return bin(round(sum(r) / len(r)))"], "sol_header": "def sol(a=0, b=52):", "ans_type": "str", "sol_docstring": "    \"\"\"Return the average of the numbers a through b rounded to nearest integer, in binary\n    (or -1 if there are no such numbers)\n\n    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, a=0, b=52):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))", "input": "def sat(s: str, a=0, b=52):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))", "target": ""}
{"module": "human_eval.py", "name": "BinaryAverage:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#103", "sol_bodies": ["    r = range(a, b)\n    if len(r) == 0:\n        return \"-1\"\n    return bin(round(sum(r) / len(r)))"], "sol_header": "def sol(a=-89, b=0):", "ans_type": "str", "sol_docstring": "    \"\"\"Return the average of the numbers a through b rounded to nearest integer, in binary\n    (or -1 if there are no such numbers)\n\n    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, a=-89, b=0):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))", "input": "def sat(s: str, a=-89, b=0):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))", "target": ""}
{"module": "human_eval.py", "name": "SortedOdds:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#104", "sol_bodies": ["    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))"], "sol_header": "def sol(nums=[17, 20, -100, 101, 423258, 19949, 0, 20174, 9351773, -11]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the sublist of numbers with only odd digits in increasing order\n\n    [17, 21, 18, 1, 4] => [1, 17, 21]\n    \"\"\"", "weight": 1.0, "sat": "def sat(sub: List[int], nums=[17, 20, -100, 101, 423258, 19949, 0, 20174, 9351773, -11]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True", "input": "def sat(sub: List[int], nums=[17, 20, -100, 101, 423258, 19949, 0, 20174, 9351773, -11]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True", "target": ""}
{"module": "human_eval.py", "name": "SortedOdds:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#104", "sol_bodies": ["    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))"], "sol_header": "def sol(nums=[57463, -919281, 3293, 346, 319386, 14840, -423, 8892, 4689075, -4526385, 5889, 1226706, -5422, 7630106, 74198, 7835, 1050438, 602897]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the sublist of numbers with only odd digits in increasing order\n\n    [17, 21, 18, 1, 4] => [1, 17, 21]\n    \"\"\"", "weight": 1.0, "sat": "def sat(sub: List[int], nums=[57463, -919281, 3293, 346, 319386, 14840, -423, 8892, 4689075, -4526385, 5889, 1226706, -5422, 7630106, 74198, 7835, 1050438, 602897]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True", "input": "def sat(sub: List[int], nums=[57463, -919281, 3293, 346, 319386, 14840, -423, 8892, 4689075, -4526385, 5889, 1226706, -5422, 7630106, 74198, 7835, 1050438, 602897]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True", "target": ""}
{"module": "human_eval.py", "name": "SortedOdds:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#104", "sol_bodies": ["    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))"], "sol_header": "def sol(nums=[0, 7888, -1156983, 67, -304732, 128, -5391, 0, 468568]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the sublist of numbers with only odd digits in increasing order\n\n    [17, 21, 18, 1, 4] => [1, 17, 21]\n    \"\"\"", "weight": 1.0, "sat": "def sat(sub: List[int], nums=[0, 7888, -1156983, 67, -304732, 128, -5391, 0, 468568]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True", "input": "def sat(sub: List[int], nums=[0, 7888, -1156983, 67, -304732, 128, -5391, 0, 468568]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True", "target": ""}
{"module": "human_eval.py", "name": "SortedOdds:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#104", "sol_bodies": ["    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))"], "sol_header": "def sol(nums=[630253, -40, -8050056, -18536, 5847702, -90469, 290800, 0, -1431502, -5837, -945, 97582, 8673, 2729]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the sublist of numbers with only odd digits in increasing order\n\n    [17, 21, 18, 1, 4] => [1, 17, 21]\n    \"\"\"", "weight": 1.0, "sat": "def sat(sub: List[int], nums=[630253, -40, -8050056, -18536, 5847702, -90469, 290800, 0, -1431502, -5837, -945, 97582, 8673, 2729]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True", "input": "def sat(sub: List[int], nums=[630253, -40, -8050056, -18536, 5847702, -90469, 290800, 0, -1431502, -5837, -945, 97582, 8673, 2729]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True", "target": ""}
{"module": "human_eval.py", "name": "SortedOdds:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#104", "sol_bodies": ["    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))"], "sol_header": "def sol(nums=[]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the sublist of numbers with only odd digits in increasing order\n\n    [17, 21, 18, 1, 4] => [1, 17, 21]\n    \"\"\"", "weight": 1.0, "sat": "def sat(sub: List[int], nums=[]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True", "input": "def sat(sub: List[int], nums=[]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True", "target": ""}
{"module": "human_eval.py", "name": "BackwardsDigits:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#105", "sol_bodies": ["    digits = {1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\", 6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\"}\n    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]"], "sol_header": "def sol(nums=[0, 2, 14, -2, 3, 8, 4, 5, 5, 7, 21, 101, 41, 2, 9, 6]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Return the single digits in nums sorted backwards and converted to English words\n\n    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']\n    \"\"\"", "weight": 1.0, "sat": "def sat(backwards_digits: List[str], nums=[0, 2, 14, -2, 3, 8, 4, 5, 5, 7, 21, 101, 41, 2, 9, 6]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)", "input": "def sat(backwards_digits: List[str], nums=[0, 2, 14, -2, 3, 8, 4, 5, 5, 7, 21, 101, 41, 2, 9, 6]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)", "target": ""}
{"module": "human_eval.py", "name": "BackwardsDigits:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#105", "sol_bodies": ["    digits = {1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\", 6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\"}\n    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]"], "sol_header": "def sol(nums=[98, -3]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Return the single digits in nums sorted backwards and converted to English words\n\n    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']\n    \"\"\"", "weight": 1.0, "sat": "def sat(backwards_digits: List[str], nums=[98, -3]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)", "input": "def sat(backwards_digits: List[str], nums=[98, -3]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)", "target": ""}
{"module": "human_eval.py", "name": "BackwardsDigits:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#105", "sol_bodies": ["    digits = {1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\", 6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\"}\n    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]"], "sol_header": "def sol(nums=[22, 5, 27, 10, 70, 9, 82, -5, 30, 51, 10, 0, 48]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Return the single digits in nums sorted backwards and converted to English words\n\n    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']\n    \"\"\"", "weight": 1.0, "sat": "def sat(backwards_digits: List[str], nums=[22, 5, 27, 10, 70, 9, 82, -5, 30, 51, 10, 0, 48]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)", "input": "def sat(backwards_digits: List[str], nums=[22, 5, 27, 10, 70, 9, 82, -5, 30, 51, 10, 0, 48]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)", "target": ""}
{"module": "human_eval.py", "name": "BackwardsDigits:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#105", "sol_bodies": ["    digits = {1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\", 6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\"}\n    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]"], "sol_header": "def sol(nums=[-5, -3, 9, 1, 93, -1, 4]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Return the single digits in nums sorted backwards and converted to English words\n\n    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']\n    \"\"\"", "weight": 1.0, "sat": "def sat(backwards_digits: List[str], nums=[-5, -3, 9, 1, 93, -1, 4]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)", "input": "def sat(backwards_digits: List[str], nums=[-5, -3, 9, 1, 93, -1, 4]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)", "target": ""}
{"module": "human_eval.py", "name": "BackwardsDigits:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#105", "sol_bodies": ["    digits = {1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\", 6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\"}\n    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]"], "sol_header": "def sol(nums=[-1, 3, 75, 86, 70, -5, 31, 5, 62, 6, 92, 60, 29, 5, 7, 3]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Return the single digits in nums sorted backwards and converted to English words\n\n    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']\n    \"\"\"", "weight": 1.0, "sat": "def sat(backwards_digits: List[str], nums=[-1, 3, 75, 86, 70, -5, 31, 5, 62, 6, 92, 60, 29, 5, 7, 3]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)", "input": "def sat(backwards_digits: List[str], nums=[-1, 3, 75, 86, 70, -5, 31, 5, 62, 6, 92, 60, 29, 5, 7, 3]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)", "target": ""}
{"module": "human_eval.py", "name": "AlternatingFactorials:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#106", "sol_bodies": ["    ans = []\n    for i in range(n):\n        if i < 2:\n            m = i + 1\n        elif i % 2 == 1:\n            m = ans[i - 2] + i + (i + 1)\n        else:\n            m = ans[i - 2] * i * (i + 1)\n        ans.append(m)\n\n    return ans"], "sol_header": "def sol(n=100):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)\n\n    5 => [1, 2, 6, 9, 120]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=100):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True", "input": "def sat(li: List[int], n=100):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "AlternatingFactorials:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#106", "sol_bodies": ["    ans = []\n    for i in range(n):\n        if i < 2:\n            m = i + 1\n        elif i % 2 == 1:\n            m = ans[i - 2] + i + (i + 1)\n        else:\n            m = ans[i - 2] * i * (i + 1)\n        ans.append(m)\n\n    return ans"], "sol_header": "def sol(n=997):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)\n\n    5 => [1, 2, 6, 9, 120]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=997):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True", "input": "def sat(li: List[int], n=997):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "AlternatingFactorials:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#106", "sol_bodies": ["    ans = []\n    for i in range(n):\n        if i < 2:\n            m = i + 1\n        elif i % 2 == 1:\n            m = ans[i - 2] + i + (i + 1)\n        else:\n            m = ans[i - 2] * i * (i + 1)\n        ans.append(m)\n\n    return ans"], "sol_header": "def sol(n=825):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)\n\n    5 => [1, 2, 6, 9, 120]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=825):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True", "input": "def sat(li: List[int], n=825):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "AlternatingFactorials:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#106", "sol_bodies": ["    ans = []\n    for i in range(n):\n        if i < 2:\n            m = i + 1\n        elif i % 2 == 1:\n            m = ans[i - 2] + i + (i + 1)\n        else:\n            m = ans[i - 2] * i * (i + 1)\n        ans.append(m)\n\n    return ans"], "sol_header": "def sol(n=267):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)\n\n    5 => [1, 2, 6, 9, 120]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=267):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True", "input": "def sat(li: List[int], n=267):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "AlternatingFactorials:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#106", "sol_bodies": ["    ans = []\n    for i in range(n):\n        if i < 2:\n            m = i + 1\n        elif i % 2 == 1:\n            m = ans[i - 2] + i + (i + 1)\n        else:\n            m = ans[i - 2] * i * (i + 1)\n        ans.append(m)\n\n    return ans"], "sol_header": "def sol(n=576):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)\n\n    5 => [1, 2, 6, 9, 120]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=576):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True", "input": "def sat(li: List[int], n=576):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "EvenPalindromeNumbers:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#107", "sol_bodies": ["    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]"], "sol_header": "def sol(n=1099, count=49):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all even palindromes up to n\n\n    3 => [0, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pals: List[int], n=1099, count=49):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count", "input": "def sat(pals: List[int], n=1099, count=49):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count", "target": ""}
{"module": "human_eval.py", "name": "EvenPalindromeNumbers:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#107", "sol_bodies": ["    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]"], "sol_header": "def sol(n=2737, count=56):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all even palindromes up to n\n\n    3 => [0, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pals: List[int], n=2737, count=56):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count", "input": "def sat(pals: List[int], n=2737, count=56):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count", "target": ""}
{"module": "human_eval.py", "name": "EvenPalindromeNumbers:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#107", "sol_bodies": ["    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]"], "sol_header": "def sol(n=7895, count=79):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all even palindromes up to n\n\n    3 => [0, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pals: List[int], n=7895, count=79):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count", "input": "def sat(pals: List[int], n=7895, count=79):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count", "target": ""}
{"module": "human_eval.py", "name": "EvenPalindromeNumbers:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#107", "sol_bodies": ["    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]"], "sol_header": "def sol(n=2645, count=55):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all even palindromes up to n\n\n    3 => [0, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pals: List[int], n=2645, count=55):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count", "input": "def sat(pals: List[int], n=2645, count=55):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count", "target": ""}
{"module": "human_eval.py", "name": "EvenPalindromeNumbers:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#107", "sol_bodies": ["    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]"], "sol_header": "def sol(n=3173, count=59):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find all even palindromes up to n\n\n    3 => [0, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pals: List[int], n=3173, count=59):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count", "input": "def sat(pals: List[int], n=3173, count=59):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count", "target": ""}
{"module": "human_eval.py", "name": "PositiveDigitSums:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#108", "sol_bodies": ["    def bad(n):\n        s = str(n)\n        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0\n\n    return [n for n in nums if not bad(n)]"], "sol_header": "def sol(nums=[-804, 9124, -945, 2410, 0, 21, -123]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.\n\n    [12, -7, -102, -100] => [12, -102]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pos: List[int], nums=[-804, 9124, -945, 2410, 0, 21, -123]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True", "input": "def sat(pos: List[int], nums=[-804, 9124, -945, 2410, 0, 21, -123]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "PositiveDigitSums:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#108", "sol_bodies": ["    def bad(n):\n        s = str(n)\n        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0\n\n    return [n for n in nums if not bad(n)]"], "sol_header": "def sol(nums=[3885, -46840, -82208, 35161, -84028]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.\n\n    [12, -7, -102, -100] => [12, -102]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pos: List[int], nums=[3885, -46840, -82208, 35161, -84028]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True", "input": "def sat(pos: List[int], nums=[3885, -46840, -82208, 35161, -84028]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "PositiveDigitSums:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#108", "sol_bodies": ["    def bad(n):\n        s = str(n)\n        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0\n\n    return [n for n in nums if not bad(n)]"], "sol_header": "def sol(nums=[42550, -7024, -90058]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.\n\n    [12, -7, -102, -100] => [12, -102]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pos: List[int], nums=[42550, -7024, -90058]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True", "input": "def sat(pos: List[int], nums=[42550, -7024, -90058]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "PositiveDigitSums:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#108", "sol_bodies": ["    def bad(n):\n        s = str(n)\n        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0\n\n    return [n for n in nums if not bad(n)]"], "sol_header": "def sol(nums=[39739, -37931, -68285, -32414]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.\n\n    [12, -7, -102, -100] => [12, -102]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pos: List[int], nums=[39739, -37931, -68285, -32414]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True", "input": "def sat(pos: List[int], nums=[39739, -37931, -68285, -32414]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "PositiveDigitSums:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#108", "sol_bodies": ["    def bad(n):\n        s = str(n)\n        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0\n\n    return [n for n in nums if not bad(n)]"], "sol_header": "def sol(nums=[26162, -47643, -37426]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.\n\n    [12, -7, -102, -100] => [12, -102]\n    \"\"\"", "weight": 1.0, "sat": "def sat(pos: List[int], nums=[26162, -47643, -37426]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True", "input": "def sat(pos: List[int], nums=[26162, -47643, -37426]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "RotateSort:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#109\n\nThis puzzle (and RotateString from #154) use the fact that a string is a rotation of r if it is a substring of r+r", "sol_bodies": ["    def sat(near):\n        order_violations = 0\n        erasures = 0\n        for i, n in enumerate(near):\n            if n < near[i - 1]:  # -1 when i =0 gives last element\n                order_violations += 1\n            while n != arr[i + erasures]:\n                erasures += 1\n        return order_violations <= 1 and erasures <= 1\n\n    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]\n    return next(near for near in candidates if sat(near))"], "sol_header": "def sol(arr=[2, 3, -1, -1, 0, 1, 1]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    An array is ring-sorted if it is a \"rotation\" of a non-decreasing list.\n    Remove at most one element from arr to make it ring-sorted.\n\n    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(original: List[int], arr=[2, 3, -1, -1, 0, 1, 1]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))", "input": "def sat(original: List[int], arr=[2, 3, -1, -1, 0, 1, 1]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))", "target": ""}
{"module": "human_eval.py", "name": "RotateSort:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#109\n\nThis puzzle (and RotateString from #154) use the fact that a string is a rotation of r if it is a substring of r+r", "sol_bodies": ["    def sat(near):\n        order_violations = 0\n        erasures = 0\n        for i, n in enumerate(near):\n            if n < near[i - 1]:  # -1 when i =0 gives last element\n                order_violations += 1\n            while n != arr[i + erasures]:\n                erasures += 1\n        return order_violations <= 1 and erasures <= 1\n\n    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]\n    return next(near for near in candidates if sat(near))"], "sol_header": "def sol(arr=[2, 3, 3, 5, 6, 0]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    An array is ring-sorted if it is a \"rotation\" of a non-decreasing list.\n    Remove at most one element from arr to make it ring-sorted.\n\n    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(original: List[int], arr=[2, 3, 3, 5, 6, 0]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))", "input": "def sat(original: List[int], arr=[2, 3, 3, 5, 6, 0]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))", "target": ""}
{"module": "human_eval.py", "name": "RotateSort:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#109\n\nThis puzzle (and RotateString from #154) use the fact that a string is a rotation of r if it is a substring of r+r", "sol_bodies": ["    def sat(near):\n        order_violations = 0\n        erasures = 0\n        for i, n in enumerate(near):\n            if n < near[i - 1]:  # -1 when i =0 gives last element\n                order_violations += 1\n            while n != arr[i + erasures]:\n                erasures += 1\n        return order_violations <= 1 and erasures <= 1\n\n    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]\n    return next(near for near in candidates if sat(near))"], "sol_header": "def sol(arr=[3, 5]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    An array is ring-sorted if it is a \"rotation\" of a non-decreasing list.\n    Remove at most one element from arr to make it ring-sorted.\n\n    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(original: List[int], arr=[3, 5]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))", "input": "def sat(original: List[int], arr=[3, 5]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))", "target": ""}
{"module": "human_eval.py", "name": "RotateSort:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#109\n\nThis puzzle (and RotateString from #154) use the fact that a string is a rotation of r if it is a substring of r+r", "sol_bodies": ["    def sat(near):\n        order_violations = 0\n        erasures = 0\n        for i, n in enumerate(near):\n            if n < near[i - 1]:  # -1 when i =0 gives last element\n                order_violations += 1\n            while n != arr[i + erasures]:\n                erasures += 1\n        return order_violations <= 1 and erasures <= 1\n\n    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]\n    return next(near for near in candidates if sat(near))"], "sol_header": "def sol(arr=[3, 7, 3, 6, 6, 8, 9, 0, 0, 1]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    An array is ring-sorted if it is a \"rotation\" of a non-decreasing list.\n    Remove at most one element from arr to make it ring-sorted.\n\n    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(original: List[int], arr=[3, 7, 3, 6, 6, 8, 9, 0, 0, 1]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))", "input": "def sat(original: List[int], arr=[3, 7, 3, 6, 6, 8, 9, 0, 0, 1]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))", "target": ""}
{"module": "human_eval.py", "name": "RotateSort:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#109\n\nThis puzzle (and RotateString from #154) use the fact that a string is a rotation of r if it is a substring of r+r", "sol_bodies": ["    def sat(near):\n        order_violations = 0\n        erasures = 0\n        for i, n in enumerate(near):\n            if n < near[i - 1]:  # -1 when i =0 gives last element\n                order_violations += 1\n            while n != arr[i + erasures]:\n                erasures += 1\n        return order_violations <= 1 and erasures <= 1\n\n    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]\n    return next(near for near in candidates if sat(near))"], "sol_header": "def sol(arr=[3, 2, 6, 7, 7, 8, 3]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    An array is ring-sorted if it is a \"rotation\" of a non-decreasing list.\n    Remove at most one element from arr to make it ring-sorted.\n\n    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]\n    \"\"\"", "weight": 1.0, "sat": "def sat(original: List[int], arr=[3, 2, 6, 7, 7, 8, 3]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))", "input": "def sat(original: List[int], arr=[3, 2, 6, 7, 7, 8, 3]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))", "target": ""}
{"module": "human_eval.py", "name": "ParityExchange:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#110", "sol_bodies": ["    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]\n    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]\n    return [[i, j] for i, j in zip(odds, evens)]"], "sol_header": "def sol(nums1=[1, 3, 2, 4, 5, 8, 7, 11], nums2=[0, 7, 0, 8, 19, 4, 41, 43, 42]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the\n    first list are even\n\n    [1, 3, 4] [2, 4, 5] => [0, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(swaps: List[List[int]], nums1=[1, 3, 2, 4, 5, 8, 7, 11], nums2=[0, 7, 0, 8, 19, 4, 41, 43, 42]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)", "input": "def sat(swaps: List[List[int]], nums1=[1, 3, 2, 4, 5, 8, 7, 11], nums2=[0, 7, 0, 8, 19, 4, 41, 43, 42]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)", "target": ""}
{"module": "human_eval.py", "name": "ParityExchange:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#110", "sol_bodies": ["    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]\n    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]\n    return [[i, j] for i, j in zip(odds, evens)]"], "sol_header": "def sol(nums1=[-4, -8, -10, -6, 0, -3, -7, 5], nums2=[-6, 6, -8, -7, -7]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the\n    first list are even\n\n    [1, 3, 4] [2, 4, 5] => [0, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(swaps: List[List[int]], nums1=[-4, -8, -10, -6, 0, -3, -7, 5], nums2=[-6, 6, -8, -7, -7]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)", "input": "def sat(swaps: List[List[int]], nums1=[-4, -8, -10, -6, 0, -3, -7, 5], nums2=[-6, 6, -8, -7, -7]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)", "target": ""}
{"module": "human_eval.py", "name": "ParityExchange:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#110", "sol_bodies": ["    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]\n    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]\n    return [[i, j] for i, j in zip(odds, evens)]"], "sol_header": "def sol(nums1=[8, -5, -4], nums2=[3, 1, 4, -3, 5, 7]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the\n    first list are even\n\n    [1, 3, 4] [2, 4, 5] => [0, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(swaps: List[List[int]], nums1=[8, -5, -4], nums2=[3, 1, 4, -3, 5, 7]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)", "input": "def sat(swaps: List[List[int]], nums1=[8, -5, -4], nums2=[3, 1, 4, -3, 5, 7]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)", "target": ""}
{"module": "human_eval.py", "name": "ParityExchange:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#110", "sol_bodies": ["    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]\n    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]\n    return [[i, j] for i, j in zip(odds, evens)]"], "sol_header": "def sol(nums1=[-8, -6], nums2=[9, -4, 0, 9, -6, -5, -4, 3, -3]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the\n    first list are even\n\n    [1, 3, 4] [2, 4, 5] => [0, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(swaps: List[List[int]], nums1=[-8, -6], nums2=[9, -4, 0, 9, -6, -5, -4, 3, -3]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)", "input": "def sat(swaps: List[List[int]], nums1=[-8, -6], nums2=[9, -4, 0, 9, -6, -5, -4, 3, -3]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)", "target": ""}
{"module": "human_eval.py", "name": "ParityExchange:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#110", "sol_bodies": ["    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]\n    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]\n    return [[i, j] for i, j in zip(odds, evens)]"], "sol_header": "def sol(nums1=[-6, -2, 8, -4, -8, 0, 8, -3, 8], nums2=[0]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the\n    first list are even\n\n    [1, 3, 4] [2, 4, 5] => [0, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(swaps: List[List[int]], nums1=[-6, -2, 8, -4, -8, 0, 8, -3, 8], nums2=[0]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)", "input": "def sat(swaps: List[List[int]], nums1=[-6, -2, 8, -4, -8, 0, 8, -3, 8], nums2=[0]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)", "target": ""}
{"module": "human_eval.py", "name": "CharCounts:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#111", "sol_bodies": ["    return \" \".join(c for c, i in counts.items() for _ in range(i))"], "sol_header": "def sol(counts={'a': 4, 'b': 17, 'd': 101, 'e': 0, 'f': 12}):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string consisting of space-separated characters with given counts\n\n    {\"f\": 1, \"o\": 2} => \"oof\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, counts={'a': 4, 'b': 17, 'd': 101, 'e': 0, 'f': 12}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())", "input": "def sat(s: str, counts={'a': 4, 'b': 17, 'd': 101, 'e': 0, 'f': 12}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())", "target": ""}
{"module": "human_eval.py", "name": "CharCounts:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#111", "sol_bodies": ["    return \" \".join(c for c, i in counts.items() for _ in range(i))"], "sol_header": "def sol(counts={'z': 0, 'e': 0, 'd': 7, 'o': 3, 'y': 8, 'w': 3, 'a': 0}):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string consisting of space-separated characters with given counts\n\n    {\"f\": 1, \"o\": 2} => \"oof\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, counts={'z': 0, 'e': 0, 'd': 7, 'o': 3, 'y': 8, 'w': 3, 'a': 0}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())", "input": "def sat(s: str, counts={'z': 0, 'e': 0, 'd': 7, 'o': 3, 'y': 8, 'w': 3, 'a': 0}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())", "target": ""}
{"module": "human_eval.py", "name": "CharCounts:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#111", "sol_bodies": ["    return \" \".join(c for c, i in counts.items() for _ in range(i))"], "sol_header": "def sol(counts={'s': 8, 'z': 6, 'd': 1, 'o': 6}):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string consisting of space-separated characters with given counts\n\n    {\"f\": 1, \"o\": 2} => \"oof\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, counts={'s': 8, 'z': 6, 'd': 1, 'o': 6}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())", "input": "def sat(s: str, counts={'s': 8, 'z': 6, 'd': 1, 'o': 6}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())", "target": ""}
{"module": "human_eval.py", "name": "CharCounts:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#111", "sol_bodies": ["    return \" \".join(c for c, i in counts.items() for _ in range(i))"], "sol_header": "def sol(counts={'c': 5, 'p': 6, 'j': 0, 'g': 1, 'w': 4, 'k': 8}):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string consisting of space-separated characters with given counts\n\n    {\"f\": 1, \"o\": 2} => \"oof\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, counts={'c': 5, 'p': 6, 'j': 0, 'g': 1, 'w': 4, 'k': 8}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())", "input": "def sat(s: str, counts={'c': 5, 'p': 6, 'j': 0, 'g': 1, 'w': 4, 'k': 8}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())", "target": ""}
{"module": "human_eval.py", "name": "CharCounts:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#111", "sol_bodies": ["    return \" \".join(c for c, i in counts.items() for _ in range(i))"], "sol_header": "def sol(counts={'c': 2}):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string consisting of space-separated characters with given counts\n\n    {\"f\": 1, \"o\": 2} => \"oof\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, counts={'c': 2}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())", "input": "def sat(s: str, counts={'c': 2}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())", "target": ""}
{"module": "human_eval.py", "name": "DelPalindrome:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#112", "sol_bodies": ["    s = \"\".join(c for c in a if c not in b)\n    return [s, str(s == s[::-1])]"], "sol_header": "def sol(a=\"this is a test\", b=\"cat\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Return a pair of a strings where the first string is the same as a with all the characters of b removed,\n    and the second string is 'True' if this string is a palindrome otherwise 'False'.\n\n    a=\"madam, I'm adam.\" b = \"Yes, we're here.\" => ['madamImadam', 'True']\n    \"\"\"", "weight": 1.0, "sat": "def sat(strings: List[str], a=\"this is a test\", b=\"cat\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])", "input": "def sat(strings: List[str], a=\"this is a test\", b=\"cat\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])", "target": ""}
{"module": "human_eval.py", "name": "DelPalindrome:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#112", "sol_bodies": ["    s = \"\".join(c for c in a if c not in b)\n    return [s, str(s == s[::-1])]"], "sol_header": "def sol(a=\"vochemogogajesuxujefobemenepejyquizys\", b=\"te\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Return a pair of a strings where the first string is the same as a with all the characters of b removed,\n    and the second string is 'True' if this string is a palindrome otherwise 'False'.\n\n    a=\"madam, I'm adam.\" b = \"Yes, we're here.\" => ['madamImadam', 'True']\n    \"\"\"", "weight": 1.0, "sat": "def sat(strings: List[str], a=\"vochemogogajesuxujefobemenepejyquizys\", b=\"te\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])", "input": "def sat(strings: List[str], a=\"vochemogogajesuxujefobemenepejyquizys\", b=\"te\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])", "target": ""}
{"module": "human_eval.py", "name": "DelPalindrome:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#112", "sol_bodies": ["    s = \"\".join(c for c in a if c not in b)\n    return [s, str(s == s[::-1])]"], "sol_header": "def sol(a=\"tagodecequyzafiwathegothatymuzabegelelathe\", b=\"wululizokiwa\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Return a pair of a strings where the first string is the same as a with all the characters of b removed,\n    and the second string is 'True' if this string is a palindrome otherwise 'False'.\n\n    a=\"madam, I'm adam.\" b = \"Yes, we're here.\" => ['madamImadam', 'True']\n    \"\"\"", "weight": 1.0, "sat": "def sat(strings: List[str], a=\"tagodecequyzafiwathegothatymuzabegelelathe\", b=\"wululizokiwa\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])", "input": "def sat(strings: List[str], a=\"tagodecequyzafiwathegothatymuzabegelelathe\", b=\"wululizokiwa\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])", "target": ""}
{"module": "human_eval.py", "name": "DelPalindrome:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#112", "sol_bodies": ["    s = \"\".join(c for c in a if c not in b)\n    return [s, str(s == s[::-1])]"], "sol_header": "def sol(a=\"sipylovegubequagujete\", b=\"doh\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Return a pair of a strings where the first string is the same as a with all the characters of b removed,\n    and the second string is 'True' if this string is a palindrome otherwise 'False'.\n\n    a=\"madam, I'm adam.\" b = \"Yes, we're here.\" => ['madamImadam', 'True']\n    \"\"\"", "weight": 1.0, "sat": "def sat(strings: List[str], a=\"sipylovegubequagujete\", b=\"doh\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])", "input": "def sat(strings: List[str], a=\"sipylovegubequagujete\", b=\"doh\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])", "target": ""}
{"module": "human_eval.py", "name": "DelPalindrome:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#112", "sol_bodies": ["    s = \"\".join(c for c in a if c not in b)\n    return [s, str(s == s[::-1])]"], "sol_header": "def sol(a=\"fodivahug\", b=\"ne\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Return a pair of a strings where the first string is the same as a with all the characters of b removed,\n    and the second string is 'True' if this string is a palindrome otherwise 'False'.\n\n    a=\"madam, I'm adam.\" b = \"Yes, we're here.\" => ['madamImadam', 'True']\n    \"\"\"", "weight": 1.0, "sat": "def sat(strings: List[str], a=\"fodivahug\", b=\"ne\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])", "input": "def sat(strings: List[str], a=\"fodivahug\", b=\"ne\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])", "target": ""}
{"module": "human_eval.py", "name": "BinarySort:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#116", "sol_bodies": ["    return sorted(arr, key=lambda n: bin(n).count(\"1\"))"], "sol_header": "def sol(arr=[4, 2, 3, -1, 15, 2, 6, 9, 5, 16, 1048576]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Sort the numbers in arr based on the number of 1's in their binary representation.\n\n    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ordered: List[int], arr=[4, 2, 3, -1, 15, 2, 6, 9, 5, 16, 1048576]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))", "input": "def sat(ordered: List[int], arr=[4, 2, 3, -1, 15, 2, 6, 9, 5, 16, 1048576]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))", "target": ""}
{"module": "human_eval.py", "name": "BinarySort:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#116", "sol_bodies": ["    return sorted(arr, key=lambda n: bin(n).count(\"1\"))"], "sol_header": "def sol(arr=[19, 47, -51, 40, 6, 0, 41, 57, 13, 16, -27, 7]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Sort the numbers in arr based on the number of 1's in their binary representation.\n\n    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ordered: List[int], arr=[19, 47, -51, 40, 6, 0, 41, 57, 13, 16, -27, 7]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))", "input": "def sat(ordered: List[int], arr=[19, 47, -51, 40, 6, 0, 41, 57, 13, 16, -27, 7]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))", "target": ""}
{"module": "human_eval.py", "name": "BinarySort:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#116", "sol_bodies": ["    return sorted(arr, key=lambda n: bin(n).count(\"1\"))"], "sol_header": "def sol(arr=[62, 63, 1]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Sort the numbers in arr based on the number of 1's in their binary representation.\n\n    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ordered: List[int], arr=[62, 63, 1]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))", "input": "def sat(ordered: List[int], arr=[62, 63, 1]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))", "target": ""}
{"module": "human_eval.py", "name": "BinarySort:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#116", "sol_bodies": ["    return sorted(arr, key=lambda n: bin(n).count(\"1\"))"], "sol_header": "def sol(arr=[-9, -78, -17, 42, 85, 79, 61]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Sort the numbers in arr based on the number of 1's in their binary representation.\n\n    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ordered: List[int], arr=[-9, -78, -17, 42, 85, 79, 61]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))", "input": "def sat(ordered: List[int], arr=[-9, -78, -17, 42, 85, 79, 61]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))", "target": ""}
{"module": "human_eval.py", "name": "BinarySort:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#116", "sol_bodies": ["    return sorted(arr, key=lambda n: bin(n).count(\"1\"))"], "sol_header": "def sol(arr=[-65, -6, 82, -85, -84, 97, 55, 54]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Sort the numbers in arr based on the number of 1's in their binary representation.\n\n    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ordered: List[int], arr=[-65, -6, 82, -85, -84, 97, 55, 54]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))", "input": "def sat(ordered: List[int], arr=[-65, -6, 82, -85, -84, 97, 55, 54]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))", "target": ""}
{"module": "human_eval.py", "name": "ConsonantFilter:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#117", "sol_bodies": ["    return [w for w in s.split() if sum(c.lower() not in \"aeiou\" for c in w) == n]"], "sol_header": "def sol(s=\"This is not a very hard puzzle\", n=3):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find all words in the string with n consonants\n\n    Sample input:\n    s=\"An eye for an I\", n=1\n    Sample output:\n    [\"An\", \"eye\", \"an\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(words: List[str], s=\"This is not a very hard puzzle\", n=3):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)", "input": "def sat(words: List[str], s=\"This is not a very hard puzzle\", n=3):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)", "target": ""}
{"module": "human_eval.py", "name": "ConsonantFilter:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#117", "sol_bodies": ["    return [w for w in s.split() if sum(c.lower() not in \"aeiou\" for c in w) == n]"], "sol_header": "def sol(s=\"xopike tha textufuzowapa xaxiweborite dutextequuch metojylucazasysebi wy\", n=5):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find all words in the string with n consonants\n\n    Sample input:\n    s=\"An eye for an I\", n=1\n    Sample output:\n    [\"An\", \"eye\", \"an\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(words: List[str], s=\"xopike tha textufuzowapa xaxiweborite dutextequuch metojylucazasysebi wy\", n=5):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)", "input": "def sat(words: List[str], s=\"xopike tha textufuzowapa xaxiweborite dutextequuch metojylucazasysebi wy\", n=5):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)", "target": ""}
{"module": "human_eval.py", "name": "ConsonantFilter:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#117", "sol_bodies": ["    return [w for w in s.split() if sum(c.lower() not in \"aeiou\" for c in w) == n]"], "sol_header": "def sol(s=\"tihyc pydykosisaroquicoc text\", n=6):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find all words in the string with n consonants\n\n    Sample input:\n    s=\"An eye for an I\", n=1\n    Sample output:\n    [\"An\", \"eye\", \"an\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(words: List[str], s=\"tihyc pydykosisaroquicoc text\", n=6):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)", "input": "def sat(words: List[str], s=\"tihyc pydykosisaroquicoc text\", n=6):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)", "target": ""}
{"module": "human_eval.py", "name": "ConsonantFilter:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#117", "sol_bodies": ["    return [w for w in s.split() if sum(c.lower() not in \"aeiou\" for c in w) == n]"], "sol_header": "def sol(s=\"chalejugedijypiq jypityvekifate mobekolupumymikana quaxizot vurikojithokasatuka teragusaculi vyceth dachaci wu\", n=1):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find all words in the string with n consonants\n\n    Sample input:\n    s=\"An eye for an I\", n=1\n    Sample output:\n    [\"An\", \"eye\", \"an\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(words: List[str], s=\"chalejugedijypiq jypityvekifate mobekolupumymikana quaxizot vurikojithokasatuka teragusaculi vyceth dachaci wu\", n=1):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)", "input": "def sat(words: List[str], s=\"chalejugedijypiq jypityvekifate mobekolupumymikana quaxizot vurikojithokasatuka teragusaculi vyceth dachaci wu\", n=1):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)", "target": ""}
{"module": "human_eval.py", "name": "ConsonantFilter:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#117", "sol_bodies": ["    return [w for w in s.split() if sum(c.lower() not in \"aeiou\" for c in w) == n]"], "sol_header": "def sol(s=\"thigafamyhuchykikoxe limyb wy textitextomyc regolathagychiby pep\", n=2):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find all words in the string with n consonants\n\n    Sample input:\n    s=\"An eye for an I\", n=1\n    Sample output:\n    [\"An\", \"eye\", \"an\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(words: List[str], s=\"thigafamyhuchykikoxe limyb wy textitextomyc regolathagychiby pep\", n=2):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)", "input": "def sat(words: List[str], s=\"thigafamyhuchykikoxe limyb wy textitextomyc regolathagychiby pep\", n=2):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)", "target": ""}
{"module": "human_eval.py", "name": "VowelSandwich:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#118", "sol_bodies": ["    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)\n                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)"], "sol_header": "def sol(s=\"Any vowel is OK\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s\n\n    \"sandwhich\" => \"hic\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ham: str, s=\"Any vowel is OK\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons", "input": "def sat(ham: str, s=\"Any vowel is OK\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons", "target": ""}
{"module": "human_eval.py", "name": "VowelSandwich:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#118", "sol_bodies": ["    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)\n                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)"], "sol_header": "def sol(s=\"wOwwwww!\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s\n\n    \"sandwhich\" => \"hic\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ham: str, s=\"wOwwwww!\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons", "input": "def sat(ham: str, s=\"wOwwwww!\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons", "target": ""}
{"module": "human_eval.py", "name": "VowelSandwich:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#118", "sol_bodies": ["    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)\n                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)"], "sol_header": "def sol(s=\"do pyp you know ?\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s\n\n    \"sandwhich\" => \"hic\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ham: str, s=\"do pyp you know ?\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons", "input": "def sat(ham: str, s=\"do pyp you know ?\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons", "target": ""}
{"module": "human_eval.py", "name": "VowelSandwich:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#118", "sol_bodies": ["    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)\n                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)"], "sol_header": "def sol(s=\"zocofiwihilyfizi ku pivanydebodygawepu nyfanusocosypinezaz pune\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s\n\n    \"sandwhich\" => \"hic\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ham: str, s=\"zocofiwihilyfizi ku pivanydebodygawepu nyfanusocosypinezaz pune\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons", "input": "def sat(ham: str, s=\"zocofiwihilyfizi ku pivanydebodygawepu nyfanusocosypinezaz pune\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons", "target": ""}
{"module": "human_eval.py", "name": "VowelSandwich:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#118", "sol_bodies": ["    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)\n                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)"], "sol_header": "def sol(s=\"citextitozuwatextoq hutextawicogylalex wi wamu\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s\n\n    \"sandwhich\" => \"hic\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(ham: str, s=\"citextitozuwatextoq hutextawicogylalex wi wamu\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons", "input": "def sat(ham: str, s=\"citextitozuwatextoq hutextawicogylalex wi wamu\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons", "target": ""}
{"module": "human_eval.py", "name": "ParenthesesPermutation:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#119\n    \nThis is harder version in which you need to find a permutation of many substrings. Brute force is too slow.", "sol_bodies": ["    assert all(c in \"( )\" for c in s)\n    parts = s.split()\n\n    def min_depth(part):\n        \"\"\"Returns the lowest depth <= 0\"\"\"\n        ans = 0\n        depth = 0\n        for c in part:\n            if c == \")\":\n                depth -= 1\n                ans = min(ans, depth)\n            else:\n                depth += 1\n        return ans\n\n    def greedy_reorder(subs):\n        \"\"\"Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s \"\"\"\n        queue = subs[:]\n        subs[:] = []\n        height = 0\n        while queue:\n            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count(\"(\") - s.count(\")\"))\n            height += best.count(\"(\") - best.count(\")\")\n            subs.append(best)\n            queue.remove(best)\n\n    lefts = [s for s in parts if s.count(\"(\") >= s.count(\")\")]\n\n    greedy_reorder(lefts)\n\n    def mirror(sub):\n        return \"\".join(\")\" if c == \"(\" else \"(\" for c in sub[::-1])\n\n    rights = [mirror(s) for s in parts if s.count(\"(\") < s.count(\")\")]  # mirror temporarily for reordering\n\n    greedy_reorder(rights)\n    return \" \".join(lefts + [mirror(s) for s in rights[::-1]])"], "sol_header": "def sol(s=\"))(  )()()() )))(( ))))((( )))))(((( ))))))))((((((( ))))))((((( )))))))(((((( )))))))))(((((((  ((((((((((\"):", "ans_type": "str", "sol_docstring": "    \"\"\"The string s consists of groups of parentheses separated by spaces.\n    Permute the groups such that the parentheses match.\n\n    \"( ) )(\" => \"( )( )\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(perm: str, s=\"))(  )()()() )))(( ))))((( )))))(((( ))))))))((((((( ))))))((((( )))))))(((((( )))))))))(((((((  ((((((((((\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))", "input": "def sat(perm: str, s=\"))(  )()()() )))(( ))))((( )))))(((( ))))))))((((((( ))))))((((( )))))))(((((( )))))))))(((((((  ((((((((((\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))", "target": ""}
{"module": "human_eval.py", "name": "ParenthesesPermutation:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#119\n    \nThis is harder version in which you need to find a permutation of many substrings. Brute force is too slow.", "sol_bodies": ["    assert all(c in \"( )\" for c in s)\n    parts = s.split()\n\n    def min_depth(part):\n        \"\"\"Returns the lowest depth <= 0\"\"\"\n        ans = 0\n        depth = 0\n        for c in part:\n            if c == \")\":\n                depth -= 1\n                ans = min(ans, depth)\n            else:\n                depth += 1\n        return ans\n\n    def greedy_reorder(subs):\n        \"\"\"Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s \"\"\"\n        queue = subs[:]\n        subs[:] = []\n        height = 0\n        while queue:\n            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count(\"(\") - s.count(\")\"))\n            height += best.count(\"(\") - best.count(\")\")\n            subs.append(best)\n            queue.remove(best)\n\n    lefts = [s for s in parts if s.count(\"(\") >= s.count(\")\")]\n\n    greedy_reorder(lefts)\n\n    def mirror(sub):\n        return \"\".join(\")\" if c == \"(\" else \"(\" for c in sub[::-1])\n\n    rights = [mirror(s) for s in parts if s.count(\"(\") < s.count(\")\")]  # mirror temporarily for reordering\n\n    greedy_reorder(rights)\n    return \" \".join(lefts + [mirror(s) for s in rights[::-1]])"], "sol_header": "def sol(s=\" (( ()(())())() ())(())))(()()) (((((((()(()))(( ()()))) )())))) ()()()(((())()\"):", "ans_type": "str", "sol_docstring": "    \"\"\"The string s consists of groups of parentheses separated by spaces.\n    Permute the groups such that the parentheses match.\n\n    \"( ) )(\" => \"( )( )\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(perm: str, s=\" (( ()(())())() ())(())))(()()) (((((((()(()))(( ()()))) )())))) ()()()(((())()\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))", "input": "def sat(perm: str, s=\" (( ()(())())() ())(())))(()()) (((((((()(()))(( ()()))) )())))) ()()()(((())()\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))", "target": ""}
{"module": "human_eval.py", "name": "ParenthesesPermutation:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#119\n    \nThis is harder version in which you need to find a permutation of many substrings. Brute force is too slow.", "sol_bodies": ["    assert all(c in \"( )\" for c in s)\n    parts = s.split()\n\n    def min_depth(part):\n        \"\"\"Returns the lowest depth <= 0\"\"\"\n        ans = 0\n        depth = 0\n        for c in part:\n            if c == \")\":\n                depth -= 1\n                ans = min(ans, depth)\n            else:\n                depth += 1\n        return ans\n\n    def greedy_reorder(subs):\n        \"\"\"Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s \"\"\"\n        queue = subs[:]\n        subs[:] = []\n        height = 0\n        while queue:\n            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count(\"(\") - s.count(\")\"))\n            height += best.count(\"(\") - best.count(\")\")\n            subs.append(best)\n            queue.remove(best)\n\n    lefts = [s for s in parts if s.count(\"(\") >= s.count(\")\")]\n\n    greedy_reorder(lefts)\n\n    def mirror(sub):\n        return \"\".join(\")\" if c == \"(\" else \"(\" for c in sub[::-1])\n\n    rights = [mirror(s) for s in parts if s.count(\"(\") < s.count(\")\")]  # mirror temporarily for reordering\n\n    greedy_reorder(rights)\n    return \" \".join(lefts + [mirror(s) for s in rights[::-1]])"], "sol_header": "def sol(s=\"()()(( ))\"):", "ans_type": "str", "sol_docstring": "    \"\"\"The string s consists of groups of parentheses separated by spaces.\n    Permute the groups such that the parentheses match.\n\n    \"( ) )(\" => \"( )( )\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(perm: str, s=\"()()(( ))\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))", "input": "def sat(perm: str, s=\"()()(( ))\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))", "target": ""}
{"module": "human_eval.py", "name": "ParenthesesPermutation:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#119\n    \nThis is harder version in which you need to find a permutation of many substrings. Brute force is too slow.", "sol_bodies": ["    assert all(c in \"( )\" for c in s)\n    parts = s.split()\n\n    def min_depth(part):\n        \"\"\"Returns the lowest depth <= 0\"\"\"\n        ans = 0\n        depth = 0\n        for c in part:\n            if c == \")\":\n                depth -= 1\n                ans = min(ans, depth)\n            else:\n                depth += 1\n        return ans\n\n    def greedy_reorder(subs):\n        \"\"\"Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s \"\"\"\n        queue = subs[:]\n        subs[:] = []\n        height = 0\n        while queue:\n            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count(\"(\") - s.count(\")\"))\n            height += best.count(\"(\") - best.count(\")\")\n            subs.append(best)\n            queue.remove(best)\n\n    lefts = [s for s in parts if s.count(\"(\") >= s.count(\")\")]\n\n    greedy_reorder(lefts)\n\n    def mirror(sub):\n        return \"\".join(\")\" if c == \"(\" else \"(\" for c in sub[::-1])\n\n    rights = [mirror(s) for s in parts if s.count(\"(\") < s.count(\")\")]  # mirror temporarily for reordering\n\n    greedy_reorder(rights)\n    return \" \".join(lefts + [mirror(s) for s in rights[::-1]])"], "sol_header": "def sol(s=\"\"):", "ans_type": "str", "sol_docstring": "    \"\"\"The string s consists of groups of parentheses separated by spaces.\n    Permute the groups such that the parentheses match.\n\n    \"( ) )(\" => \"( )( )\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(perm: str, s=\"\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))", "input": "def sat(perm: str, s=\"\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))", "target": ""}
{"module": "human_eval.py", "name": "ParenthesesPermutation:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#119\n    \nThis is harder version in which you need to find a permutation of many substrings. Brute force is too slow.", "sol_bodies": ["    assert all(c in \"( )\" for c in s)\n    parts = s.split()\n\n    def min_depth(part):\n        \"\"\"Returns the lowest depth <= 0\"\"\"\n        ans = 0\n        depth = 0\n        for c in part:\n            if c == \")\":\n                depth -= 1\n                ans = min(ans, depth)\n            else:\n                depth += 1\n        return ans\n\n    def greedy_reorder(subs):\n        \"\"\"Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s \"\"\"\n        queue = subs[:]\n        subs[:] = []\n        height = 0\n        while queue:\n            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count(\"(\") - s.count(\")\"))\n            height += best.count(\"(\") - best.count(\")\")\n            subs.append(best)\n            queue.remove(best)\n\n    lefts = [s for s in parts if s.count(\"(\") >= s.count(\")\")]\n\n    greedy_reorder(lefts)\n\n    def mirror(sub):\n        return \"\".join(\")\" if c == \"(\" else \"(\" for c in sub[::-1])\n\n    rights = [mirror(s) for s in parts if s.count(\"(\") < s.count(\")\")]  # mirror temporarily for reordering\n\n    greedy_reorder(rights)\n    return \" \".join(lefts + [mirror(s) for s in rights[::-1]])"], "sol_header": "def sol(s=\"()(()())( )()\"):", "ans_type": "str", "sol_docstring": "    \"\"\"The string s consists of groups of parentheses separated by spaces.\n    Permute the groups such that the parentheses match.\n\n    \"( ) )(\" => \"( )( )\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(perm: str, s=\"()(()())( )()\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))", "input": "def sat(perm: str, s=\"()(()())( )()\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))", "target": ""}
{"module": "human_eval.py", "name": "BiggestK:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#120", "sol_bodies": ["    return sorted(nums, reverse=True)[:k]"], "sol_header": "def sol(k=7, nums=[31, 1, 2, -10, -2, 4, 17, 18, 20, 14, 20, 21, 18, 0]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the largest k numbers\n\n    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(biggest: List[int], k=7, nums=[31, 1, 2, -10, -2, 4, 17, 18, 20, 14, 20, 21, 18, 0]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)", "input": "def sat(biggest: List[int], k=7, nums=[31, 1, 2, -10, -2, 4, 17, 18, 20, 14, 20, 21, 18, 0]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)", "target": ""}
{"module": "human_eval.py", "name": "BiggestK:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#120", "sol_bodies": ["    return sorted(nums, reverse=True)[:k]"], "sol_header": "def sol(k=3, nums=[-5, 30, 31, 32, 30, 93, 97]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the largest k numbers\n\n    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(biggest: List[int], k=3, nums=[-5, 30, 31, 32, 30, 93, 97]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)", "input": "def sat(biggest: List[int], k=3, nums=[-5, 30, 31, 32, 30, 93, 97]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)", "target": ""}
{"module": "human_eval.py", "name": "BiggestK:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#120", "sol_bodies": ["    return sorted(nums, reverse=True)[:k]"], "sol_header": "def sol(k=2, nums=[75, 30, 53, 25, 14]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the largest k numbers\n\n    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(biggest: List[int], k=2, nums=[75, 30, 53, 25, 14]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)", "input": "def sat(biggest: List[int], k=2, nums=[75, 30, 53, 25, 14]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)", "target": ""}
{"module": "human_eval.py", "name": "BiggestK:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#120", "sol_bodies": ["    return sorted(nums, reverse=True)[:k]"], "sol_header": "def sol(k=1, nums=[-6, 9, 36, 36, 99, 66, 41, 38, 11, 61]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the largest k numbers\n\n    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(biggest: List[int], k=1, nums=[-6, 9, 36, 36, 99, 66, 41, 38, 11, 61]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)", "input": "def sat(biggest: List[int], k=1, nums=[-6, 9, 36, 36, 99, 66, 41, 38, 11, 61]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)", "target": ""}
{"module": "human_eval.py", "name": "BiggestK:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#120", "sol_bodies": ["    return sorted(nums, reverse=True)[:k]"], "sol_header": "def sol(k=2, nums=[4, 65, 52, 41, 21, 0, 45, 71]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the largest k numbers\n\n    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]\n    \"\"\"", "weight": 1.0, "sat": "def sat(biggest: List[int], k=2, nums=[4, 65, 52, 41, 21, 0, 45, 71]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)", "input": "def sat(biggest: List[int], k=2, nums=[4, 65, 52, 41, 21, 0, 45, 71]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)", "target": ""}
{"module": "human_eval.py", "name": "LongEarlySum:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#122\n    \nChanged slightly to make the answer not be a small integer.", "sol_bodies": ["    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)"], "sol_header": "def sol(k=5, nums=[1252, 125273523, 0, 42, 100, 214532, 2, 0, 11, 14]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the numbers among the first k with more than 2 digits\n\n    k=3, nums=[2, 102, 12, 1000] => 102\n    \"\"\"", "weight": 1.0, "sat": "def sat(tot: int, k=5, nums=[1252, 125273523, 0, 42, 100, 214532, 2, 0, 11, 14]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0", "input": "def sat(tot: int, k=5, nums=[1252, 125273523, 0, 42, 100, 214532, 2, 0, 11, 14]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0", "target": ""}
{"module": "human_eval.py", "name": "LongEarlySum:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#122\n    \nChanged slightly to make the answer not be a small integer.", "sol_bodies": ["    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)"], "sol_header": "def sol(k=5, nums=[-7157016423, 2782843150, 7219126112, -6508908448, -2700793649]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the numbers among the first k with more than 2 digits\n\n    k=3, nums=[2, 102, 12, 1000] => 102\n    \"\"\"", "weight": 1.0, "sat": "def sat(tot: int, k=5, nums=[-7157016423, 2782843150, 7219126112, -6508908448, -2700793649]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0", "input": "def sat(tot: int, k=5, nums=[-7157016423, 2782843150, 7219126112, -6508908448, -2700793649]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0", "target": ""}
{"module": "human_eval.py", "name": "LongEarlySum:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#122\n    \nChanged slightly to make the answer not be a small integer.", "sol_bodies": ["    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)"], "sol_header": "def sol(k=9, nums=[-5897482060, -6124803429, 460595384, -4038677051, 4034899461, 4374130613, -107107411]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the numbers among the first k with more than 2 digits\n\n    k=3, nums=[2, 102, 12, 1000] => 102\n    \"\"\"", "weight": 1.0, "sat": "def sat(tot: int, k=9, nums=[-5897482060, -6124803429, 460595384, -4038677051, 4034899461, 4374130613, -107107411]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0", "input": "def sat(tot: int, k=9, nums=[-5897482060, -6124803429, 460595384, -4038677051, 4034899461, 4374130613, -107107411]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0", "target": ""}
{"module": "human_eval.py", "name": "LongEarlySum:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#122\n    \nChanged slightly to make the answer not be a small integer.", "sol_bodies": ["    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)"], "sol_header": "def sol(k=9, nums=[-8188839170, -4196027936, 7189346049, -3904396164, -6197615761, -1925353242, 4455917604, -60399777, 2265288077, -5809369361, -1403148167, 4937241577, 6147738064, 2911928645, -3466247912]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the numbers among the first k with more than 2 digits\n\n    k=3, nums=[2, 102, 12, 1000] => 102\n    \"\"\"", "weight": 1.0, "sat": "def sat(tot: int, k=9, nums=[-8188839170, -4196027936, 7189346049, -3904396164, -6197615761, -1925353242, 4455917604, -60399777, 2265288077, -5809369361, -1403148167, 4937241577, 6147738064, 2911928645, -3466247912]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0", "input": "def sat(tot: int, k=9, nums=[-8188839170, -4196027936, 7189346049, -3904396164, -6197615761, -1925353242, 4455917604, -60399777, 2265288077, -5809369361, -1403148167, 4937241577, 6147738064, 2911928645, -3466247912]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0", "target": ""}
{"module": "human_eval.py", "name": "LongEarlySum:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#122\n    \nChanged slightly to make the answer not be a small integer.", "sol_bodies": ["    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)"], "sol_header": "def sol(k=7, nums=[9205334525, 5459823374, -7169802732, 9865454706, -7321060937, 6045166493, 15149444, 1118638089, -4595115991, -3388779539]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the numbers among the first k with more than 2 digits\n\n    k=3, nums=[2, 102, 12, 1000] => 102\n    \"\"\"", "weight": 1.0, "sat": "def sat(tot: int, k=7, nums=[9205334525, 5459823374, -7169802732, 9865454706, -7321060937, 6045166493, 15149444, 1118638089, -4595115991, -3388779539]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0", "input": "def sat(tot: int, k=7, nums=[9205334525, 5459823374, -7169802732, 9865454706, -7321060937, 6045166493, 15149444, 1118638089, -4595115991, -3388779539]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0", "target": ""}
{"module": "human_eval.py", "name": "OddCollatz:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#123", "sol_bodies": ["    ans = []\n    while True:\n        if n % 2 == 1:\n            ans.append(n)\n        if n <= 1:\n            return ans\n        n = (3 * n + 1) if n % 2 == 1 else n // 2"], "sol_header": "def sol(n=1243272912731):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the odd numbers in the collatz sequence starting at n\n\n    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(odds: List[int], n=1243272912731):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2", "input": "def sat(odds: List[int], n=1243272912731):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2", "target": ""}
{"module": "human_eval.py", "name": "OddCollatz:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#123", "sol_bodies": ["    ans = []\n    while True:\n        if n % 2 == 1:\n            ans.append(n)\n        if n <= 1:\n            return ans\n        n = (3 * n + 1) if n % 2 == 1 else n // 2"], "sol_header": "def sol(n=6969429614):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the odd numbers in the collatz sequence starting at n\n\n    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(odds: List[int], n=6969429614):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2", "input": "def sat(odds: List[int], n=6969429614):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2", "target": ""}
{"module": "human_eval.py", "name": "OddCollatz:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#123", "sol_bodies": ["    ans = []\n    while True:\n        if n % 2 == 1:\n            ans.append(n)\n        if n <= 1:\n            return ans\n        n = (3 * n + 1) if n % 2 == 1 else n // 2"], "sol_header": "def sol(n=529):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the odd numbers in the collatz sequence starting at n\n\n    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(odds: List[int], n=529):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2", "input": "def sat(odds: List[int], n=529):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2", "target": ""}
{"module": "human_eval.py", "name": "OddCollatz:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#123", "sol_bodies": ["    ans = []\n    while True:\n        if n % 2 == 1:\n            ans.append(n)\n        if n <= 1:\n            return ans\n        n = (3 * n + 1) if n % 2 == 1 else n // 2"], "sol_header": "def sol(n=37):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the odd numbers in the collatz sequence starting at n\n\n    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(odds: List[int], n=37):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2", "input": "def sat(odds: List[int], n=37):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2", "target": ""}
{"module": "human_eval.py", "name": "OddCollatz:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#123", "sol_bodies": ["    ans = []\n    while True:\n        if n % 2 == 1:\n            ans.append(n)\n        if n <= 1:\n            return ans\n        n = (3 * n + 1) if n % 2 == 1 else n // 2"], "sol_header": "def sol(n=95119584):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the odd numbers in the collatz sequence starting at n\n\n    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]\n    \"\"\"", "weight": 1.0, "sat": "def sat(odds: List[int], n=95119584):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2", "input": "def sat(odds: List[int], n=95119584):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2", "target": ""}
{"module": "human_eval.py", "name": "DateDiff:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#124", "sol_bodies": ["    if target >= -30:\n        return \"12-01-\" + str(11 - target).zfill(4)\n    return \"01-31-\" + str(-30 - target).zfill(4)"], "sol_header": "def sol(target=-2075):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target\n\n    -2029 => \"10-18-2021\" # because 10-18-2021 == -2029\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=-2075):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target", "input": "def sat(s: str, target=-2075):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target", "target": ""}
{"module": "human_eval.py", "name": "DateDiff:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#124", "sol_bodies": ["    if target >= -30:\n        return \"12-01-\" + str(11 - target).zfill(4)\n    return \"01-31-\" + str(-30 - target).zfill(4)"], "sol_header": "def sol(target=11):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target\n\n    -2029 => \"10-18-2021\" # because 10-18-2021 == -2029\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=11):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target", "input": "def sat(s: str, target=11):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target", "target": ""}
{"module": "human_eval.py", "name": "DateDiff:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#124", "sol_bodies": ["    if target >= -30:\n        return \"12-01-\" + str(11 - target).zfill(4)\n    return \"01-31-\" + str(-30 - target).zfill(4)"], "sol_header": "def sol(target=-30):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target\n\n    -2029 => \"10-18-2021\" # because 10-18-2021 == -2029\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=-30):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target", "input": "def sat(s: str, target=-30):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target", "target": ""}
{"module": "human_eval.py", "name": "DateDiff:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#124", "sol_bodies": ["    if target >= -30:\n        return \"12-01-\" + str(11 - target).zfill(4)\n    return \"01-31-\" + str(-30 - target).zfill(4)"], "sol_header": "def sol(target=-1999):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target\n\n    -2029 => \"10-18-2021\" # because 10-18-2021 == -2029\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=-1999):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target", "input": "def sat(s: str, target=-1999):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target", "target": ""}
{"module": "human_eval.py", "name": "DateDiff:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#124", "sol_bodies": ["    if target >= -30:\n        return \"12-01-\" + str(11 - target).zfill(4)\n    return \"01-31-\" + str(-30 - target).zfill(4)"], "sol_header": "def sol(target=-10029):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target\n\n    -2029 => \"10-18-2021\" # because 10-18-2021 == -2029\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, target=-10029):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target", "input": "def sat(s: str, target=-10029):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target", "target": ""}
{"module": "human_eval.py", "name": "StrangeSplit:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#125", "sol_bodies": ["    if \" \" in s:\n        return s.split(\" \")\n    if \",\" in s:\n        return s.split(\",\")\n    return [c for c in s if c.islower() and ord(c) % 2 == 0]"], "sol_header": "def sol(s=\"Hello, world!\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise\n    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)\n\n    \"a b c\" => [\"a\", \"b\", \"c\"]\n    \"a,b\" => [\"a\", \"b\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(lst: List[str], s=\"Hello, world!\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)", "input": "def sat(lst: List[str], s=\"Hello, world!\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)", "target": ""}
{"module": "human_eval.py", "name": "StrangeSplit:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#125", "sol_bodies": ["    if \" \" in s:\n        return s.split(\" \")\n    if \",\" in s:\n        return s.split(\",\")\n    return [c for c in s if c.islower() and ord(c) % 2 == 0]"], "sol_header": "def sol(s=\"Goodbye,spaces!\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise\n    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)\n\n    \"a b c\" => [\"a\", \"b\", \"c\"]\n    \"a,b\" => [\"a\", \"b\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(lst: List[str], s=\"Goodbye,spaces!\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)", "input": "def sat(lst: List[str], s=\"Goodbye,spaces!\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)", "target": ""}
{"module": "human_eval.py", "name": "StrangeSplit:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#125", "sol_bodies": ["    if \" \" in s:\n        return s.split(\" \")\n    if \",\" in s:\n        return s.split(\",\")\n    return [c for c in s if c.islower() and ord(c) % 2 == 0]"], "sol_header": "def sol(s=\"abcbcbbedfsgfakbfjghskbne[pewte\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise\n    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)\n\n    \"a b c\" => [\"a\", \"b\", \"c\"]\n    \"a,b\" => [\"a\", \"b\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(lst: List[str], s=\"abcbcbbedfsgfakbfjghskbne[pewte\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)", "input": "def sat(lst: List[str], s=\"abcbcbbedfsgfakbfjghskbne[pewte\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)", "target": ""}
{"module": "human_eval.py", "name": "StrangeSplit:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#125", "sol_bodies": ["    if \" \" in s:\n        return s.split(\" \")\n    if \",\" in s:\n        return s.split(\",\")\n    return [c for c in s if c.islower() and ord(c) % 2 == 0]"], "sol_header": "def sol(s=\"wotekitex,textarinequo,do,machoki,balecethotuwy,jarynutextopimud,dethexifythuthyc\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise\n    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)\n\n    \"a b c\" => [\"a\", \"b\", \"c\"]\n    \"a,b\" => [\"a\", \"b\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(lst: List[str], s=\"wotekitex,textarinequo,do,machoki,balecethotuwy,jarynutextopimud,dethexifythuthyc\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)", "input": "def sat(lst: List[str], s=\"wotekitex,textarinequo,do,machoki,balecethotuwy,jarynutextopimud,dethexifythuthyc\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)", "target": ""}
{"module": "human_eval.py", "name": "StrangeSplit:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#125", "sol_bodies": ["    if \" \" in s:\n        return s.split(\" \")\n    if \",\" in s:\n        return s.split(\",\")\n    return [c for c in s if c.islower() and ord(c) % 2 == 0]"], "sol_header": "def sol(s=\"jitys py sepocedynechuhegu lekinihiluwefax\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise\n    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)\n\n    \"a b c\" => [\"a\", \"b\", \"c\"]\n    \"a,b\" => [\"a\", \"b\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(lst: List[str], s=\"jitys py sepocedynechuhegu lekinihiluwefax\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)", "input": "def sat(lst: List[str], s=\"jitys py sepocedynechuhegu lekinihiluwefax\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)", "target": ""}
{"module": "human_eval.py", "name": "IncreasingViolation:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#126", "sol_bodies": ["    for i in range(len(nums) - 1):\n        if nums[i] >= nums[i + 1]:\n            return [i, i + 1]\n    return []"], "sol_header": "def sol(nums=[1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 17, 17, 18, 19, 20, 22, 24]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of two entries that show that the list is not in increasing order.\n    If there are no violations (they are increasing), return an empty list.\n\n    [1,2,3,0,4,5,6] => [1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(violation: List[int], nums=[1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 17, 17, 18, 19, 20, 22, 24]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]", "input": "def sat(violation: List[int], nums=[1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 17, 17, 18, 19, 20, 22, 24]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]", "target": ""}
{"module": "human_eval.py", "name": "IncreasingViolation:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#126", "sol_bodies": ["    for i in range(len(nums) - 1):\n        if nums[i] >= nums[i + 1]:\n            return [i, i + 1]\n    return []"], "sol_header": "def sol(nums=[10, 16, 19, 23, 25, 27, 27, 39, 39, 44, 52, 60, 64, 1, 92, 96]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of two entries that show that the list is not in increasing order.\n    If there are no violations (they are increasing), return an empty list.\n\n    [1,2,3,0,4,5,6] => [1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(violation: List[int], nums=[10, 16, 19, 23, 25, 27, 27, 39, 39, 44, 52, 60, 64, 1, 92, 96]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]", "input": "def sat(violation: List[int], nums=[10, 16, 19, 23, 25, 27, 27, 39, 39, 44, 52, 60, 64, 1, 92, 96]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]", "target": ""}
{"module": "human_eval.py", "name": "IncreasingViolation:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#126", "sol_bodies": ["    for i in range(len(nums) - 1):\n        if nums[i] >= nums[i + 1]:\n            return [i, i + 1]\n    return []"], "sol_header": "def sol(nums=[10, 10, 10, 11, 17, 22, 31, 35, 42, 48, 61, 75, 90, 92]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of two entries that show that the list is not in increasing order.\n    If there are no violations (they are increasing), return an empty list.\n\n    [1,2,3,0,4,5,6] => [1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(violation: List[int], nums=[10, 10, 10, 11, 17, 22, 31, 35, 42, 48, 61, 75, 90, 92]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]", "input": "def sat(violation: List[int], nums=[10, 10, 10, 11, 17, 22, 31, 35, 42, 48, 61, 75, 90, 92]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]", "target": ""}
{"module": "human_eval.py", "name": "IncreasingViolation:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#126", "sol_bodies": ["    for i in range(len(nums) - 1):\n        if nums[i] >= nums[i + 1]:\n            return [i, i + 1]\n    return []"], "sol_header": "def sol(nums=[5, 5, 84]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of two entries that show that the list is not in increasing order.\n    If there are no violations (they are increasing), return an empty list.\n\n    [1,2,3,0,4,5,6] => [1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(violation: List[int], nums=[5, 5, 84]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]", "input": "def sat(violation: List[int], nums=[5, 5, 84]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]", "target": ""}
{"module": "human_eval.py", "name": "IncreasingViolation:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#126", "sol_bodies": ["    for i in range(len(nums) - 1):\n        if nums[i] >= nums[i + 1]:\n            return [i, i + 1]\n    return []"], "sol_header": "def sol(nums=[2, 5, 12, 40, 41, 47, 52, 53, 60, 46, 64, 66, 71]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find the indices of two entries that show that the list is not in increasing order.\n    If there are no violations (they are increasing), return an empty list.\n\n    [1,2,3,0,4,5,6] => [1, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(violation: List[int], nums=[2, 5, 12, 40, 41, 47, 52, 53, 60, 46, 64, 66, 71]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]", "input": "def sat(violation: List[int], nums=[2, 5, 12, 40, 41, 47, 52, 53, 60, 46, 64, 66, 71]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]", "target": ""}
{"module": "human_eval.py", "name": "PrimeIntervalIntersection:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#127", "sol_bodies": ["    a, b = interval1\n    assert b - a >= 2\n    return [a, a + 2]"], "sol_header": "def sol(interval1=[32157, 93210127]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find an interval whose intersection with a given interval has a width that is a prime integer.\n\n    [7, 100] => [0, 10]  # because 10-7=3 is prime\n    \"\"\"", "weight": 1.0, "sat": "def sat(interval2: List[int], interval1=[32157, 93210127]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))", "input": "def sat(interval2: List[int], interval1=[32157, 93210127]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))", "target": ""}
{"module": "human_eval.py", "name": "PrimeIntervalIntersection:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#127", "sol_bodies": ["    a, b = interval1\n    assert b - a >= 2\n    return [a, a + 2]"], "sol_header": "def sol(interval1=[-3367, 4628]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find an interval whose intersection with a given interval has a width that is a prime integer.\n\n    [7, 100] => [0, 10]  # because 10-7=3 is prime\n    \"\"\"", "weight": 1.0, "sat": "def sat(interval2: List[int], interval1=[-3367, 4628]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))", "input": "def sat(interval2: List[int], interval1=[-3367, 4628]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))", "target": ""}
{"module": "human_eval.py", "name": "PrimeIntervalIntersection:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#127", "sol_bodies": ["    a, b = interval1\n    assert b - a >= 2\n    return [a, a + 2]"], "sol_header": "def sol(interval1=[0, 2381571]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find an interval whose intersection with a given interval has a width that is a prime integer.\n\n    [7, 100] => [0, 10]  # because 10-7=3 is prime\n    \"\"\"", "weight": 1.0, "sat": "def sat(interval2: List[int], interval1=[0, 2381571]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))", "input": "def sat(interval2: List[int], interval1=[0, 2381571]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))", "target": ""}
{"module": "human_eval.py", "name": "PrimeIntervalIntersection:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#127", "sol_bodies": ["    a, b = interval1\n    assert b - a >= 2\n    return [a, a + 2]"], "sol_header": "def sol(interval1=[0, 1867]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find an interval whose intersection with a given interval has a width that is a prime integer.\n\n    [7, 100] => [0, 10]  # because 10-7=3 is prime\n    \"\"\"", "weight": 1.0, "sat": "def sat(interval2: List[int], interval1=[0, 1867]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))", "input": "def sat(interval2: List[int], interval1=[0, 1867]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))", "target": ""}
{"module": "human_eval.py", "name": "PrimeIntervalIntersection:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#127", "sol_bodies": ["    a, b = interval1\n    assert b - a >= 2\n    return [a, a + 2]"], "sol_header": "def sol(interval1=[-9017, 9358096]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find an interval whose intersection with a given interval has a width that is a prime integer.\n\n    [7, 100] => [0, 10]  # because 10-7=3 is prime\n    \"\"\"", "weight": 1.0, "sat": "def sat(interval2: List[int], interval1=[-9017, 9358096]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))", "input": "def sat(interval2: List[int], interval1=[-9017, 9358096]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))", "target": ""}
{"module": "human_eval.py", "name": "ProductSigns:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#128\n    \nEasy puzzle since the answer is computed in the puzzle, but it is okay to have a few trivial puzzles.", "sol_bodies": ["    tot = sum(abs(i) for i in arr)\n    if all(arr):\n        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot\n    return 0"], "sol_header": "def sol(arr=[1, 7, -20052, 14, -3, -11, 1025235, 14]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of\n    the signs of the entries.\n\n    [1, -2, 3] => -6  # negative because there is one negative\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, arr=[1, 7, -20052, 14, -3, -11, 1025235, 14]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot", "input": "def sat(n: int, arr=[1, 7, -20052, 14, -3, -11, 1025235, 14]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot", "target": ""}
{"module": "human_eval.py", "name": "ProductSigns:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#128\n    \nEasy puzzle since the answer is computed in the puzzle, but it is okay to have a few trivial puzzles.", "sol_bodies": ["    tot = sum(abs(i) for i in arr)\n    if all(arr):\n        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot\n    return 0"], "sol_header": "def sol(arr=[13, 38, 57, 6, -79, 85, -96, 60, 45, 37, 66]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of\n    the signs of the entries.\n\n    [1, -2, 3] => -6  # negative because there is one negative\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, arr=[13, 38, 57, 6, -79, 85, -96, 60, 45, 37, 66]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot", "input": "def sat(n: int, arr=[13, 38, 57, 6, -79, 85, -96, 60, 45, 37, 66]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot", "target": ""}
{"module": "human_eval.py", "name": "ProductSigns:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#128\n    \nEasy puzzle since the answer is computed in the puzzle, but it is okay to have a few trivial puzzles.", "sol_bodies": ["    tot = sum(abs(i) for i in arr)\n    if all(arr):\n        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot\n    return 0"], "sol_header": "def sol(arr=[-58, -49, -56, 75, 52, -54, -95]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of\n    the signs of the entries.\n\n    [1, -2, 3] => -6  # negative because there is one negative\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, arr=[-58, -49, -56, 75, 52, -54, -95]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot", "input": "def sat(n: int, arr=[-58, -49, -56, 75, 52, -54, -95]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot", "target": ""}
{"module": "human_eval.py", "name": "ProductSigns:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#128\n    \nEasy puzzle since the answer is computed in the puzzle, but it is okay to have a few trivial puzzles.", "sol_bodies": ["    tot = sum(abs(i) for i in arr)\n    if all(arr):\n        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot\n    return 0"], "sol_header": "def sol(arr=[-41, 67, -27, -41, 16, 1, 66, -91, 4, 36, 10, -95, 7, 54, -97, -87]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of\n    the signs of the entries.\n\n    [1, -2, 3] => -6  # negative because there is one negative\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, arr=[-41, 67, -27, -41, 16, 1, 66, -91, 4, 36, 10, -95, 7, 54, -97, -87]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot", "input": "def sat(n: int, arr=[-41, 67, -27, -41, 16, 1, 66, -91, 4, 36, 10, -95, 7, 54, -97, -87]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot", "target": ""}
{"module": "human_eval.py", "name": "ProductSigns:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#128\n    \nEasy puzzle since the answer is computed in the puzzle, but it is okay to have a few trivial puzzles.", "sol_bodies": ["    tot = sum(abs(i) for i in arr)\n    if all(arr):\n        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot\n    return 0"], "sol_header": "def sol(arr=[-62, 46, -83, -14]):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of\n    the signs of the entries.\n\n    [1, -2, 3] => -6  # negative because there is one negative\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, arr=[-62, 46, -83, -14]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot", "input": "def sat(n: int, arr=[-62, 46, -83, -14]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot", "target": ""}
{"module": "human_eval.py", "name": "LexPath:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#129", "sol_bodies": ["    path = []\n    while len(path) < k:\n        path.append(min(edges[path[-1]]) if path else 0)\n    return path"], "sol_header": "def sol(k=10, edges=[[2, 4], [3], [4, 1], [4], [0]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)\n\n    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges\n    \"\"\"", "weight": 1.0, "sat": "def sat(path: List[int], k=10, edges=[[2, 4], [3], [4, 1], [4], [0]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))", "input": "def sat(path: List[int], k=10, edges=[[2, 4], [3], [4, 1], [4], [0]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))", "target": ""}
{"module": "human_eval.py", "name": "LexPath:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#129", "sol_bodies": ["    path = []\n    while len(path) < k:\n        path.append(min(edges[path[-1]]) if path else 0)\n    return path"], "sol_header": "def sol(k=12, edges=[[2, 1], [0], [1, 3, 0], [1, 0, 3]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)\n\n    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges\n    \"\"\"", "weight": 1.0, "sat": "def sat(path: List[int], k=12, edges=[[2, 1], [0], [1, 3, 0], [1, 0, 3]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))", "input": "def sat(path: List[int], k=12, edges=[[2, 1], [0], [1, 3, 0], [1, 0, 3]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))", "target": ""}
{"module": "human_eval.py", "name": "LexPath:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#129", "sol_bodies": ["    path = []\n    while len(path) < k:\n        path.append(min(edges[path[-1]]) if path else 0)\n    return path"], "sol_header": "def sol(k=0, edges=[[2, 0], [0, 3, 1, 2], [3, 0, 1, 2], [1, 2]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)\n\n    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges\n    \"\"\"", "weight": 1.0, "sat": "def sat(path: List[int], k=0, edges=[[2, 0], [0, 3, 1, 2], [3, 0, 1, 2], [1, 2]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))", "input": "def sat(path: List[int], k=0, edges=[[2, 0], [0, 3, 1, 2], [3, 0, 1, 2], [1, 2]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))", "target": ""}
{"module": "human_eval.py", "name": "LexPath:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#129", "sol_bodies": ["    path = []\n    while len(path) < k:\n        path.append(min(edges[path[-1]]) if path else 0)\n    return path"], "sol_header": "def sol(k=14, edges=[[2], [2, 1, 0], [2, 1, 0]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)\n\n    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges\n    \"\"\"", "weight": 1.0, "sat": "def sat(path: List[int], k=14, edges=[[2], [2, 1, 0], [2, 1, 0]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))", "input": "def sat(path: List[int], k=14, edges=[[2], [2, 1, 0], [2, 1, 0]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))", "target": ""}
{"module": "human_eval.py", "name": "LexPath:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#129", "sol_bodies": ["    path = []\n    while len(path) < k:\n        path.append(min(edges[path[-1]]) if path else 0)\n    return path"], "sol_header": "def sol(k=1, edges=[[2, 0, 3, 1], [3, 1], [2, 0, 1], [0]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)\n\n    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges\n    \"\"\"", "weight": 1.0, "sat": "def sat(path: List[int], k=1, edges=[[2, 0, 3, 1], [3, 1], [2, 0, 1], [0]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))", "input": "def sat(path: List[int], k=1, edges=[[2, 0, 3, 1], [3, 1], [2, 0, 1], [0]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))", "target": ""}
{"module": "human_eval.py", "name": "Tribonacci:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#130\n\nThis puzzle is a bit harder because the definition is slightly different at seq[1].", "sol_bodies": ["    seq = []\n    while len(seq) <= length:\n        n = len(seq)\n        if n % 2 == 0:\n            seq.append(1 + n // 2)\n        else:\n            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))\n    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1"], "sol_header": "def sol(length=181):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a sequence where seq[n] == 1 + n / 2 for even n, and\n    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length.\"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], length=181):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))", "input": "def sat(seq: List[int], length=181):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))", "target": ""}
{"module": "human_eval.py", "name": "Tribonacci:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#130\n\nThis puzzle is a bit harder because the definition is slightly different at seq[1].", "sol_bodies": ["    seq = []\n    while len(seq) <= length:\n        n = len(seq)\n        if n % 2 == 0:\n            seq.append(1 + n // 2)\n        else:\n            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))\n    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1"], "sol_header": "def sol(length=412):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a sequence where seq[n] == 1 + n / 2 for even n, and\n    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length.\"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], length=412):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))", "input": "def sat(seq: List[int], length=412):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))", "target": ""}
{"module": "human_eval.py", "name": "Tribonacci:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#130\n\nThis puzzle is a bit harder because the definition is slightly different at seq[1].", "sol_bodies": ["    seq = []\n    while len(seq) <= length:\n        n = len(seq)\n        if n % 2 == 0:\n            seq.append(1 + n // 2)\n        else:\n            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))\n    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1"], "sol_header": "def sol(length=482):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a sequence where seq[n] == 1 + n / 2 for even n, and\n    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length.\"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], length=482):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))", "input": "def sat(seq: List[int], length=482):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))", "target": ""}
{"module": "human_eval.py", "name": "Tribonacci:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#130\n\nThis puzzle is a bit harder because the definition is slightly different at seq[1].", "sol_bodies": ["    seq = []\n    while len(seq) <= length:\n        n = len(seq)\n        if n % 2 == 0:\n            seq.append(1 + n // 2)\n        else:\n            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))\n    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1"], "sol_header": "def sol(length=50):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a sequence where seq[n] == 1 + n / 2 for even n, and\n    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length.\"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], length=50):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))", "input": "def sat(seq: List[int], length=50):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))", "target": ""}
{"module": "human_eval.py", "name": "Tribonacci:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#130\n\nThis puzzle is a bit harder because the definition is slightly different at seq[1].", "sol_bodies": ["    seq = []\n    while len(seq) <= length:\n        n = len(seq)\n        if n % 2 == 0:\n            seq.append(1 + n // 2)\n        else:\n            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))\n    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1"], "sol_header": "def sol(length=761):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a sequence where seq[n] == 1 + n / 2 for even n, and\n    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length.\"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], length=761):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))", "input": "def sat(seq: List[int], length=761):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))", "target": ""}
{"module": "human_eval.py", "name": "OddProduct:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#131", "sol_bodies": ["    if any(int(c) % 2 for c in str(n)):\n        prod = 1\n        for c in str(n):\n            if int(c) % 2 == 1:\n                prod *= int(c)\n        return prod\n    return 0"], "sol_header": "def sol(n=14235764939971075543215213):", "ans_type": "int", "sol_docstring": "    \"\"\"Return the product of the odd digits in n, or 0 if there aren't any\n\n    12345 => 15\n    \"\"\"", "weight": 1.0, "sat": "def sat(prod: int, n=14235764939971075543215213):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))", "input": "def sat(prod: int, n=14235764939971075543215213):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))", "target": ""}
{"module": "human_eval.py", "name": "OddProduct:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#131", "sol_bodies": ["    if any(int(c) % 2 for c in str(n)):\n        prod = 1\n        for c in str(n):\n            if int(c) % 2 == 1:\n                prod *= int(c)\n        return prod\n    return 0"], "sol_header": "def sol(n=8502):", "ans_type": "int", "sol_docstring": "    \"\"\"Return the product of the odd digits in n, or 0 if there aren't any\n\n    12345 => 15\n    \"\"\"", "weight": 1.0, "sat": "def sat(prod: int, n=8502):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))", "input": "def sat(prod: int, n=8502):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))", "target": ""}
{"module": "human_eval.py", "name": "OddProduct:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#131", "sol_bodies": ["    if any(int(c) % 2 for c in str(n)):\n        prod = 1\n        for c in str(n):\n            if int(c) % 2 == 1:\n                prod *= int(c)\n        return prod\n    return 0"], "sol_header": "def sol(n=95973):", "ans_type": "int", "sol_docstring": "    \"\"\"Return the product of the odd digits in n, or 0 if there aren't any\n\n    12345 => 15\n    \"\"\"", "weight": 1.0, "sat": "def sat(prod: int, n=95973):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))", "input": "def sat(prod: int, n=95973):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))", "target": ""}
{"module": "human_eval.py", "name": "OddProduct:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#131", "sol_bodies": ["    if any(int(c) % 2 for c in str(n)):\n        prod = 1\n        for c in str(n):\n            if int(c) % 2 == 1:\n                prod *= int(c)\n        return prod\n    return 0"], "sol_header": "def sol(n=0):", "ans_type": "int", "sol_docstring": "    \"\"\"Return the product of the odd digits in n, or 0 if there aren't any\n\n    12345 => 15\n    \"\"\"", "weight": 1.0, "sat": "def sat(prod: int, n=0):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))", "input": "def sat(prod: int, n=0):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))", "target": ""}
{"module": "human_eval.py", "name": "OddProduct:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#131", "sol_bodies": ["    if any(int(c) % 2 for c in str(n)):\n        prod = 1\n        for c in str(n):\n            if int(c) % 2 == 1:\n                prod *= int(c)\n        return prod\n    return 0"], "sol_header": "def sol(n=331901673137376013):", "ans_type": "int", "sol_docstring": "    \"\"\"Return the product of the odd digits in n, or 0 if there aren't any\n\n    12345 => 15\n    \"\"\"", "weight": 1.0, "sat": "def sat(prod: int, n=331901673137376013):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))", "input": "def sat(prod: int, n=331901673137376013):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))", "target": ""}
{"module": "human_eval.py", "name": "ValidBracketSubsequence:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#132", "sol_bodies": ["    left = []\n    nested = False\n    for i, c in enumerate(s):\n        if c == \"[\":\n            if len(left) == 2:\n                left = [left[1], i]\n                nested = False\n            else:\n                left.append(i)\n        elif c == \"]\":\n            if not left:\n                continue\n            if len(left) == 1 and nested:\n                return s[left[0]:i + 1]\n            elif len(left) == 2:\n                nested = True\n            left.pop()\n    assert False", "    import re\n    return re.search(r\"\\[(\\[\\])+\\]\", s).group(0)"], "sol_header": "def sol(s=\"]]]]]]]]]]]]]]]]][][][][]]]]]]]]]]][[[][[][[[[[][][][]][[[[[[[[[[[[[[[[[[\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a valid substring of s that contains matching brackets, at least one of which is nested\n\n    \"]][][[]]]\" => \"[][[]]\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(valid: str, s=\"]]]]]]]]]]]]]]]]][][][][]]]]]]]]]]][[[][[][[[[[][][][]][[[[[[[[[[[[[[[[[[\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1", "input": "def sat(valid: str, s=\"]]]]]]]]]]]]]]]]][][][][]]]]]]]]]]][[[][[][[[[[][][][]][[[[[[[[[[[[[[[[[[\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1", "target": ""}
{"module": "human_eval.py", "name": "ValidBracketSubsequence:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#132", "sol_bodies": ["    left = []\n    nested = False\n    for i, c in enumerate(s):\n        if c == \"[\":\n            if len(left) == 2:\n                left = [left[1], i]\n                nested = False\n            else:\n                left.append(i)\n        elif c == \"]\":\n            if not left:\n                continue\n            if len(left) == 1 and nested:\n                return s[left[0]:i + 1]\n            elif len(left) == 2:\n                nested = True\n            left.pop()\n    assert False", "    import re\n    return re.search(r\"\\[(\\[\\])+\\]\", s).group(0)"], "sol_header": "def sol(s=\"[[[[][][][][][][]][[]][]][[[][]][[]]\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a valid substring of s that contains matching brackets, at least one of which is nested\n\n    \"]][][[]]]\" => \"[][[]]\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(valid: str, s=\"[[[[][][][][][][]][[]][]][[[][]][[]]\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1", "input": "def sat(valid: str, s=\"[[[[][][][][][][]][[]][]][[[][]][[]]\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1", "target": ""}
{"module": "human_eval.py", "name": "ValidBracketSubsequence:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#132", "sol_bodies": ["    left = []\n    nested = False\n    for i, c in enumerate(s):\n        if c == \"[\":\n            if len(left) == 2:\n                left = [left[1], i]\n                nested = False\n            else:\n                left.append(i)\n        elif c == \"]\":\n            if not left:\n                continue\n            if len(left) == 1 and nested:\n                return s[left[0]:i + 1]\n            elif len(left) == 2:\n                nested = True\n            left.pop()\n    assert False", "    import re\n    return re.search(r\"\\[(\\[\\])+\\]\", s).group(0)"], "sol_header": "def sol(s=\"]][[]][[][[[[][]]][[][[[][\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a valid substring of s that contains matching brackets, at least one of which is nested\n\n    \"]][][[]]]\" => \"[][[]]\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(valid: str, s=\"]][[]][[][[[[][]]][[][[[][\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1", "input": "def sat(valid: str, s=\"]][[]][[][[[[][]]][[][[[][\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1", "target": ""}
{"module": "human_eval.py", "name": "ValidBracketSubsequence:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#132", "sol_bodies": ["    left = []\n    nested = False\n    for i, c in enumerate(s):\n        if c == \"[\":\n            if len(left) == 2:\n                left = [left[1], i]\n                nested = False\n            else:\n                left.append(i)\n        elif c == \"]\":\n            if not left:\n                continue\n            if len(left) == 1 and nested:\n                return s[left[0]:i + 1]\n            elif len(left) == 2:\n                nested = True\n            left.pop()\n    assert False", "    import re\n    return re.search(r\"\\[(\\[\\])+\\]\", s).group(0)"], "sol_header": "def sol(s=\"][]]][]][[[][][][][][][][]][[]][[]]][[\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a valid substring of s that contains matching brackets, at least one of which is nested\n\n    \"]][][[]]]\" => \"[][[]]\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(valid: str, s=\"][]]][]][[[][][][][][][][]][[]][[]]][[\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1", "input": "def sat(valid: str, s=\"][]]][]][[[][][][][][][][]][[]][[]]][[\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1", "target": ""}
{"module": "human_eval.py", "name": "ValidBracketSubsequence:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#132", "sol_bodies": ["    left = []\n    nested = False\n    for i, c in enumerate(s):\n        if c == \"[\":\n            if len(left) == 2:\n                left = [left[1], i]\n                nested = False\n            else:\n                left.append(i)\n        elif c == \"]\":\n            if not left:\n                continue\n            if len(left) == 1 and nested:\n                return s[left[0]:i + 1]\n            elif len(left) == 2:\n                nested = True\n            left.pop()\n    assert False", "    import re\n    return re.search(r\"\\[(\\[\\])+\\]\", s).group(0)"], "sol_header": "def sol(s=\"[[[][][[[[[[]][[]][[[][][][][][][][][]][\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a valid substring of s that contains matching brackets, at least one of which is nested\n\n    \"]][][[]]]\" => \"[][[]]\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(valid: str, s=\"[[[][][[[[[[]][[]][[[][][][][][][][][]][\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1", "input": "def sat(valid: str, s=\"[[[][][[[[[[]][[]][[[][][][][][][][][]][\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1", "target": ""}
{"module": "human_eval.py", "name": "CeilingSquares:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#133", "sol_bodies": ["    from math import ceil\n    running_squares = []\n    tot = 0\n    for v in x:\n        tot += ceil(v) ** 2\n        running_squares.append(tot)\n    return running_squares"], "sol_header": "def sol(x=[201.1, 301.4, -18.1, 1244122.0, 10101.0101, 10000000.0]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Round each float in x up to the next integer and return the running total of the integer squares\n\n    [2.4, 3.7, 0.1] => [9, 25, 26]\n    \"\"\"", "weight": 1.0, "sat": "def sat(running_squares: List[int], x=[201.1, 301.4, -18.1, 1244122.0, 10101.0101, 10000000.0]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)", "input": "def sat(running_squares: List[int], x=[201.1, 301.4, -18.1, 1244122.0, 10101.0101, 10000000.0]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)", "target": ""}
{"module": "human_eval.py", "name": "CeilingSquares:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#133", "sol_bodies": ["    from math import ceil\n    running_squares = []\n    tot = 0\n    for v in x:\n        tot += ceil(v) ** 2\n        running_squares.append(tot)\n    return running_squares"], "sol_header": "def sol(x=[9.650000588598111, -8.077324515062926, 2.649836251190308, 0.7153951297675469, -1.9181388431489204, 2.7112675102232675, -6.813543009125667, 7.029917456417941, -2.821293215347511]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Round each float in x up to the next integer and return the running total of the integer squares\n\n    [2.4, 3.7, 0.1] => [9, 25, 26]\n    \"\"\"", "weight": 1.0, "sat": "def sat(running_squares: List[int], x=[9.650000588598111, -8.077324515062926, 2.649836251190308, 0.7153951297675469, -1.9181388431489204, 2.7112675102232675, -6.813543009125667, 7.029917456417941, -2.821293215347511]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)", "input": "def sat(running_squares: List[int], x=[9.650000588598111, -8.077324515062926, 2.649836251190308, 0.7153951297675469, -1.9181388431489204, 2.7112675102232675, -6.813543009125667, 7.029917456417941, -2.821293215347511]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)", "target": ""}
{"module": "human_eval.py", "name": "CeilingSquares:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#133", "sol_bodies": ["    from math import ceil\n    running_squares = []\n    tot = 0\n    for v in x:\n        tot += ceil(v) ** 2\n        running_squares.append(tot)\n    return running_squares"], "sol_header": "def sol(x=[-2.6340066467560996, 4.322176523433114, -1.5079841130054472, -8.985060763252859, -9.074227436202381]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Round each float in x up to the next integer and return the running total of the integer squares\n\n    [2.4, 3.7, 0.1] => [9, 25, 26]\n    \"\"\"", "weight": 1.0, "sat": "def sat(running_squares: List[int], x=[-2.6340066467560996, 4.322176523433114, -1.5079841130054472, -8.985060763252859, -9.074227436202381]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)", "input": "def sat(running_squares: List[int], x=[-2.6340066467560996, 4.322176523433114, -1.5079841130054472, -8.985060763252859, -9.074227436202381]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)", "target": ""}
{"module": "human_eval.py", "name": "CeilingSquares:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#133", "sol_bodies": ["    from math import ceil\n    running_squares = []\n    tot = 0\n    for v in x:\n        tot += ceil(v) ** 2\n        running_squares.append(tot)\n    return running_squares"], "sol_header": "def sol(x=[8.257528417306844, -3.7315204726521944, 9.856438333047798, -7.228652980051451, -6.343263566703614, -2.5469735103334834, -3.2923884429492762, -2.991171802818804]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Round each float in x up to the next integer and return the running total of the integer squares\n\n    [2.4, 3.7, 0.1] => [9, 25, 26]\n    \"\"\"", "weight": 1.0, "sat": "def sat(running_squares: List[int], x=[8.257528417306844, -3.7315204726521944, 9.856438333047798, -7.228652980051451, -6.343263566703614, -2.5469735103334834, -3.2923884429492762, -2.991171802818804]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)", "input": "def sat(running_squares: List[int], x=[8.257528417306844, -3.7315204726521944, 9.856438333047798, -7.228652980051451, -6.343263566703614, -2.5469735103334834, -3.2923884429492762, -2.991171802818804]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)", "target": ""}
{"module": "human_eval.py", "name": "CeilingSquares:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#133", "sol_bodies": ["    from math import ceil\n    running_squares = []\n    tot = 0\n    for v in x:\n        tot += ceil(v) ** 2\n        running_squares.append(tot)\n    return running_squares"], "sol_header": "def sol(x=[6.608264692857215, -2.204391758043112, 3.8328091843913974, 4.122558586426074, 6.79452673601816, -1.8532801154281735, 6.207567645800566]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Round each float in x up to the next integer and return the running total of the integer squares\n\n    [2.4, 3.7, 0.1] => [9, 25, 26]\n    \"\"\"", "weight": 1.0, "sat": "def sat(running_squares: List[int], x=[6.608264692857215, -2.204391758043112, 3.8328091843913974, 4.122558586426074, 6.79452673601816, -1.8532801154281735, 6.207567645800566]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)", "input": "def sat(running_squares: List[int], x=[6.608264692857215, -2.204391758043112, 3.8328091843913974, 4.122558586426074, 6.79452673601816, -1.8532801154281735, 6.207567645800566]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)", "target": ""}
{"module": "human_eval.py", "name": "LastLetters:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#134", "sol_bodies": ["    return [len(s.split(\" \")[-1]) == 1 and s[-1].isalpha() for s in x]"], "sol_header": "def sol(x=['Hello, world!', 'cat', '', 'a test', 'test a', 'i e', 'o', 'I O U', 'You and I']):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine, for each string in x, whether the last character is an isolated letter\n\n    [\"a b c\", \"abc\"] => [True, False]\n    \"\"\"", "weight": 1.0, "sat": "def sat(y: List[bool], x=['Hello, world!', 'cat', '', 'a test', 'test a', 'i e', 'o', 'I O U', 'You and I']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True", "input": "def sat(y: List[bool], x=['Hello, world!', 'cat', '', 'a test', 'test a', 'i e', 'o', 'I O U', 'You and I']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True", "target": ""}
{"module": "human_eval.py", "name": "LastLetters:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#134", "sol_bodies": ["    return [len(s.split(\" \")[-1]) == 1 and s[-1].isalpha() for s in x]"], "sol_header": "def sol(x=['bymuthuzuxanehun tuwugycyhewavazow 1', ' x', 'womavyra', 'nitex quufojythobubetexto e']):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine, for each string in x, whether the last character is an isolated letter\n\n    [\"a b c\", \"abc\"] => [True, False]\n    \"\"\"", "weight": 1.0, "sat": "def sat(y: List[bool], x=['bymuthuzuxanehun tuwugycyhewavazow 1', ' x', 'womavyra', 'nitex quufojythobubetexto e']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True", "input": "def sat(y: List[bool], x=['bymuthuzuxanehun tuwugycyhewavazow 1', ' x', 'womavyra', 'nitex quufojythobubetexto e']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True", "target": ""}
{"module": "human_eval.py", "name": "LastLetters:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#134", "sol_bodies": ["    return [len(s.split(\" \")[-1]) == 1 and s[-1].isalpha() for s in x]"], "sol_header": "def sol(x=[' D', '', 'xamywathozuch 6', 'zulopatextathusyro *', ' y', 'wuvoguthixytexte textydytoquizazuquyt', 'texta duthu [', 'zebozegifelutaxyquix cabach d', ' C', 'rodumelidet quutaquukythusyb', ' %', 'b (', 'kabezanolipesethyba dyvechikathuwi n', 'fyzotextyhukokydihuc 8', '', 'memadapuc y', 'thavajythysojecywut g', 'wekirevajezexyfitex j', '', 'sekytextyko C', 'pe sobekujodefypo', 'dyjagiko chyfin', ' v', 'nisytextinexochych  ', '', 'ni', 'l zitufutachot R']):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine, for each string in x, whether the last character is an isolated letter\n\n    [\"a b c\", \"abc\"] => [True, False]\n    \"\"\"", "weight": 1.0, "sat": "def sat(y: List[bool], x=[' D', '', 'xamywathozuch 6', 'zulopatextathusyro *', ' y', 'wuvoguthixytexte textydytoquizazuquyt', 'texta duthu [', 'zebozegifelutaxyquix cabach d', ' C', 'rodumelidet quutaquukythusyb', ' %', 'b (', 'kabezanolipesethyba dyvechikathuwi n', 'fyzotextyhukokydihuc 8', '', 'memadapuc y', 'thavajythysojecywut g', 'wekirevajezexyfitex j', '', 'sekytextyko C', 'pe sobekujodefypo', 'dyjagiko chyfin', ' v', 'nisytextinexochych  ', '', 'ni', 'l zitufutachot R']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True", "input": "def sat(y: List[bool], x=[' D', '', 'xamywathozuch 6', 'zulopatextathusyro *', ' y', 'wuvoguthixytexte textydytoquizazuquyt', 'texta duthu [', 'zebozegifelutaxyquix cabach d', ' C', 'rodumelidet quutaquukythusyb', ' %', 'b (', 'kabezanolipesethyba dyvechikathuwi n', 'fyzotextyhukokydihuc 8', '', 'memadapuc y', 'thavajythysojecywut g', 'wekirevajezexyfitex j', '', 'sekytextyko C', 'pe sobekujodefypo', 'dyjagiko chyfin', ' v', 'nisytextinexochych  ', '', 'ni', 'l zitufutachot R']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True", "target": ""}
{"module": "human_eval.py", "name": "LastLetters:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#134", "sol_bodies": ["    return [len(s.split(\" \")[-1]) == 1 and s[-1].isalpha() for s in x]"], "sol_header": "def sol(x=['ryxadec', 'pyfixotibujadyxe', 'mopubywewexi witethig 7', ' !', 'jethi sed c', 'lotextusavufubynyb', 'wuxesafetatextysima pebutextiwafufok', 'tuchonip', ' S', 'xyvovikofutex pylekazuquekedajota E', 'wik xofoxujegerigubo ?', 'gipimakude 1', ' O', ' ^', 'lakiquuvuhenugu vajyquy P', ' 6', 'fezore', 'vabithin textusichytilejocoke', ' B', 'lasuthasebuvy que &', 'mymanuzuzudyc thazufys y', '', ' ?', 'gecohywelawu', 'wath']):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine, for each string in x, whether the last character is an isolated letter\n\n    [\"a b c\", \"abc\"] => [True, False]\n    \"\"\"", "weight": 1.0, "sat": "def sat(y: List[bool], x=['ryxadec', 'pyfixotibujadyxe', 'mopubywewexi witethig 7', ' !', 'jethi sed c', 'lotextusavufubynyb', 'wuxesafetatextysima pebutextiwafufok', 'tuchonip', ' S', 'xyvovikofutex pylekazuquekedajota E', 'wik xofoxujegerigubo ?', 'gipimakude 1', ' O', ' ^', 'lakiquuvuhenugu vajyquy P', ' 6', 'fezore', 'vabithin textusichytilejocoke', ' B', 'lasuthasebuvy que &', 'mymanuzuzudyc thazufys y', '', ' ?', 'gecohywelawu', 'wath']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True", "input": "def sat(y: List[bool], x=['ryxadec', 'pyfixotibujadyxe', 'mopubywewexi witethig 7', ' !', 'jethi sed c', 'lotextusavufubynyb', 'wuxesafetatextysima pebutextiwafufok', 'tuchonip', ' S', 'xyvovikofutex pylekazuquekedajota E', 'wik xofoxujegerigubo ?', 'gipimakude 1', ' O', ' ^', 'lakiquuvuhenugu vajyquy P', ' 6', 'fezore', 'vabithin textusichytilejocoke', ' B', 'lasuthasebuvy que &', 'mymanuzuzudyc thazufys y', '', ' ?', 'gecohywelawu', 'wath']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True", "target": ""}
{"module": "human_eval.py", "name": "LastLetters:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#134", "sol_bodies": ["    return [len(s.split(\" \")[-1]) == 1 and s[-1].isalpha() for s in x]"], "sol_header": "def sol(x=['ribesaquotextytazech #', '', ' Y', 'tychawicemafethupi 3', 'laz kakumynohyw', 'quotextifethixyvo pofukixa l']):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"Determine, for each string in x, whether the last character is an isolated letter\n\n    [\"a b c\", \"abc\"] => [True, False]\n    \"\"\"", "weight": 1.0, "sat": "def sat(y: List[bool], x=['ribesaquotextytazech #', '', ' Y', 'tychawicemafethupi 3', 'laz kakumynohyw', 'quotextifethixyvo pofukixa l']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True", "input": "def sat(y: List[bool], x=['ribesaquotextytazech #', '', ' Y', 'tychawicemafethupi 3', 'laz kakumynohyw', 'quotextifethixyvo pofukixa l']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True", "target": ""}
{"module": "human_eval.py", "name": "Drops:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#135", "sol_bodies": ["    return [i for i in range(1, len(nums)) if nums[i] < nums[i - 1]]"], "sol_header": "def sol(nums=[2, -1, 14, 8, 9, 9, 8, 4, 2, 4, 3, -100, 1000, 18, 4, -2, -3, -3, 1, 0]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the indices for which the nums array drops.\n\n    [1,2,3,0,2,4,1] => [3,6]\n    \"\"\"", "weight": 1.0, "sat": "def sat(drop_indexes: List[int], nums=[2, -1, 14, 8, 9, 9, 8, 4, 2, 4, 3, -100, 1000, 18, 4, -2, -3, -3, 1, 0]):\n    d = 0\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            assert drop_indexes[d] == i\n            d += 1\n    return d == len(drop_indexes)", "input": "def sat(drop_indexes: List[int], nums=[2, -1, 14, 8, 9, 9, 8, 4, 2, 4, 3, -100, 1000, 18, 4, -2, -3, -3, 1, 0]):\n    d = 0\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            assert drop_indexes[d] == i\n            d += 1\n    return d == len(drop_indexes)", "target": ""}
{"module": "human_eval.py", "name": "LargestNegSmallestPos:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#136", "sol_bodies": ["    pos = [n for n in nums if n > 0]\n    neg = [n for n in nums if n < 0]\n    return [max(neg) if neg else 0, min(pos) if pos else 0]"], "sol_header": "def sol(nums=[-10, -4, 100, -40, 2, 2, 3, 17, -50, -25, 18, 41, 9, 11, 15]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the largest negative ans smallest positive numbers (or 0 if none)\n\n    [-2, -4, 14, 50] => [-2, 14]\n    [3, 22] => [0, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(extremes: List[int], nums=[-10, -4, 100, -40, 2, 2, 3, 17, -50, -25, 18, 41, 9, 11, 15]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True", "input": "def sat(extremes: List[int], nums=[-10, -4, 100, -40, 2, 2, 3, 17, -50, -25, 18, 41, 9, 11, 15]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "LargestNegSmallestPos:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#136", "sol_bodies": ["    pos = [n for n in nums if n > 0]\n    neg = [n for n in nums if n < 0]\n    return [max(neg) if neg else 0, min(pos) if pos else 0]"], "sol_header": "def sol(nums=[-566, -114, -971]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the largest negative ans smallest positive numbers (or 0 if none)\n\n    [-2, -4, 14, 50] => [-2, 14]\n    [3, 22] => [0, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(extremes: List[int], nums=[-566, -114, -971]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True", "input": "def sat(extremes: List[int], nums=[-566, -114, -971]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "LargestNegSmallestPos:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#136", "sol_bodies": ["    pos = [n for n in nums if n > 0]\n    neg = [n for n in nums if n < 0]\n    return [max(neg) if neg else 0, min(pos) if pos else 0]"], "sol_header": "def sol(nums=[-90, -123, 227, 905, 613, 735, 988, -215, -190, 272, -920, 581, 212, 317]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the largest negative ans smallest positive numbers (or 0 if none)\n\n    [-2, -4, 14, 50] => [-2, 14]\n    [3, 22] => [0, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(extremes: List[int], nums=[-90, -123, 227, 905, 613, 735, 988, -215, -190, 272, -920, 581, 212, 317]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True", "input": "def sat(extremes: List[int], nums=[-90, -123, 227, 905, 613, 735, 988, -215, -190, 272, -920, 581, 212, 317]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "LargestNegSmallestPos:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#136", "sol_bodies": ["    pos = [n for n in nums if n > 0]\n    neg = [n for n in nums if n < 0]\n    return [max(neg) if neg else 0, min(pos) if pos else 0]"], "sol_header": "def sol(nums=[]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the largest negative ans smallest positive numbers (or 0 if none)\n\n    [-2, -4, 14, 50] => [-2, 14]\n    [3, 22] => [0, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(extremes: List[int], nums=[]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True", "input": "def sat(extremes: List[int], nums=[]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "LargestNegSmallestPos:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#136", "sol_bodies": ["    pos = [n for n in nums if n > 0]\n    neg = [n for n in nums if n < 0]\n    return [max(neg) if neg else 0, min(pos) if pos else 0]"], "sol_header": "def sol(nums=[-719, 922, 52, -861, 495, 327, -955, -301, -542, -257, -712]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the largest negative ans smallest positive numbers (or 0 if none)\n\n    [-2, -4, 14, 50] => [-2, 14]\n    [3, 22] => [0, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(extremes: List[int], nums=[-719, 922, 52, -861, 495, 327, -955, -301, -542, -257, -712]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True", "input": "def sat(extremes: List[int], nums=[-719, 922, 52, -861, 495, 327, -955, -301, -542, -257, -712]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True", "target": ""}
{"module": "human_eval.py", "name": "LargestStringNum:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#137", "sol_bodies": ["    return max(float(s.replace(\",\", \".\")) for s in str_nums)"], "sol_header": "def sol(str_nums=['1,3', '-11', '17.5', '-11', '2', '2.2', '2,2', '4', '-18,18', '99.09']):", "ans_type": "float", "sol_docstring": "    \"\"\"Find the largest number where commas or periods are decimal points\n\n    [\"99,9\", \"100\"] => 100.0\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, str_nums=['1,3', '-11', '17.5', '-11', '2', '2.2', '2,2', '4', '-18,18', '99.09']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found", "input": "def sat(x: float, str_nums=['1,3', '-11', '17.5', '-11', '2', '2.2', '2,2', '4', '-18,18', '99.09']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found", "target": ""}
{"module": "human_eval.py", "name": "LargestStringNum:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#137", "sol_bodies": ["    return max(float(s.replace(\",\", \".\")) for s in str_nums)"], "sol_header": "def sol(str_nums=['31.39683666368859', '73,72440474051831', '72.34060469647804', '73']):", "ans_type": "float", "sol_docstring": "    \"\"\"Find the largest number where commas or periods are decimal points\n\n    [\"99,9\", \"100\"] => 100.0\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, str_nums=['31.39683666368859', '73,72440474051831', '72.34060469647804', '73']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found", "input": "def sat(x: float, str_nums=['31.39683666368859', '73,72440474051831', '72.34060469647804', '73']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found", "target": ""}
{"module": "human_eval.py", "name": "LargestStringNum:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#137", "sol_bodies": ["    return max(float(s.replace(\",\", \".\")) for s in str_nums)"], "sol_header": "def sol(str_nums=['-6', '68', '-100', '42,449764091997196', '-29,24317717823544', '-41.15991554949425', '93.91903086808122', '-40', '95,64713000645497', '10.987133348617888', '-12', '-30', '-67.5420580170809', '58', '66,77819624303987', '-37.8232752327492', '8', '-99', '98']):", "ans_type": "float", "sol_docstring": "    \"\"\"Find the largest number where commas or periods are decimal points\n\n    [\"99,9\", \"100\"] => 100.0\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, str_nums=['-6', '68', '-100', '42,449764091997196', '-29,24317717823544', '-41.15991554949425', '93.91903086808122', '-40', '95,64713000645497', '10.987133348617888', '-12', '-30', '-67.5420580170809', '58', '66,77819624303987', '-37.8232752327492', '8', '-99', '98']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found", "input": "def sat(x: float, str_nums=['-6', '68', '-100', '42,449764091997196', '-29,24317717823544', '-41.15991554949425', '93.91903086808122', '-40', '95,64713000645497', '10.987133348617888', '-12', '-30', '-67.5420580170809', '58', '66,77819624303987', '-37.8232752327492', '8', '-99', '98']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found", "target": ""}
{"module": "human_eval.py", "name": "LargestStringNum:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#137", "sol_bodies": ["    return max(float(s.replace(\",\", \".\")) for s in str_nums)"], "sol_header": "def sol(str_nums=['-13', '-9,405268331489253', '86,60853263788738', '1.6303719756540573', '25,638544353710756']):", "ans_type": "float", "sol_docstring": "    \"\"\"Find the largest number where commas or periods are decimal points\n\n    [\"99,9\", \"100\"] => 100.0\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, str_nums=['-13', '-9,405268331489253', '86,60853263788738', '1.6303719756540573', '25,638544353710756']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found", "input": "def sat(x: float, str_nums=['-13', '-9,405268331489253', '86,60853263788738', '1.6303719756540573', '25,638544353710756']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found", "target": ""}
{"module": "human_eval.py", "name": "LargestStringNum:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#137", "sol_bodies": ["    return max(float(s.replace(\",\", \".\")) for s in str_nums)"], "sol_header": "def sol(str_nums=['-100', '43', '12,380225941003388', '-10', '55', '40,34567619114577', '45', '-26,348841728512014', '-79.01130149535118', '48', '57', '-87', '24,13286574459906', '8', '57.12265333169756', '19,864244993734175', '24', '-82', '22']):", "ans_type": "float", "sol_docstring": "    \"\"\"Find the largest number where commas or periods are decimal points\n\n    [\"99,9\", \"100\"] => 100.0\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, str_nums=['-100', '43', '12,380225941003388', '-10', '55', '40,34567619114577', '45', '-26,348841728512014', '-79.01130149535118', '48', '57', '-87', '24,13286574459906', '8', '57.12265333169756', '19,864244993734175', '24', '-82', '22']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found", "input": "def sat(x: float, str_nums=['-100', '43', '12,380225941003388', '-10', '55', '40,34567619114577', '45', '-26,348841728512014', '-79.01130149535118', '48', '57', '-87', '24,13286574459906', '8', '57.12265333169756', '19,864244993734175', '24', '-82', '22']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found", "target": ""}
{"module": "human_eval.py", "name": "Even4Sum:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#138", "sol_bodies": ["    return [2] * 3 + [n - 6]"], "sol_header": "def sol(n=1234567890):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find four positive even integers whose sum is n\n\n    100 => [22, 24, 26, 28]\"\"\"", "weight": 1.0, "sat": "def sat(summands: List[int], n=1234567890):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)", "input": "def sat(summands: List[int], n=1234567890):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)", "target": ""}
{"module": "human_eval.py", "name": "Even4Sum:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#138", "sol_bodies": ["    return [2] * 3 + [n - 6]"], "sol_header": "def sol(n=8):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find four positive even integers whose sum is n\n\n    100 => [22, 24, 26, 28]\"\"\"", "weight": 1.0, "sat": "def sat(summands: List[int], n=8):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)", "input": "def sat(summands: List[int], n=8):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)", "target": ""}
{"module": "human_eval.py", "name": "Even4Sum:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#138", "sol_bodies": ["    return [2] * 3 + [n - 6]"], "sol_header": "def sol(n=10):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find four positive even integers whose sum is n\n\n    100 => [22, 24, 26, 28]\"\"\"", "weight": 1.0, "sat": "def sat(summands: List[int], n=10):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)", "input": "def sat(summands: List[int], n=10):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)", "target": ""}
{"module": "human_eval.py", "name": "Even4Sum:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#138", "sol_bodies": ["    return [2] * 3 + [n - 6]"], "sol_header": "def sol(n=12):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find four positive even integers whose sum is n\n\n    100 => [22, 24, 26, 28]\"\"\"", "weight": 1.0, "sat": "def sat(summands: List[int], n=12):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)", "input": "def sat(summands: List[int], n=12):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)", "target": ""}
{"module": "human_eval.py", "name": "Even4Sum:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#138", "sol_bodies": ["    return [2] * 3 + [n - 6]"], "sol_header": "def sol(n=465665808):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find four positive even integers whose sum is n\n\n    100 => [22, 24, 26, 28]\"\"\"", "weight": 1.0, "sat": "def sat(summands: List[int], n=465665808):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)", "input": "def sat(summands: List[int], n=465665808):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)", "target": ""}
{"module": "human_eval.py", "name": "InverseSuperFactorial:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#139", "sol_bodies": ["    queue = set(super_factorials)\n    cache = {}\n    n = 1\n    fact = 1\n    s_fact = 1\n    while queue:\n        fact *= n\n        s_fact *= fact\n        if s_fact in queue:\n            queue.remove(s_fact)\n            cache[s_fact] = n\n        n += 1\n    return [cache[sf] for sf in super_factorials]"], "sol_header": "def sol(super_factorials=[1, 2, 1]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.\n\n    [1, 2, 2, 12] => [1, 2, 2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], super_factorials=[1, 2, 1]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True", "input": "def sat(nums: List[int], super_factorials=[1, 2, 1]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True", "target": ""}
{"module": "human_eval.py", "name": "InverseSuperFactorial:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#139", "sol_bodies": ["    queue = set(super_factorials)\n    cache = {}\n    n = 1\n    fact = 1\n    s_fact = 1\n    while queue:\n        fact *= n\n        s_fact *= fact\n        if s_fact in queue:\n            queue.remove(s_fact)\n            cache[s_fact] = n\n        n += 1\n    return [cache[sf] for sf in super_factorials]"], "sol_header": "def sol(super_factorials=[24883200, 288, 24883200, 1834933472251084800000, 125411328000, 5056584744960000, 2, 125411328000, 34560, 1834933472251084800000, 34560]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.\n\n    [1, 2, 2, 12] => [1, 2, 2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], super_factorials=[24883200, 288, 24883200, 1834933472251084800000, 125411328000, 5056584744960000, 2, 125411328000, 34560, 1834933472251084800000, 34560]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True", "input": "def sat(nums: List[int], super_factorials=[24883200, 288, 24883200, 1834933472251084800000, 125411328000, 5056584744960000, 2, 125411328000, 34560, 1834933472251084800000, 34560]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True", "target": ""}
{"module": "human_eval.py", "name": "InverseSuperFactorial:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#139", "sol_bodies": ["    queue = set(super_factorials)\n    cache = {}\n    n = 1\n    fact = 1\n    s_fact = 1\n    while queue:\n        fact *= n\n        s_fact *= fact\n        if s_fact in queue:\n            queue.remove(s_fact)\n            cache[s_fact] = n\n        n += 1\n    return [cache[sf] for sf in super_factorials]"], "sol_header": "def sol(super_factorials=[2, 2, 12, 2, 2, 1, 1834933472251084800000, 1, 24883200, 24883200, 1834933472251084800000]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.\n\n    [1, 2, 2, 12] => [1, 2, 2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], super_factorials=[2, 2, 12, 2, 2, 1, 1834933472251084800000, 1, 24883200, 24883200, 1834933472251084800000]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True", "input": "def sat(nums: List[int], super_factorials=[2, 2, 12, 2, 2, 1, 1834933472251084800000, 1, 24883200, 24883200, 1834933472251084800000]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True", "target": ""}
{"module": "human_eval.py", "name": "InverseSuperFactorial:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#139", "sol_bodies": ["    queue = set(super_factorials)\n    cache = {}\n    n = 1\n    fact = 1\n    s_fact = 1\n    while queue:\n        fact *= n\n        s_fact *= fact\n        if s_fact in queue:\n            queue.remove(s_fact)\n            cache[s_fact] = n\n        n += 1\n    return [cache[sf] for sf in super_factorials]"], "sol_header": "def sol(super_factorials=[1, 1, 12, 2, 12, 12, 2, 2, 12, 2, 24883200]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.\n\n    [1, 2, 2, 12] => [1, 2, 2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], super_factorials=[1, 1, 12, 2, 12, 12, 2, 2, 12, 2, 24883200]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True", "input": "def sat(nums: List[int], super_factorials=[1, 1, 12, 2, 12, 12, 2, 2, 12, 2, 24883200]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True", "target": ""}
{"module": "human_eval.py", "name": "InverseSuperFactorial:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#139", "sol_bodies": ["    queue = set(super_factorials)\n    cache = {}\n    n = 1\n    fact = 1\n    s_fact = 1\n    while queue:\n        fact *= n\n        s_fact *= fact\n        if s_fact in queue:\n            queue.remove(s_fact)\n            cache[s_fact] = n\n        n += 1\n    return [cache[sf] for sf in super_factorials]"], "sol_header": "def sol(super_factorials=[1, 125411328000, 34560, 288, 24883200, 1, 12, 2, 5056584744960000, 1834933472251084800000, 125411328000]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.\n\n    [1, 2, 2, 12] => [1, 2, 2, 3]\n    \"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], super_factorials=[1, 125411328000, 34560, 288, 24883200, 1, 12, 2, 5056584744960000, 1834933472251084800000, 125411328000]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True", "input": "def sat(nums: List[int], super_factorials=[1, 125411328000, 34560, 288, 24883200, 1, 12, 2, 5056584744960000, 1834933472251084800000, 125411328000]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True", "target": ""}
{"module": "human_eval.py", "name": "ExpandSpaces:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#140", "sol_bodies": ["    return target.replace(\"-\", \" \" * 3).replace(\"_\", \" \")"], "sol_header": "def sol(target=\"-Hello,_world!__This_is-so-easy!-\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are\n    replaced by underscores, leads to the target.\n\n    \"_o-k__?-\" => \"  o        k  ?     \"\n    \"\"\"", "weight": 1.0, "sat": "def sat(orig: str, target=\"-Hello,_world!__This_is-so-easy!-\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target", "input": "def sat(orig: str, target=\"-Hello,_world!__This_is-so-easy!-\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target", "target": ""}
{"module": "human_eval.py", "name": "ExpandSpaces:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#140", "sol_bodies": ["    return target.replace(\"-\", \" \" * 3).replace(\"_\", \" \")"], "sol_header": "def sol(target=\"H-d\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are\n    replaced by underscores, leads to the target.\n\n    \"_o-k__?-\" => \"  o        k  ?     \"\n    \"\"\"", "weight": 1.0, "sat": "def sat(orig: str, target=\"H-d\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target", "input": "def sat(orig: str, target=\"H-d\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target", "target": ""}
{"module": "human_eval.py", "name": "ExpandSpaces:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#140", "sol_bodies": ["    return target.replace(\"-\", \" \" * 3).replace(\"_\", \" \")"], "sol_header": "def sol(target=\"\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are\n    replaced by underscores, leads to the target.\n\n    \"_o-k__?-\" => \"  o        k  ?     \"\n    \"\"\"", "weight": 1.0, "sat": "def sat(orig: str, target=\"\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target", "input": "def sat(orig: str, target=\"\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target", "target": ""}
{"module": "human_eval.py", "name": "ExpandSpaces:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#140", "sol_bodies": ["    return target.replace(\"-\", \" \" * 3).replace(\"_\", \" \")"], "sol_header": "def sol(target=\"H@zoxyquygupaxofirefavuvubadigwQ\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are\n    replaced by underscores, leads to the target.\n\n    \"_o-k__?-\" => \"  o        k  ?     \"\n    \"\"\"", "weight": 1.0, "sat": "def sat(orig: str, target=\"H@zoxyquygupaxofirefavuvubadigwQ\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target", "input": "def sat(orig: str, target=\"H@zoxyquygupaxofirefavuvubadigwQ\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target", "target": ""}
{"module": "human_eval.py", "name": "ExpandSpaces:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#140", "sol_bodies": ["    return target.replace(\"-\", \" \" * 3).replace(\"_\", \" \")"], "sol_header": "def sol(target=\"-O!6quag\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are\n    replaced by underscores, leads to the target.\n\n    \"_o-k__?-\" => \"  o        k  ?     \"\n    \"\"\"", "weight": 1.0, "sat": "def sat(orig: str, target=\"-O!6quag\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target", "input": "def sat(orig: str, target=\"-O!6quag\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target", "target": ""}
{"module": "human_eval.py", "name": "FilenameOK:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#141", "sol_bodies": ["    return [\"Yes\" if\n            f.split(\".\")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4\n            else \"No\"\n            for f in filenames]"], "sol_header": "def sol(filenames=['cat.txt', '!jog.dll', '31F9.html', 'Is this okay?.txt', '.exe', '']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename\n    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods\n\n    [\"train.jpg\", \"doc10234.txt\", \"3eadme.txt\"] = [\"No\", \"No\", \"Yes\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(valids: List[str], filenames=['cat.txt', '!jog.dll', '31F9.html', 'Is this okay?.txt', '.exe', '']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True", "input": "def sat(valids: List[str], filenames=['cat.txt', '!jog.dll', '31F9.html', 'Is this okay?.txt', '.exe', '']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FilenameOK:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#141", "sol_bodies": ["    return [\"Yes\" if\n            f.split(\".\")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4\n            else \"No\"\n            for f in filenames]"], "sol_header": "def sol(filenames=['mtherylP.exe', 'Qbatw.mp4', 'DtextadusypykagusakoA.exe', 'Bmigusocycyth].mp4', ')kutextulelucezyQ.tar.zip', 'nchelycozitixiM.exe', 'wrichevyxi.exe', 'Nvew0.txt', 'dnochofazehaxaharop!.dll', '8mefasechuxacyxg.txt', 'isijufotextydycifu3.mp4', 'vmithujydet[.mp4']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename\n    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods\n\n    [\"train.jpg\", \"doc10234.txt\", \"3eadme.txt\"] = [\"No\", \"No\", \"Yes\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(valids: List[str], filenames=['mtherylP.exe', 'Qbatw.mp4', 'DtextadusypykagusakoA.exe', 'Bmigusocycyth].mp4', ')kutextulelucezyQ.tar.zip', 'nchelycozitixiM.exe', 'wrichevyxi.exe', 'Nvew0.txt', 'dnochofazehaxaharop!.dll', '8mefasechuxacyxg.txt', 'isijufotextydycifu3.mp4', 'vmithujydet[.mp4']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True", "input": "def sat(valids: List[str], filenames=['mtherylP.exe', 'Qbatw.mp4', 'DtextadusypykagusakoA.exe', 'Bmigusocycyth].mp4', ')kutextulelucezyQ.tar.zip', 'nchelycozitixiM.exe', 'wrichevyxi.exe', 'Nvew0.txt', 'dnochofazehaxaharop!.dll', '8mefasechuxacyxg.txt', 'isijufotextydycifu3.mp4', 'vmithujydet[.mp4']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FilenameOK:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#141", "sol_bodies": ["    return [\"Yes\" if\n            f.split(\".\")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4\n            else \"No\"\n            for f in filenames]"], "sol_header": "def sol(filenames=['WbytyjachuquithX.tar.zip', 'Pzuzuvetextr.mp4', 'Xcymem[.tar.zip', 'AhypagacheJ.dll', 'JbubefichiwyryzydochC.exe', '8te;.dll', 'wtextoL.mp4', 'mthowexezixexuqd.exe', '^nehapu4.txt', 'Hsovap].txt', 'Cchoxe>.tar.zip', '1quobejugichewabechek#.dll']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename\n    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods\n\n    [\"train.jpg\", \"doc10234.txt\", \"3eadme.txt\"] = [\"No\", \"No\", \"Yes\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(valids: List[str], filenames=['WbytyjachuquithX.tar.zip', 'Pzuzuvetextr.mp4', 'Xcymem[.tar.zip', 'AhypagacheJ.dll', 'JbubefichiwyryzydochC.exe', '8te;.dll', 'wtextoL.mp4', 'mthowexezixexuqd.exe', '^nehapu4.txt', 'Hsovap].txt', 'Cchoxe>.tar.zip', '1quobejugichewabechek#.dll']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True", "input": "def sat(valids: List[str], filenames=['WbytyjachuquithX.tar.zip', 'Pzuzuvetextr.mp4', 'Xcymem[.tar.zip', 'AhypagacheJ.dll', 'JbubefichiwyryzydochC.exe', '8te;.dll', 'wtextoL.mp4', 'mthowexezixexuqd.exe', '^nehapu4.txt', 'Hsovap].txt', 'Cchoxe>.tar.zip', '1quobejugichewabechek#.dll']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FilenameOK:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#141", "sol_bodies": ["    return [\"Yes\" if\n            f.split(\".\")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4\n            else \"No\"\n            for f in filenames]"], "sol_header": "def sol(filenames=['+thunidothytextofi..txt', 'Onithytemolysefel$.mp4', 'Clychifopozesuxijuvo.mp4']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename\n    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods\n\n    [\"train.jpg\", \"doc10234.txt\", \"3eadme.txt\"] = [\"No\", \"No\", \"Yes\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(valids: List[str], filenames=['+thunidothytextofi..txt', 'Onithytemolysefel$.mp4', 'Clychifopozesuxijuvo.mp4']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True", "input": "def sat(valids: List[str], filenames=['+thunidothytextofi..txt', 'Onithytemolysefel$.mp4', 'Clychifopozesuxijuvo.mp4']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True", "target": ""}
{"module": "human_eval.py", "name": "FilenameOK:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#141", "sol_bodies": ["    return [\"Yes\" if\n            f.split(\".\")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4\n            else \"No\"\n            for f in filenames]"], "sol_header": "def sol(filenames=['XsiwemunarytextatecY.exe', 'Dfanachofegerevojyv].dll', ')pethymula0.exe', '4dihurudyjahatextov.exe', '0hyxZ.tar.zip', 'WbywithachoxenomeW.mp4', 'rniworatuzepatapuy.txt', '6quypucocj.exe', 'Zmavifolulitek.txt', 'ywue.exe', 'QhI.txt', ')vugu^.mp4', 'ygihycogaduhalyfyzen.tar.zip', 'icubonaguchegupejuha(.exe', ']gothusodawinuwidinexD.mp4', ' wyw(.exe']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename\n    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods\n\n    [\"train.jpg\", \"doc10234.txt\", \"3eadme.txt\"] = [\"No\", \"No\", \"Yes\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(valids: List[str], filenames=['XsiwemunarytextatecY.exe', 'Dfanachofegerevojyv].dll', ')pethymula0.exe', '4dihurudyjahatextov.exe', '0hyxZ.tar.zip', 'WbywithachoxenomeW.mp4', 'rniworatuzepatapuy.txt', '6quypucocj.exe', 'Zmavifolulitek.txt', 'ywue.exe', 'QhI.txt', ')vugu^.mp4', 'ygihycogaduhalyfyzen.tar.zip', 'icubonaguchegupejuha(.exe', ']gothusodawinuwidinexD.mp4', ' wyw(.exe']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True", "input": "def sat(valids: List[str], filenames=['XsiwemunarytextatecY.exe', 'Dfanachofegerevojyv].dll', ')pethymula0.exe', '4dihurudyjahatextov.exe', '0hyxZ.tar.zip', 'WbywithachoxenomeW.mp4', 'rniworatuzepatapuy.txt', '6quypucocj.exe', 'Zmavifolulitek.txt', 'ywue.exe', 'QhI.txt', ')vugu^.mp4', 'ygihycogaduhalyfyzen.tar.zip', 'icubonaguchegupejuha(.exe', ']gothusodawinuwidinexD.mp4', ' wyw(.exe']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True", "target": ""}
{"module": "human_eval.py", "name": "PrimeWords:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#143", "sol_bodies": ["    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return \" \".join(w for w in s.split() if is_prime(len(w)))"], "sol_header": "def sol(s=\"This is a test of whether you would want to do such strange puzzles\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the string consisting of all the words whose lengths are prime numbers\n\n    \"A bird in the hand is worth two in the bush\" => \"in the is worth two in the\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: str, s=\"This is a test of whether you would want to do such strange puzzles\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)", "input": "def sat(primes: str, s=\"This is a test of whether you would want to do such strange puzzles\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)", "target": ""}
{"module": "human_eval.py", "name": "PrimeWords:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#143", "sol_bodies": ["    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return \" \".join(w for w in s.split() if is_prime(len(w)))"], "sol_header": "def sol(s=\"t quiquitutohetextyvod thacycotextilequa thavow rygo q xythejixojubuz jufutozozat cabuthymuchyji\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the string consisting of all the words whose lengths are prime numbers\n\n    \"A bird in the hand is worth two in the bush\" => \"in the is worth two in the\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: str, s=\"t quiquitutohetextyvod thacycotextilequa thavow rygo q xythejixojubuz jufutozozat cabuthymuchyji\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)", "input": "def sat(primes: str, s=\"t quiquitutohetextyvod thacycotextilequa thavow rygo q xythejixojubuz jufutozozat cabuthymuchyji\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)", "target": ""}
{"module": "human_eval.py", "name": "PrimeWords:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#143", "sol_bodies": ["    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return \" \".join(w for w in s.split() if is_prime(len(w)))"], "sol_header": "def sol(s=\"caquovovich keguqu tatextuhok jajabyv kibatextuchisimoz xibe sotext s helalewipixemujiwixa\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the string consisting of all the words whose lengths are prime numbers\n\n    \"A bird in the hand is worth two in the bush\" => \"in the is worth two in the\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: str, s=\"caquovovich keguqu tatextuhok jajabyv kibatextuchisimoz xibe sotext s helalewipixemujiwixa\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)", "input": "def sat(primes: str, s=\"caquovovich keguqu tatextuhok jajabyv kibatextuchisimoz xibe sotext s helalewipixemujiwixa\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)", "target": ""}
{"module": "human_eval.py", "name": "PrimeWords:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#143", "sol_bodies": ["    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return \" \".join(w for w in s.split() if is_prime(len(w)))"], "sol_header": "def sol(s=\"\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the string consisting of all the words whose lengths are prime numbers\n\n    \"A bird in the hand is worth two in the bush\" => \"in the is worth two in the\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: str, s=\"\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)", "input": "def sat(primes: str, s=\"\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)", "target": ""}
{"module": "human_eval.py", "name": "PrimeWords:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#143", "sol_bodies": ["    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return \" \".join(w for w in s.split() if is_prime(len(w)))"], "sol_header": "def sol(s=\"sidathochocek qualodu thugolo wywyfykyxyhewyjapeke matofamep n wemahu pesethimine\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find the string consisting of all the words whose lengths are prime numbers\n\n    \"A bird in the hand is worth two in the bush\" => \"in the is worth two in the\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(primes: str, s=\"sidathochocek qualodu thugolo wywyfykyxyhewyjapeke matofamep n wemahu pesethimine\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)", "input": "def sat(primes: str, s=\"sidathochocek qualodu thugolo wywyfykyxyhewyjapeke matofamep n wemahu pesethimine\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)", "target": ""}
{"module": "human_eval.py", "name": "SimplifyProductFraction:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#144", "sol_bodies": ["    [[a, b], [c, d]] = [[int(n) for n in s.split(\"/\")] for s in [x, y]]\n    num, den = a * c, b * d\n    if num < 0 and den < 0:\n        num, den = -num, -den\n    if num == 0:\n        return \"0/1\"\n\n    def gcd(a, b):\n        a, b = min(a, b), max(a, b)\n        if b % a == 0:\n            return a\n        return gcd(b % a, a)\n\n    d = gcd(abs(num), abs(den))\n    return f'{num // d}/{den // d}'"], "sol_header": "def sol(x=\"-8142432/763083\", y=\"66/-13474\", max_len=18):", "ans_type": "str", "sol_docstring": "    \"\"\"Write x * y as the shortest equivalent fraction using at most max_len chars\n\n    x=\"-2/3\", y=\"-3/8\", max_len=3 => \"1/4\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(z: str, x=\"-8142432/763083\", y=\"66/-13474\", max_len=18):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len", "input": "def sat(z: str, x=\"-8142432/763083\", y=\"66/-13474\", max_len=18):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len", "target": ""}
{"module": "human_eval.py", "name": "SimplifyProductFraction:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#144", "sol_bodies": ["    [[a, b], [c, d]] = [[int(n) for n in s.split(\"/\")] for s in [x, y]]\n    num, den = a * c, b * d\n    if num < 0 and den < 0:\n        num, den = -num, -den\n    if num == 0:\n        return \"0/1\"\n\n    def gcd(a, b):\n        a, b = min(a, b), max(a, b)\n        if b % a == 0:\n            return a\n        return gcd(b % a, a)\n\n    d = gcd(abs(num), abs(den))\n    return f'{num // d}/{den // d}'"], "sol_header": "def sol(x=\"0/47460\", y=\"357/8389715\", max_len=3):", "ans_type": "str", "sol_docstring": "    \"\"\"Write x * y as the shortest equivalent fraction using at most max_len chars\n\n    x=\"-2/3\", y=\"-3/8\", max_len=3 => \"1/4\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(z: str, x=\"0/47460\", y=\"357/8389715\", max_len=3):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len", "input": "def sat(z: str, x=\"0/47460\", y=\"357/8389715\", max_len=3):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len", "target": ""}
{"module": "human_eval.py", "name": "SimplifyProductFraction:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#144", "sol_bodies": ["    [[a, b], [c, d]] = [[int(n) for n in s.split(\"/\")] for s in [x, y]]\n    num, den = a * c, b * d\n    if num < 0 and den < 0:\n        num, den = -num, -den\n    if num == 0:\n        return \"0/1\"\n\n    def gcd(a, b):\n        a, b = min(a, b), max(a, b)\n        if b % a == 0:\n            return a\n        return gcd(b % a, a)\n\n    d = gcd(abs(num), abs(den))\n    return f'{num // d}/{den // d}'"], "sol_header": "def sol(x=\"-20/-54383610\", y=\"7865/34\", max_len=13):", "ans_type": "str", "sol_docstring": "    \"\"\"Write x * y as the shortest equivalent fraction using at most max_len chars\n\n    x=\"-2/3\", y=\"-3/8\", max_len=3 => \"1/4\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(z: str, x=\"-20/-54383610\", y=\"7865/34\", max_len=13):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len", "input": "def sat(z: str, x=\"-20/-54383610\", y=\"7865/34\", max_len=13):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len", "target": ""}
{"module": "human_eval.py", "name": "SimplifyProductFraction:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#144", "sol_bodies": ["    [[a, b], [c, d]] = [[int(n) for n in s.split(\"/\")] for s in [x, y]]\n    num, den = a * c, b * d\n    if num < 0 and den < 0:\n        num, den = -num, -den\n    if num == 0:\n        return \"0/1\"\n\n    def gcd(a, b):\n        a, b = min(a, b), max(a, b)\n        if b % a == 0:\n            return a\n        return gcd(b % a, a)\n\n    d = gcd(abs(num), abs(den))\n    return f'{num // d}/{den // d}'"], "sol_header": "def sol(x=\"0/2\", y=\"79/45361\", max_len=3):", "ans_type": "str", "sol_docstring": "    \"\"\"Write x * y as the shortest equivalent fraction using at most max_len chars\n\n    x=\"-2/3\", y=\"-3/8\", max_len=3 => \"1/4\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(z: str, x=\"0/2\", y=\"79/45361\", max_len=3):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len", "input": "def sat(z: str, x=\"0/2\", y=\"79/45361\", max_len=3):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len", "target": ""}
{"module": "human_eval.py", "name": "SimplifyProductFraction:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#144", "sol_bodies": ["    [[a, b], [c, d]] = [[int(n) for n in s.split(\"/\")] for s in [x, y]]\n    num, den = a * c, b * d\n    if num < 0 and den < 0:\n        num, den = -num, -den\n    if num == 0:\n        return \"0/1\"\n\n    def gcd(a, b):\n        a, b = min(a, b), max(a, b)\n        if b % a == 0:\n            return a\n        return gcd(b % a, a)\n\n    d = gcd(abs(num), abs(den))\n    return f'{num // d}/{den // d}'"], "sol_header": "def sol(x=\"1316/-4820197\", y=\"0/28968\", max_len=3):", "ans_type": "str", "sol_docstring": "    \"\"\"Write x * y as the shortest equivalent fraction using at most max_len chars\n\n    x=\"-2/3\", y=\"-3/8\", max_len=3 => \"1/4\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(z: str, x=\"1316/-4820197\", y=\"0/28968\", max_len=3):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len", "input": "def sat(z: str, x=\"1316/-4820197\", y=\"0/28968\", max_len=3):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len", "target": ""}
{"module": "human_eval.py", "name": "SortByDigitSum:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#145", "sol_bodies": ["    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != \"-\"))"], "sol_header": "def sol(nums=[1, 0, -1, -100, 10, 14, 235251, 11, 10000, 2000001, -155]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Sort the numbers by the sum of their digits\n\n    [17, 21, 0] => [0, 17, 21]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ordered: List[int], nums=[1, 0, -1, -100, 10, 14, 235251, 11, 10000, 2000001, -155]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)", "input": "def sat(ordered: List[int], nums=[1, 0, -1, -100, 10, 14, 235251, 11, 10000, 2000001, -155]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)", "target": ""}
{"module": "human_eval.py", "name": "SortByDigitSum:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#145", "sol_bodies": ["    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != \"-\"))"], "sol_header": "def sol(nums=[-222, -896, 914, 817]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Sort the numbers by the sum of their digits\n\n    [17, 21, 0] => [0, 17, 21]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ordered: List[int], nums=[-222, -896, 914, 817]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)", "input": "def sat(ordered: List[int], nums=[-222, -896, 914, 817]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)", "target": ""}
{"module": "human_eval.py", "name": "SortByDigitSum:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#145", "sol_bodies": ["    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != \"-\"))"], "sol_header": "def sol(nums=[208]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Sort the numbers by the sum of their digits\n\n    [17, 21, 0] => [0, 17, 21]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ordered: List[int], nums=[208]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)", "input": "def sat(ordered: List[int], nums=[208]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)", "target": ""}
{"module": "human_eval.py", "name": "SortByDigitSum:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#145", "sol_bodies": ["    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != \"-\"))"], "sol_header": "def sol(nums=[]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Sort the numbers by the sum of their digits\n\n    [17, 21, 0] => [0, 17, 21]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ordered: List[int], nums=[]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)", "input": "def sat(ordered: List[int], nums=[]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)", "target": ""}
{"module": "human_eval.py", "name": "SortByDigitSum:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#145", "sol_bodies": ["    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != \"-\"))"], "sol_header": "def sol(nums=[232, -710]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Sort the numbers by the sum of their digits\n\n    [17, 21, 0] => [0, 17, 21]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ordered: List[int], nums=[232, -710]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)", "input": "def sat(ordered: List[int], nums=[232, -710]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)", "target": ""}
{"module": "human_eval.py", "name": "BigOdds:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#146", "sol_bodies": ["    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]"], "sol_header": "def sol(nums=[204, 109, 203, 17, 45, 11, 21, 99, 909, 16, -33, 3, 17]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the numbers that are greater than 10 and have odd first and last digits\n\n    [73, 4, 72] => [73]\n    \"\"\"", "weight": 1.0, "sat": "def sat(odds: List[int], nums=[204, 109, 203, 17, 45, 11, 21, 99, 909, 16, -33, 3, 17]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)", "input": "def sat(odds: List[int], nums=[204, 109, 203, 17, 45, 11, 21, 99, 909, 16, -33, 3, 17]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)", "target": ""}
{"module": "human_eval.py", "name": "BigOdds:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#146", "sol_bodies": ["    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]"], "sol_header": "def sol(nums=[13559]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the numbers that are greater than 10 and have odd first and last digits\n\n    [73, 4, 72] => [73]\n    \"\"\"", "weight": 1.0, "sat": "def sat(odds: List[int], nums=[13559]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)", "input": "def sat(odds: List[int], nums=[13559]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)", "target": ""}
{"module": "human_eval.py", "name": "BigOdds:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#146", "sol_bodies": ["    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]"], "sol_header": "def sol(nums=[12320, 771, 11224, 17261]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the numbers that are greater than 10 and have odd first and last digits\n\n    [73, 4, 72] => [73]\n    \"\"\"", "weight": 1.0, "sat": "def sat(odds: List[int], nums=[12320, 771, 11224, 17261]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)", "input": "def sat(odds: List[int], nums=[12320, 771, 11224, 17261]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)", "target": ""}
{"module": "human_eval.py", "name": "BigOdds:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#146", "sol_bodies": ["    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]"], "sol_header": "def sol(nums=[13251, 8503, 5595, 19712, 10196, 16271]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the numbers that are greater than 10 and have odd first and last digits\n\n    [73, 4, 72] => [73]\n    \"\"\"", "weight": 1.0, "sat": "def sat(odds: List[int], nums=[13251, 8503, 5595, 19712, 10196, 16271]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)", "input": "def sat(odds: List[int], nums=[13251, 8503, 5595, 19712, 10196, 16271]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)", "target": ""}
{"module": "human_eval.py", "name": "BigOdds:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#146", "sol_bodies": ["    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]"], "sol_header": "def sol(nums=[]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find the numbers that are greater than 10 and have odd first and last digits\n\n    [73, 4, 72] => [73]\n    \"\"\"", "weight": 1.0, "sat": "def sat(odds: List[int], nums=[]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)", "input": "def sat(odds: List[int], nums=[]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)", "target": ""}
{"module": "human_eval.py", "name": "Threeples:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#147", "sol_bodies": ["    n = len(a)\n    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]"], "sol_header": "def sol(a=[1, 0, -17, 42, 321, 36, 429, 35, 10, 923, 35, 18, 0, 17, 24, 32, 8], count=221):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find all triples of increasing indices where the sum of the numbers is divisible by three\n\n    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(trips: List[List[int]], a=[1, 0, -17, 42, 321, 36, 429, 35, 10, 923, 35, 18, 0, 17, 24, 32, 8], count=221):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)", "input": "def sat(trips: List[List[int]], a=[1, 0, -17, 42, 321, 36, 429, 35, 10, 923, 35, 18, 0, 17, 24, 32, 8], count=221):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)", "target": ""}
{"module": "human_eval.py", "name": "Threeples:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#147", "sol_bodies": ["    n = len(a)\n    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]"], "sol_header": "def sol(a=[8, 5, 9, 3, 3, 9, 2, 6, 6, 0, 8, 0, 3, 2, 5, 2, 3, -1, 6], count=221):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find all triples of increasing indices where the sum of the numbers is divisible by three\n\n    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(trips: List[List[int]], a=[8, 5, 9, 3, 3, 9, 2, 6, 6, 0, 8, 0, 3, 2, 5, 2, 3, -1, 6], count=221):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)", "input": "def sat(trips: List[List[int]], a=[8, 5, 9, 3, 3, 9, 2, 6, 6, 0, 8, 0, 3, 2, 5, 2, 3, -1, 6], count=221):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)", "target": ""}
{"module": "human_eval.py", "name": "Threeples:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#147", "sol_bodies": ["    n = len(a)\n    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]"], "sol_header": "def sol(a=[6, 5, 3, 0, 1, 9, 7, 6, 6, 7, 6, 8, 4, -1, 0, 3, 6, 7, 5, 3], count=399):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find all triples of increasing indices where the sum of the numbers is divisible by three\n\n    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(trips: List[List[int]], a=[6, 5, 3, 0, 1, 9, 7, 6, 6, 7, 6, 8, 4, -1, 0, 3, 6, 7, 5, 3], count=399):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)", "input": "def sat(trips: List[List[int]], a=[6, 5, 3, 0, 1, 9, 7, 6, 6, 7, 6, 8, 4, -1, 0, 3, 6, 7, 5, 3], count=399):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)", "target": ""}
{"module": "human_eval.py", "name": "Threeples:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#147", "sol_bodies": ["    n = len(a)\n    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]"], "sol_header": "def sol(a=[6, 3, 5, -1, 8, 8], count=4):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find all triples of increasing indices where the sum of the numbers is divisible by three\n\n    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(trips: List[List[int]], a=[6, 3, 5, -1, 8, 8], count=4):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)", "input": "def sat(trips: List[List[int]], a=[6, 3, 5, -1, 8, 8], count=4):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)", "target": ""}
{"module": "human_eval.py", "name": "Threeples:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#147", "sol_bodies": ["    n = len(a)\n    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]"], "sol_header": "def sol(a=[7], count=0):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find all triples of increasing indices where the sum of the numbers is divisible by three\n\n    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(trips: List[List[int]], a=[7], count=0):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)", "input": "def sat(trips: List[List[int]], a=[7], count=0):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)", "target": ""}
{"module": "human_eval.py", "name": "PlanetRange:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#148", "sol_bodies": ["    planets = \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\".split()\n    return planets[planets.index(a) + 1:planets.index(b)]"], "sol_header": "def sol(a=\"Mars\", b=\"Neptune\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find all planets between the two given planets\n\n    a=\"Jupiter\", b=\"Pluto\" => [\"Saturn\" \"Uranus\" \"Neptune\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(planets_between: List[str], a=\"Mars\", b=\"Neptune\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"", "input": "def sat(planets_between: List[str], a=\"Mars\", b=\"Neptune\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"", "target": ""}
{"module": "human_eval.py", "name": "PlanetRange:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#148", "sol_bodies": ["    planets = \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\".split()\n    return planets[planets.index(a) + 1:planets.index(b)]"], "sol_header": "def sol(a=\"Venus\", b=\"Neptune\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find all planets between the two given planets\n\n    a=\"Jupiter\", b=\"Pluto\" => [\"Saturn\" \"Uranus\" \"Neptune\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(planets_between: List[str], a=\"Venus\", b=\"Neptune\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"", "input": "def sat(planets_between: List[str], a=\"Venus\", b=\"Neptune\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"", "target": ""}
{"module": "human_eval.py", "name": "PlanetRange:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#148", "sol_bodies": ["    planets = \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\".split()\n    return planets[planets.index(a) + 1:planets.index(b)]"], "sol_header": "def sol(a=\"Venus\", b=\"Earth\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find all planets between the two given planets\n\n    a=\"Jupiter\", b=\"Pluto\" => [\"Saturn\" \"Uranus\" \"Neptune\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(planets_between: List[str], a=\"Venus\", b=\"Earth\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"", "input": "def sat(planets_between: List[str], a=\"Venus\", b=\"Earth\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"", "target": ""}
{"module": "human_eval.py", "name": "PlanetRange:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#148", "sol_bodies": ["    planets = \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\".split()\n    return planets[planets.index(a) + 1:planets.index(b)]"], "sol_header": "def sol(a=\"Earth\", b=\"Jupiter\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find all planets between the two given planets\n\n    a=\"Jupiter\", b=\"Pluto\" => [\"Saturn\" \"Uranus\" \"Neptune\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(planets_between: List[str], a=\"Earth\", b=\"Jupiter\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"", "input": "def sat(planets_between: List[str], a=\"Earth\", b=\"Jupiter\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"", "target": ""}
{"module": "human_eval.py", "name": "PlanetRange:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#148", "sol_bodies": ["    planets = \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\".split()\n    return planets[planets.index(a) + 1:planets.index(b)]"], "sol_header": "def sol(a=\"Earth\", b=\"Uranus\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find all planets between the two given planets\n\n    a=\"Jupiter\", b=\"Pluto\" => [\"Saturn\" \"Uranus\" \"Neptune\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(planets_between: List[str], a=\"Earth\", b=\"Uranus\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"", "input": "def sat(planets_between: List[str], a=\"Earth\", b=\"Uranus\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"", "target": ""}
{"module": "human_eval.py", "name": "EvenWords:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#149", "sol_bodies": ["    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))"], "sol_header": "def sol(words=['The', 'worm', 'ate', 'a', 'bird', 'imagine', 'that', '!', 'Absurd', '!!']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find the even-length words and sort them by length.\n\n    [\"soup\", \"not\", \"splendid\"] => [\"soup\", \"splendid\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(evens: List[str], words=['The', 'worm', 'ate', 'a', 'bird', 'imagine', 'that', '!', 'Absurd', '!!']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)", "input": "def sat(evens: List[str], words=['The', 'worm', 'ate', 'a', 'bird', 'imagine', 'that', '!', 'Absurd', '!!']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)", "target": ""}
{"module": "human_eval.py", "name": "EvenWords:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#149", "sol_bodies": ["    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))"], "sol_header": "def sol(words=['valafytextulu', 'quyjylixyvy', 'mavusegojysaquo']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find the even-length words and sort them by length.\n\n    [\"soup\", \"not\", \"splendid\"] => [\"soup\", \"splendid\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(evens: List[str], words=['valafytextulu', 'quyjylixyvy', 'mavusegojysaquo']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)", "input": "def sat(evens: List[str], words=['valafytextulu', 'quyjylixyvy', 'mavusegojysaquo']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)", "target": ""}
{"module": "human_eval.py", "name": "EvenWords:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#149", "sol_bodies": ["    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))"], "sol_header": "def sol(words=['pemathubolyrav', 'mucyxavofolajig', 'm', 'zyzagynorusybef']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find the even-length words and sort them by length.\n\n    [\"soup\", \"not\", \"splendid\"] => [\"soup\", \"splendid\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(evens: List[str], words=['pemathubolyrav', 'mucyxavofolajig', 'm', 'zyzagynorusybef']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)", "input": "def sat(evens: List[str], words=['pemathubolyrav', 'mucyxavofolajig', 'm', 'zyzagynorusybef']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)", "target": ""}
{"module": "human_eval.py", "name": "EvenWords:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#149", "sol_bodies": ["    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))"], "sol_header": "def sol(words=['bozachogawykon', 'kywicij', 'tylegykivysequ']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find the even-length words and sort them by length.\n\n    [\"soup\", \"not\", \"splendid\"] => [\"soup\", \"splendid\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(evens: List[str], words=['bozachogawykon', 'kywicij', 'tylegykivysequ']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)", "input": "def sat(evens: List[str], words=['bozachogawykon', 'kywicij', 'tylegykivysequ']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)", "target": ""}
{"module": "human_eval.py", "name": "EvenWords:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#149", "sol_bodies": ["    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))"], "sol_header": "def sol(words=['vanafegyfog', 'vipugohuvychu']):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find the even-length words and sort them by length.\n\n    [\"soup\", \"not\", \"splendid\"] => [\"soup\", \"splendid\"]\n    \"\"\"", "weight": 1.0, "sat": "def sat(evens: List[str], words=['vanafegyfog', 'vipugohuvychu']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)", "input": "def sat(evens: List[str], words=['vanafegyfog', 'vipugohuvychu']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)", "target": ""}
{"module": "human_eval.py", "name": "PrimeSel:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#150", "sol_bodies": ["    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return sorted({\n        n for i, n in enumerate(nums)\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))\n    })"], "sol_header": "def sol(nums=[14, 7, 11, 13, 7, 4, 19, 2, 55, 13, 31, 14, 2, 9, -7, 0, 88, 13, 13]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates\n\n    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]\"\"\"", "weight": 1.0, "sat": "def sat(neighbors: List[int], nums=[14, 7, 11, 13, 7, 4, 19, 2, 55, 13, 31, 14, 2, 9, -7, 0, 88, 13, 13]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))", "input": "def sat(neighbors: List[int], nums=[14, 7, 11, 13, 7, 4, 19, 2, 55, 13, 31, 14, 2, 9, -7, 0, 88, 13, 13]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))", "target": ""}
{"module": "human_eval.py", "name": "PrimeSel:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#150", "sol_bodies": ["    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return sorted({\n        n for i, n in enumerate(nums)\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))\n    })"], "sol_header": "def sol(nums=[15, 1, 1, 11, 12, 12, 3, 3, 2, 5, 12, 0, 16, 0, 4, 14, 11, 7, 8]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates\n\n    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]\"\"\"", "weight": 1.0, "sat": "def sat(neighbors: List[int], nums=[15, 1, 1, 11, 12, 12, 3, 3, 2, 5, 12, 0, 16, 0, 4, 14, 11, 7, 8]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))", "input": "def sat(neighbors: List[int], nums=[15, 1, 1, 11, 12, 12, 3, 3, 2, 5, 12, 0, 16, 0, 4, 14, 11, 7, 8]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))", "target": ""}
{"module": "human_eval.py", "name": "PrimeSel:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#150", "sol_bodies": ["    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return sorted({\n        n for i, n in enumerate(nums)\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))\n    })"], "sol_header": "def sol(nums=[1, 15, 19]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates\n\n    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]\"\"\"", "weight": 1.0, "sat": "def sat(neighbors: List[int], nums=[1, 15, 19]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))", "input": "def sat(neighbors: List[int], nums=[1, 15, 19]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))", "target": ""}
{"module": "human_eval.py", "name": "PrimeSel:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#150", "sol_bodies": ["    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return sorted({\n        n for i, n in enumerate(nums)\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))\n    })"], "sol_header": "def sol(nums=[9, 9, 0, 2, 7, 14, 14, 2, 6, 4, -1, 7, 2, 2, 14, 8, 7, 19, 5, 9, 4, 18, 14, 8, 9, 2, -1]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates\n\n    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]\"\"\"", "weight": 1.0, "sat": "def sat(neighbors: List[int], nums=[9, 9, 0, 2, 7, 14, 14, 2, 6, 4, -1, 7, 2, 2, 14, 8, 7, 19, 5, 9, 4, 18, 14, 8, 9, 2, -1]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))", "input": "def sat(neighbors: List[int], nums=[9, 9, 0, 2, 7, 14, 14, 2, 6, 4, -1, 7, 2, 2, 14, 8, 7, 19, 5, 9, 4, 18, 14, 8, 9, 2, -1]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))", "target": ""}
{"module": "human_eval.py", "name": "PrimeSel:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#150", "sol_bodies": ["    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return sorted({\n        n for i, n in enumerate(nums)\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))\n    })"], "sol_header": "def sol(nums=[4, 2, 4, 7, -1, 10, 0, 10, 1, 3, 8, 3, 5, 3, 0, -1, 11, 18, 15, 2, 4, 10, 8, 14, 6, 1, 12, 14, 5]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates\n\n    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]\"\"\"", "weight": 1.0, "sat": "def sat(neighbors: List[int], nums=[4, 2, 4, 7, -1, 10, 0, 10, 1, 3, 8, 3, 5, 3, 0, -1, 11, 18, 15, 2, 4, 10, 8, 14, 6, 1, 12, 14, 5]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))", "input": "def sat(neighbors: List[int], nums=[4, 2, 4, 7, -1, 10, 0, 10, 1, 3, 8, 3, 5, 3, 0, -1, 11, 18, 15, 2, 4, 10, 8, 14, 6, 1, 12, 14, 5]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))", "target": ""}
{"module": "human_eval.py", "name": "ArrayDiff:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#152", "sol_bodies": ["    return [k - i for i, k in zip(a, c)]"], "sol_header": "def sol(a=[1, 2, 3, 0, 4, 17, 2, 4, 5, 9, 8, 4], c=[1, 2, 3, 4, 0, 16, 2, 3, 5, 9, 8, 4]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find an array that when added to vector a gives array vector c\n\n    [1, 2, 3], [4, 17, 5] => [3, 15, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(b: List[int], a=[1, 2, 3, 0, 4, 17, 2, 4, 5, 9, 8, 4], c=[1, 2, 3, 4, 0, 16, 2, 3, 5, 9, 8, 4]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))", "input": "def sat(b: List[int], a=[1, 2, 3, 0, 4, 17, 2, 4, 5, 9, 8, 4], c=[1, 2, 3, 4, 0, 16, 2, 3, 5, 9, 8, 4]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))", "target": ""}
{"module": "human_eval.py", "name": "ArrayDiff:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#152", "sol_bodies": ["    return [k - i for i, k in zip(a, c)]"], "sol_header": "def sol(a=[14, -1, 12, 11, 3, -1, 18, 5, 8, 5, 6, 1], c=[15, 19, 15, 19, 4, 1, 7, 12, -1, 16, 11, 5]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find an array that when added to vector a gives array vector c\n\n    [1, 2, 3], [4, 17, 5] => [3, 15, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(b: List[int], a=[14, -1, 12, 11, 3, -1, 18, 5, 8, 5, 6, 1], c=[15, 19, 15, 19, 4, 1, 7, 12, -1, 16, 11, 5]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))", "input": "def sat(b: List[int], a=[14, -1, 12, 11, 3, -1, 18, 5, 8, 5, 6, 1], c=[15, 19, 15, 19, 4, 1, 7, 12, -1, 16, 11, 5]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))", "target": ""}
{"module": "human_eval.py", "name": "ArrayDiff:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#152", "sol_bodies": ["    return [k - i for i, k in zip(a, c)]"], "sol_header": "def sol(a=[14, 14, 2, 1, 11, 10, 15, 11, 9, 10, 4, 1, 7, 10, 16, 12], c=[5, 11, 16, 8, 19, 12, 19, 9, 10, 11, 14, 18, 2, 2, 0, 17]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find an array that when added to vector a gives array vector c\n\n    [1, 2, 3], [4, 17, 5] => [3, 15, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(b: List[int], a=[14, 14, 2, 1, 11, 10, 15, 11, 9, 10, 4, 1, 7, 10, 16, 12], c=[5, 11, 16, 8, 19, 12, 19, 9, 10, 11, 14, 18, 2, 2, 0, 17]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))", "input": "def sat(b: List[int], a=[14, 14, 2, 1, 11, 10, 15, 11, 9, 10, 4, 1, 7, 10, 16, 12], c=[5, 11, 16, 8, 19, 12, 19, 9, 10, 11, 14, 18, 2, 2, 0, 17]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))", "target": ""}
{"module": "human_eval.py", "name": "ArrayDiff:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#152", "sol_bodies": ["    return [k - i for i, k in zip(a, c)]"], "sol_header": "def sol(a=[4, 8, 14, 17, 15, -1, 17, 8, -1, 4, 3, 10, 2, 13, 1], c=[13, 14, 11, 18, 16, 8, 14, 3, 0, 9, 7, 19, 11, 15, 9]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find an array that when added to vector a gives array vector c\n\n    [1, 2, 3], [4, 17, 5] => [3, 15, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(b: List[int], a=[4, 8, 14, 17, 15, -1, 17, 8, -1, 4, 3, 10, 2, 13, 1], c=[13, 14, 11, 18, 16, 8, 14, 3, 0, 9, 7, 19, 11, 15, 9]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))", "input": "def sat(b: List[int], a=[4, 8, 14, 17, 15, -1, 17, 8, -1, 4, 3, 10, 2, 13, 1], c=[13, 14, 11, 18, 16, 8, 14, 3, 0, 9, 7, 19, 11, 15, 9]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))", "target": ""}
{"module": "human_eval.py", "name": "ArrayDiff:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#152", "sol_bodies": ["    return [k - i for i, k in zip(a, c)]"], "sol_header": "def sol(a=[13, 10, 7, 7, 1, 10, 0, 17, 5, 14, 10, 14], c=[13, 13, 17, 4, 18, 17, 12, 16, 0, 3, 12, 14]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find an array that when added to vector a gives array vector c\n\n    [1, 2, 3], [4, 17, 5] => [3, 15, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(b: List[int], a=[13, 10, 7, 7, 1, 10, 0, 17, 5, 14, 10, 14], c=[13, 13, 17, 4, 18, 17, 12, 16, 0, 3, 12, 14]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))", "input": "def sat(b: List[int], a=[13, 10, 7, 7, 1, 10, 0, 17, 5, 14, 10, 14], c=[13, 13, 17, 4, 18, 17, 12, 16, 0, 3, 12, 14]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))", "target": ""}
{"module": "human_eval.py", "name": "RotateString:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#154\n\nThis puzzle (and RotateSort from #109) use the fact that a string is a rotation of r if it is a substring of r+r", "sol_bodies": ["    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)"], "sol_header": "def sol(s=\"light star\", t=\"I love to look at the starlight!\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a rotation of string s that is a substring of t\n\n    Input Example:\n    s=\"test\", t=\"I love lattes\"\n\n    Output Example:\n    \"ttes\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(r: str, s=\"light star\", t=\"I love to look at the starlight!\"):\n    return r in t and len(r) == len(s) and r in s + s", "input": "def sat(r: str, s=\"light star\", t=\"I love to look at the starlight!\"):\n    return r in t and len(r) == len(s) and r in s + s", "target": ""}
{"module": "human_eval.py", "name": "RotateString:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#154\n\nThis puzzle (and RotateSort from #109) use the fact that a string is a rotation of r if it is a substring of r+r", "sol_bodies": ["    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)"], "sol_header": "def sol(s=\"fuz tox banu dukukyjosuthihono\", t=\"sikysefylacywitijuz thosowehiv kiviwas girezol betext lepumarasithihonofuz tox banu dukukyjosutog kuquinecakyt\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a rotation of string s that is a substring of t\n\n    Input Example:\n    s=\"test\", t=\"I love lattes\"\n\n    Output Example:\n    \"ttes\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(r: str, s=\"fuz tox banu dukukyjosuthihono\", t=\"sikysefylacywitijuz thosowehiv kiviwas girezol betext lepumarasithihonofuz tox banu dukukyjosutog kuquinecakyt\"):\n    return r in t and len(r) == len(s) and r in s + s", "input": "def sat(r: str, s=\"fuz tox banu dukukyjosuthihono\", t=\"sikysefylacywitijuz thosowehiv kiviwas girezol betext lepumarasithihonofuz tox banu dukukyjosutog kuquinecakyt\"):\n    return r in t and len(r) == len(s) and r in s + s", "target": ""}
{"module": "human_eval.py", "name": "RotateString:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#154\n\nThis puzzle (and RotateSort from #109) use the fact that a string is a rotation of r if it is a substring of r+r", "sol_bodies": ["    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)"], "sol_header": "def sol(s=\"vyquaquabuwuktus tyryrezywovimu sopikalo \", t=\"zugu benuzyca cafoca gawy sycapoxitus tyryrezywovimu sopikalo vyquaquabuwuko citextytextythakidu basikyched\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a rotation of string s that is a substring of t\n\n    Input Example:\n    s=\"test\", t=\"I love lattes\"\n\n    Output Example:\n    \"ttes\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(r: str, s=\"vyquaquabuwuktus tyryrezywovimu sopikalo \", t=\"zugu benuzyca cafoca gawy sycapoxitus tyryrezywovimu sopikalo vyquaquabuwuko citextytextythakidu basikyched\"):\n    return r in t and len(r) == len(s) and r in s + s", "input": "def sat(r: str, s=\"vyquaquabuwuktus tyryrezywovimu sopikalo \", t=\"zugu benuzyca cafoca gawy sycapoxitus tyryrezywovimu sopikalo vyquaquabuwuko citextytextythakidu basikyched\"):\n    return r in t and len(r) == len(s) and r in s + s", "target": ""}
{"module": "human_eval.py", "name": "RotateString:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#154\n\nThis puzzle (and RotateSort from #109) use the fact that a string is a rotation of r if it is a substring of r+r", "sol_bodies": ["    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)"], "sol_header": "def sol(s=\"udynybu cequelynxebalu w guh\", t=\"zigoxesychujocefete nyquuquu wubupi quidoxebalu w guhudynybu cequelynuquumythaku xet syquaxatext lizevachuciconolove\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a rotation of string s that is a substring of t\n\n    Input Example:\n    s=\"test\", t=\"I love lattes\"\n\n    Output Example:\n    \"ttes\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(r: str, s=\"udynybu cequelynxebalu w guh\", t=\"zigoxesychujocefete nyquuquu wubupi quidoxebalu w guhudynybu cequelynuquumythaku xet syquaxatext lizevachuciconolove\"):\n    return r in t and len(r) == len(s) and r in s + s", "input": "def sat(r: str, s=\"udynybu cequelynxebalu w guh\", t=\"zigoxesychujocefete nyquuquu wubupi quidoxebalu w guhudynybu cequelynuquumythaku xet syquaxatext lizevachuciconolove\"):\n    return r in t and len(r) == len(s) and r in s + s", "target": ""}
{"module": "human_eval.py", "name": "RotateString:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#154\n\nThis puzzle (and RotateSort from #109) use the fact that a string is a rotation of r if it is a substring of r+r", "sol_bodies": ["    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)"], "sol_header": "def sol(s=\"fecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kmowe\", t=\"fuch mowefecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kotextu hothakatozate thyzet\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a rotation of string s that is a substring of t\n\n    Input Example:\n    s=\"test\", t=\"I love lattes\"\n\n    Output Example:\n    \"ttes\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(r: str, s=\"fecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kmowe\", t=\"fuch mowefecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kotextu hothakatozate thyzet\"):\n    return r in t and len(r) == len(s) and r in s + s", "input": "def sat(r: str, s=\"fecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kmowe\", t=\"fuch mowefecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kotextu hothakatozate thyzet\"):\n    return r in t and len(r) == len(s) and r in s + s", "target": ""}
{"module": "human_eval.py", "name": "EvenOddDigits:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#155", "sol_bodies": ["    return int(\"2\" * evens + \"1\" * odds)"], "sol_header": "def sol(evens=17, odds=3):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer n >= 0 with the given number of even and odd digits.\n\n    evens=3, odds=4 => 2381695\"\"\"", "weight": 1.0, "sat": "def sat(n: int, evens=17, odds=3):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0", "input": "def sat(n: int, evens=17, odds=3):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0", "target": ""}
{"module": "human_eval.py", "name": "EvenOddDigits:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#155", "sol_bodies": ["    return int(\"2\" * evens + \"1\" * odds)"], "sol_header": "def sol(evens=117, odds=56):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer n >= 0 with the given number of even and odd digits.\n\n    evens=3, odds=4 => 2381695\"\"\"", "weight": 1.0, "sat": "def sat(n: int, evens=117, odds=56):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0", "input": "def sat(n: int, evens=117, odds=56):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0", "target": ""}
{"module": "human_eval.py", "name": "EvenOddDigits:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#155", "sol_bodies": ["    return int(\"2\" * evens + \"1\" * odds)"], "sol_header": "def sol(evens=114, odds=119):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer n >= 0 with the given number of even and odd digits.\n\n    evens=3, odds=4 => 2381695\"\"\"", "weight": 1.0, "sat": "def sat(n: int, evens=114, odds=119):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0", "input": "def sat(n: int, evens=114, odds=119):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0", "target": ""}
{"module": "human_eval.py", "name": "EvenOddDigits:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#155", "sol_bodies": ["    return int(\"2\" * evens + \"1\" * odds)"], "sol_header": "def sol(evens=133, odds=33):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer n >= 0 with the given number of even and odd digits.\n\n    evens=3, odds=4 => 2381695\"\"\"", "weight": 1.0, "sat": "def sat(n: int, evens=133, odds=33):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0", "input": "def sat(n: int, evens=133, odds=33):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0", "target": ""}
{"module": "human_eval.py", "name": "EvenOddDigits:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#155", "sol_bodies": ["    return int(\"2\" * evens + \"1\" * odds)"], "sol_header": "def sol(evens=8, odds=114):", "ans_type": "int", "sol_docstring": "    \"\"\"Find an integer n >= 0 with the given number of even and odd digits.\n\n    evens=3, odds=4 => 2381695\"\"\"", "weight": 1.0, "sat": "def sat(n: int, evens=8, odds=114):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0", "input": "def sat(n: int, evens=8, odds=114):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0", "target": ""}
{"module": "human_eval.py", "name": "RomanNumerals:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#156\n    \nDo not add a reverse puzzle converting roman numerals to arabic numbers as it would give away the solution.", "sol_bodies": ["    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)\n    roman = \"\"\n    for s, i in units.items():\n        while n >= i:\n            roman += s\n            n -= i\n    return roman"], "sol_header": "def sol(n=2414):", "ans_type": "str", "sol_docstring": "    \"\"\"Convert integer 0 < n < 4000 to roman numerals, and make it lowercase\n\n    11 => \"xi\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(roman: str, n=2414):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n", "input": "def sat(roman: str, n=2414):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n", "target": ""}
{"module": "human_eval.py", "name": "RomanNumerals:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#156\n    \nDo not add a reverse puzzle converting roman numerals to arabic numbers as it would give away the solution.", "sol_bodies": ["    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)\n    roman = \"\"\n    for s, i in units.items():\n        while n >= i:\n            roman += s\n            n -= i\n    return roman"], "sol_header": "def sol(n=2058):", "ans_type": "str", "sol_docstring": "    \"\"\"Convert integer 0 < n < 4000 to roman numerals, and make it lowercase\n\n    11 => \"xi\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(roman: str, n=2058):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n", "input": "def sat(roman: str, n=2058):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n", "target": ""}
{"module": "human_eval.py", "name": "RomanNumerals:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#156\n    \nDo not add a reverse puzzle converting roman numerals to arabic numbers as it would give away the solution.", "sol_bodies": ["    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)\n    roman = \"\"\n    for s, i in units.items():\n        while n >= i:\n            roman += s\n            n -= i\n    return roman"], "sol_header": "def sol(n=1467):", "ans_type": "str", "sol_docstring": "    \"\"\"Convert integer 0 < n < 4000 to roman numerals, and make it lowercase\n\n    11 => \"xi\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(roman: str, n=1467):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n", "input": "def sat(roman: str, n=1467):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n", "target": ""}
{"module": "human_eval.py", "name": "RomanNumerals:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#156\n    \nDo not add a reverse puzzle converting roman numerals to arabic numbers as it would give away the solution.", "sol_bodies": ["    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)\n    roman = \"\"\n    for s, i in units.items():\n        while n >= i:\n            roman += s\n            n -= i\n    return roman"], "sol_header": "def sol(n=1533):", "ans_type": "str", "sol_docstring": "    \"\"\"Convert integer 0 < n < 4000 to roman numerals, and make it lowercase\n\n    11 => \"xi\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(roman: str, n=1533):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n", "input": "def sat(roman: str, n=1533):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n", "target": ""}
{"module": "human_eval.py", "name": "RomanNumerals:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#156\n    \nDo not add a reverse puzzle converting roman numerals to arabic numbers as it would give away the solution.", "sol_bodies": ["    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)\n    roman = \"\"\n    for s, i in units.items():\n        while n >= i:\n            roman += s\n            n -= i\n    return roman"], "sol_header": "def sol(n=114):", "ans_type": "str", "sol_docstring": "    \"\"\"Convert integer 0 < n < 4000 to roman numerals, and make it lowercase\n\n    11 => \"xi\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(roman: str, n=114):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n", "input": "def sat(roman: str, n=114):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n", "target": ""}
{"module": "human_eval.py", "name": "PythagoreanTriples:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#157", "sol_bodies": ["    return [[a, b, int((a * a + b * b) ** 0.5)]\n            for a in range(3, int(n / (2 ** 0.5)))\n            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)\n            if ((a * a + b * b) ** 0.5).is_integer()]"], "sol_header": "def sol(n=920, m=799):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order\n\n    (n=6, m=1) => [[3, 4, 5]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(triples: List[List[int]], n=920, m=799):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m", "input": "def sat(triples: List[List[int]], n=920, m=799):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m", "target": ""}
{"module": "human_eval.py", "name": "PythagoreanTriples:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#157", "sol_bodies": ["    return [[a, b, int((a * a + b * b) ** 0.5)]\n            for a in range(3, int(n / (2 ** 0.5)))\n            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)\n            if ((a * a + b * b) ** 0.5).is_integer()]"], "sol_header": "def sol(n=847, m=721):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order\n\n    (n=6, m=1) => [[3, 4, 5]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(triples: List[List[int]], n=847, m=721):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m", "input": "def sat(triples: List[List[int]], n=847, m=721):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m", "target": ""}
{"module": "human_eval.py", "name": "PythagoreanTriples:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#157", "sol_bodies": ["    return [[a, b, int((a * a + b * b) ** 0.5)]\n            for a in range(3, int(n / (2 ** 0.5)))\n            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)\n            if ((a * a + b * b) ** 0.5).is_integer()]"], "sol_header": "def sol(n=646, m=523):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order\n\n    (n=6, m=1) => [[3, 4, 5]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(triples: List[List[int]], n=646, m=523):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m", "input": "def sat(triples: List[List[int]], n=646, m=523):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m", "target": ""}
{"module": "human_eval.py", "name": "PythagoreanTriples:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#157", "sol_bodies": ["    return [[a, b, int((a * a + b * b) ** 0.5)]\n            for a in range(3, int(n / (2 ** 0.5)))\n            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)\n            if ((a * a + b * b) ** 0.5).is_integer()]"], "sol_header": "def sol(n=901, m=780):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order\n\n    (n=6, m=1) => [[3, 4, 5]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(triples: List[List[int]], n=901, m=780):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m", "input": "def sat(triples: List[List[int]], n=901, m=780):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m", "target": ""}
{"module": "human_eval.py", "name": "PythagoreanTriples:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#157", "sol_bodies": ["    return [[a, b, int((a * a + b * b) ** 0.5)]\n            for a in range(3, int(n / (2 ** 0.5)))\n            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)\n            if ((a * a + b * b) ** 0.5).is_integer()]"], "sol_header": "def sol(n=936, m=817):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order\n\n    (n=6, m=1) => [[3, 4, 5]]\n    \"\"\"", "weight": 1.0, "sat": "def sat(triples: List[List[int]], n=936, m=817):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m", "input": "def sat(triples: List[List[int]], n=936, m=817):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m", "target": ""}
{"module": "human_eval.py", "name": "MostUnique:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#158", "sol_bodies": ["    return max(pool, key=lambda x: len(set(x)))"], "sol_header": "def sol(pool=['cat', 'catatatatctsa', 'abcdefhijklmnop', '124259239185125', '', 'foo', 'unique']):", "ans_type": "str", "sol_docstring": "    \"\"\"Select a string from the pool with the most unique characters\n\n    [\"woooow\", \"cow\"] => \"cow\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, pool=['cat', 'catatatatctsa', 'abcdefhijklmnop', '124259239185125', '', 'foo', 'unique']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True", "input": "def sat(s: str, pool=['cat', 'catatatatctsa', 'abcdefhijklmnop', '124259239185125', '', 'foo', 'unique']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True", "target": ""}
{"module": "human_eval.py", "name": "MostUnique:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#158", "sol_bodies": ["    return max(pool, key=lambda x: len(set(x)))"], "sol_header": "def sol(pool=['sibiloguhujuquenam', 'nyzidikedutexti', 'zatextuquyvakijahixa', 'textujig', 'cewynyrimatex', 'textusaxinypuhyheza']):", "ans_type": "str", "sol_docstring": "    \"\"\"Select a string from the pool with the most unique characters\n\n    [\"woooow\", \"cow\"] => \"cow\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, pool=['sibiloguhujuquenam', 'nyzidikedutexti', 'zatextuquyvakijahixa', 'textujig', 'cewynyrimatex', 'textusaxinypuhyheza']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True", "input": "def sat(s: str, pool=['sibiloguhujuquenam', 'nyzidikedutexti', 'zatextuquyvakijahixa', 'textujig', 'cewynyrimatex', 'textusaxinypuhyheza']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True", "target": ""}
{"module": "human_eval.py", "name": "MostUnique:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#158", "sol_bodies": ["    return max(pool, key=lambda x: len(set(x)))"], "sol_header": "def sol(pool=['gylapasugatextysar', 'zapy', 'hycokelet']):", "ans_type": "str", "sol_docstring": "    \"\"\"Select a string from the pool with the most unique characters\n\n    [\"woooow\", \"cow\"] => \"cow\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, pool=['gylapasugatextysar', 'zapy', 'hycokelet']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True", "input": "def sat(s: str, pool=['gylapasugatextysar', 'zapy', 'hycokelet']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True", "target": ""}
{"module": "human_eval.py", "name": "MostUnique:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#158", "sol_bodies": ["    return max(pool, key=lambda x: len(set(x)))"], "sol_header": "def sol(pool=['te', '', 'badypikyxucudil', 'fuhibatextixyburekan', 'chole']):", "ans_type": "str", "sol_docstring": "    \"\"\"Select a string from the pool with the most unique characters\n\n    [\"woooow\", \"cow\"] => \"cow\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, pool=['te', '', 'badypikyxucudil', 'fuhibatextixyburekan', 'chole']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True", "input": "def sat(s: str, pool=['te', '', 'badypikyxucudil', 'fuhibatextixyburekan', 'chole']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True", "target": ""}
{"module": "human_eval.py", "name": "MostUnique:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#158", "sol_bodies": ["    return max(pool, key=lambda x: len(set(x)))"], "sol_header": "def sol(pool=['th', 's', 'bulonu', 'r']):", "ans_type": "str", "sol_docstring": "    \"\"\"Select a string from the pool with the most unique characters\n\n    [\"woooow\", \"cow\"] => \"cow\"\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, pool=['th', 's', 'bulonu', 'r']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True", "input": "def sat(s: str, pool=['th', 's', 'bulonu', 'r']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True", "target": ""}
{"module": "human_eval.py", "name": "EvaluateOperators:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#160", "sol_bodies": ["    from itertools import permutations\n    for ops in permutations([\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"]):\n        expr = str(nums[0])\n        for n, op in zip(nums[1:], ops):\n            expr += op + str(n)\n        try:\n            if eval(expr) == target:\n                return list(ops)\n        except (ZeroDivisionError, SyntaxError):\n            pass\n    assert False"], "sol_header": "def sol(target=2021, nums=[4, 6, 2, 1, 1, 3, 9]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target\n\n    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => [\"+\", \"*\", \"**\", \"%\", \"//\", \"-\"]\n                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(ops: List[str], target=2021, nums=[4, 6, 2, 1, 1, 3, 9]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target", "input": "def sat(ops: List[str], target=2021, nums=[4, 6, 2, 1, 1, 3, 9]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target", "target": ""}
{"module": "human_eval.py", "name": "EvaluateOperators:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#160", "sol_bodies": ["    from itertools import permutations\n    for ops in permutations([\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"]):\n        expr = str(nums[0])\n        for n, op in zip(nums[1:], ops):\n            expr += op + str(n)\n        try:\n            if eval(expr) == target:\n                return list(ops)\n        except (ZeroDivisionError, SyntaxError):\n            pass\n    assert False"], "sol_header": "def sol(target=4, nums=[5, 4, 8, 9, 3, 6, 2]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target\n\n    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => [\"+\", \"*\", \"**\", \"%\", \"//\", \"-\"]\n                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(ops: List[str], target=4, nums=[5, 4, 8, 9, 3, 6, 2]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target", "input": "def sat(ops: List[str], target=4, nums=[5, 4, 8, 9, 3, 6, 2]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target", "target": ""}
{"module": "human_eval.py", "name": "EvaluateOperators:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#160", "sol_bodies": ["    from itertools import permutations\n    for ops in permutations([\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"]):\n        expr = str(nums[0])\n        for n, op in zip(nums[1:], ops):\n            expr += op + str(n)\n        try:\n            if eval(expr) == target:\n                return list(ops)\n        except (ZeroDivisionError, SyntaxError):\n            pass\n    assert False"], "sol_header": "def sol(target=-24995, nums=[1, 8, 5, 8, 5, 5, 5]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target\n\n    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => [\"+\", \"*\", \"**\", \"%\", \"//\", \"-\"]\n                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(ops: List[str], target=-24995, nums=[1, 8, 5, 8, 5, 5, 5]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target", "input": "def sat(ops: List[str], target=-24995, nums=[1, 8, 5, 8, 5, 5, 5]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target", "target": ""}
{"module": "human_eval.py", "name": "EvaluateOperators:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#160", "sol_bodies": ["    from itertools import permutations\n    for ops in permutations([\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"]):\n        expr = str(nums[0])\n        for n, op in zip(nums[1:], ops):\n            expr += op + str(n)\n        try:\n            if eval(expr) == target:\n                return list(ops)\n        except (ZeroDivisionError, SyntaxError):\n            pass\n    assert False"], "sol_header": "def sol(target=6, nums=[7, 4, 4, 2, 4, 1, 6]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target\n\n    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => [\"+\", \"*\", \"**\", \"%\", \"//\", \"-\"]\n                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(ops: List[str], target=6, nums=[7, 4, 4, 2, 4, 1, 6]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target", "input": "def sat(ops: List[str], target=6, nums=[7, 4, 4, 2, 4, 1, 6]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target", "target": ""}
{"module": "human_eval.py", "name": "EvaluateOperators:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#160", "sol_bodies": ["    from itertools import permutations\n    for ops in permutations([\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"]):\n        expr = str(nums[0])\n        for n, op in zip(nums[1:], ops):\n            expr += op + str(n)\n        try:\n            if eval(expr) == target:\n                return list(ops)\n        except (ZeroDivisionError, SyntaxError):\n            pass\n    assert False"], "sol_header": "def sol(target=38, nums=[6, 2, 1, 7, 1, 3, 1]):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target\n\n    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => [\"+\", \"*\", \"**\", \"%\", \"//\", \"-\"]\n                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3\n    \"\"\"", "weight": 1.0, "sat": "def sat(ops: List[str], target=38, nums=[6, 2, 1, 7, 1, 3, 1]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target", "input": "def sat(ops: List[str], target=38, nums=[6, 2, 1, 7, 1, 3, 1]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target", "target": ""}
{"module": "human_eval.py", "name": "ZobristCollision:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#162\n\nThe original problem was to compute an MD5 hash. This puzzle is a problem in the space of hashing, but of a\ndifferent nature.", "sol_bodies": ["    hashes = {}\n    table = [[(i * 429436219 + j * 100239120) % 63491564 for j in range(13)] for i in range(64)]\n\n    def zobrist(pos):\n        h = 0\n        for i in range(64):\n            if pos[i]:\n                h ^= table[i][pos[i]]\n        return h\n\n    for i in range(1, 100000000):\n        pos = [(i * 42 + ((i + 1) * j * 12589) % 54321) % 13 for j in range(64)]  # pseudo-random board\n        h = zobrist(pos)\n        if h in hashes:\n            return [pos, hashes[h]]\n        else:\n            hashes[h] = pos"], "sol_header": "def sol():", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find a collision for the given Zobrist chess board hash: https://en.wikipedia.org/wiki/Zobrist_hashing\n\n    Each of the two positions should be encoded as a list of 64 integers 0-12\"\"\"", "weight": 1.0, "sat": "def sat(positions: List[List[int]]):\n\n    table = [[(i * 429436219 + j * 100239120) % 63491564 for j in range(13)] for i in range(64)]\n\n    def zobrist(pos):\n        h = 0\n        for i in range(64):\n            if pos[i]:\n                h ^= table[i][pos[i]]\n        return h\n\n    a, b = positions\n    return zobrist(a) == zobrist(b) and a != b", "input": "def sat(positions: List[List[int]]):\n\n    table = [[(i * 429436219 + j * 100239120) % 63491564 for j in range(13)] for i in range(64)]\n\n    def zobrist(pos):\n        h = 0\n        for i in range(64):\n            if pos[i]:\n                h ^= table[i][pos[i]]\n        return h\n\n    a, b = positions\n    return zobrist(a) == zobrist(b) and a != b", "target": ""}
{"module": "human_eval.py", "name": "EvenBetween:0", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#163\n\nThe original problem was trivial to list the even single-digit numbers between two numbers:\n`a=2, b=12` => `[4, 6, 8]`. In this puzzle, we consider the string of even numbers formed when counting from\n`a` to `b`, e.g., `\"1618202224262830\"` when counting from `15` to `30`. The puzzle is, given such a string,\nfind `a` and `b`.", "sol_bodies": ["    for i in range(1, len(s)):\n        n = int(s[:i])\n        n -= (n + 1) % 2  # make n odd\n        m = n + 1  # next even\n        t = \"\"\n        while len(t) < len(s):\n            t += str(m)\n            m += 2\n        if s == t:\n            return [n, m - 1]\n\n    assert False"], "sol_header": "def sol(s=\"3298832990329923299432996329983300033002\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers\n    between them gives the string s\n\n    \"32343638\" => [31, 38]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ab: List[int], s=\"3298832990329923299432996329983300033002\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)", "input": "def sat(ab: List[int], s=\"3298832990329923299432996329983300033002\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)", "target": ""}
{"module": "human_eval.py", "name": "EvenBetween:1", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#163\n\nThe original problem was trivial to list the even single-digit numbers between two numbers:\n`a=2, b=12` => `[4, 6, 8]`. In this puzzle, we consider the string of even numbers formed when counting from\n`a` to `b`, e.g., `\"1618202224262830\"` when counting from `15` to `30`. The puzzle is, given such a string,\nfind `a` and `b`.", "sol_bodies": ["    for i in range(1, len(s)):\n        n = int(s[:i])\n        n -= (n + 1) % 2  # make n odd\n        m = n + 1  # next even\n        t = \"\"\n        while len(t) < len(s):\n            t += str(m)\n            m += 2\n        if s == t:\n            return [n, m - 1]\n\n    assert False"], "sol_header": "def sol(s=\"38600386023860438606\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers\n    between them gives the string s\n\n    \"32343638\" => [31, 38]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ab: List[int], s=\"38600386023860438606\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)", "input": "def sat(ab: List[int], s=\"38600386023860438606\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)", "target": ""}
{"module": "human_eval.py", "name": "EvenBetween:2", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#163\n\nThe original problem was trivial to list the even single-digit numbers between two numbers:\n`a=2, b=12` => `[4, 6, 8]`. In this puzzle, we consider the string of even numbers formed when counting from\n`a` to `b`, e.g., `\"1618202224262830\"` when counting from `15` to `30`. The puzzle is, given such a string,\nfind `a` and `b`.", "sol_bodies": ["    for i in range(1, len(s)):\n        n = int(s[:i])\n        n -= (n + 1) % 2  # make n odd\n        m = n + 1  # next even\n        t = \"\"\n        while len(t) < len(s):\n            t += str(m)\n            m += 2\n        if s == t:\n            return [n, m - 1]\n\n    assert False"], "sol_header": "def sol(s=\"254042540625408\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers\n    between them gives the string s\n\n    \"32343638\" => [31, 38]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ab: List[int], s=\"254042540625408\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)", "input": "def sat(ab: List[int], s=\"254042540625408\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)", "target": ""}
{"module": "human_eval.py", "name": "EvenBetween:3", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#163\n\nThe original problem was trivial to list the even single-digit numbers between two numbers:\n`a=2, b=12` => `[4, 6, 8]`. In this puzzle, we consider the string of even numbers formed when counting from\n`a` to `b`, e.g., `\"1618202224262830\"` when counting from `15` to `30`. The puzzle is, given such a string,\nfind `a` and `b`.", "sol_bodies": ["    for i in range(1, len(s)):\n        n = int(s[:i])\n        n -= (n + 1) % 2  # make n odd\n        m = n + 1  # next even\n        t = \"\"\n        while len(t) < len(s):\n            t += str(m)\n            m += 2\n        if s == t:\n            return [n, m - 1]\n\n    assert False"], "sol_header": "def sol(s=\"32880328823288432886\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers\n    between them gives the string s\n\n    \"32343638\" => [31, 38]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ab: List[int], s=\"32880328823288432886\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)", "input": "def sat(ab: List[int], s=\"32880328823288432886\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)", "target": ""}
{"module": "human_eval.py", "name": "EvenBetween:4", "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#163\n\nThe original problem was trivial to list the even single-digit numbers between two numbers:\n`a=2, b=12` => `[4, 6, 8]`. In this puzzle, we consider the string of even numbers formed when counting from\n`a` to `b`, e.g., `\"1618202224262830\"` when counting from `15` to `30`. The puzzle is, given such a string,\nfind `a` and `b`.", "sol_bodies": ["    for i in range(1, len(s)):\n        n = int(s[:i])\n        n -= (n + 1) % 2  # make n odd\n        m = n + 1  # next even\n        t = \"\"\n        while len(t) < len(s):\n            t += str(m)\n            m += 2\n        if s == t:\n            return [n, m - 1]\n\n    assert False"], "sol_header": "def sol(s=\"6062860630606326063460636\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers\n    between them gives the string s\n\n    \"32343638\" => [31, 38]\n    \"\"\"", "weight": 1.0, "sat": "def sat(ab: List[int], s=\"6062860630606326063460636\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)", "input": "def sat(ab: List[int], s=\"6062860630606326063460636\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)", "target": ""}
{"module": "codeforces.py", "name": "IsEven:0", "notes": "Inspired by [Codeforces Problem 4 A](https://codeforces.com/problemset/problem/4/A)", "sol_bodies": ["    return n % 2 == 0"], "sol_header": "def sol(n=10):", "ans_type": "bool", "sol_docstring": "    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"", "weight": 1.0, "sat": "def sat(b: bool, n=10):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False", "input": "def sat(b: bool, n=10):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False", "target": ""}
{"module": "codeforces.py", "name": "IsEven:1", "notes": "Inspired by [Codeforces Problem 4 A](https://codeforces.com/problemset/problem/4/A)", "sol_bodies": ["    return n % 2 == 0"], "sol_header": "def sol(n=0):", "ans_type": "bool", "sol_docstring": "    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"", "weight": 1.0, "sat": "def sat(b: bool, n=0):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False", "input": "def sat(b: bool, n=0):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False", "target": ""}
{"module": "codeforces.py", "name": "IsEven:2", "notes": "Inspired by [Codeforces Problem 4 A](https://codeforces.com/problemset/problem/4/A)", "sol_bodies": ["    return n % 2 == 0"], "sol_header": "def sol(n=1):", "ans_type": "bool", "sol_docstring": "    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"", "weight": 1.0, "sat": "def sat(b: bool, n=1):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False", "input": "def sat(b: bool, n=1):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False", "target": ""}
{"module": "codeforces.py", "name": "IsEven:3", "notes": "Inspired by [Codeforces Problem 4 A](https://codeforces.com/problemset/problem/4/A)", "sol_bodies": ["    return n % 2 == 0"], "sol_header": "def sol(n=2):", "ans_type": "bool", "sol_docstring": "    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"", "weight": 1.0, "sat": "def sat(b: bool, n=2):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False", "input": "def sat(b: bool, n=2):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False", "target": ""}
{"module": "codeforces.py", "name": "IsEven:4", "notes": "Inspired by [Codeforces Problem 4 A](https://codeforces.com/problemset/problem/4/A)", "sol_bodies": ["    return n % 2 == 0"], "sol_header": "def sol(n=3):", "ans_type": "bool", "sol_docstring": "    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"", "weight": 1.0, "sat": "def sat(b: bool, n=3):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False", "input": "def sat(b: bool, n=3):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False", "target": ""}
{"module": "codeforces.py", "name": "SlidingOne:0", "notes": "Inspired by [Codeforces Problem 263 A](https://codeforces.com/problemset/problem/263/A)", "sol_bodies": ["    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"], "sol_header": "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1", "input": "def sat(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1", "target": ""}
{"module": "codeforces.py", "name": "SlidingOne:1", "notes": "Inspired by [Codeforces Problem 263 A](https://codeforces.com/problemset/problem/263/A)", "sol_bodies": ["    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"], "sol_header": "def sol(matrix=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, matrix=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1", "input": "def sat(s: str, matrix=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1", "target": ""}
{"module": "codeforces.py", "name": "SlidingOne:2", "notes": "Inspired by [Codeforces Problem 263 A](https://codeforces.com/problemset/problem/263/A)", "sol_bodies": ["    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"], "sol_header": "def sol(matrix=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, matrix=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1", "input": "def sat(s: str, matrix=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1", "target": ""}
{"module": "codeforces.py", "name": "SlidingOne:3", "notes": "Inspired by [Codeforces Problem 263 A](https://codeforces.com/problemset/problem/263/A)", "sol_bodies": ["    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"], "sol_header": "def sol(matrix=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):", "ans_type": "str", "sol_docstring": "    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"", "weight": 1.0, "sat": "def sat(s: str, matrix=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1", "input": "def sat(s: str, matrix=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1", "target": ""}
{"module": "codeforces.py", "name": "SortPlusPlus:0", "notes": "Inspired by [Codeforces Problem 339 A](https://codeforces.com/problemset/problem/339/A)", "sol_bodies": ["    return \"+\".join(sorted(inp.split(\"+\")))"], "sol_header": "def sol(inp=\"1+1+3+1+3+2+2+1+3+1+2\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"", "weight": 1.0, "sat": "def sat(s: str, inp=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "input": "def sat(s: str, inp=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "target": ""}
{"module": "codeforces.py", "name": "SortPlusPlus:1", "notes": "Inspired by [Codeforces Problem 339 A](https://codeforces.com/problemset/problem/339/A)", "sol_bodies": ["    return \"+\".join(sorted(inp.split(\"+\")))"], "sol_header": "def sol(inp=\"2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"", "weight": 1.0, "sat": "def sat(s: str, inp=\"2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "input": "def sat(s: str, inp=\"2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "target": ""}
{"module": "codeforces.py", "name": "SortPlusPlus:2", "notes": "Inspired by [Codeforces Problem 339 A](https://codeforces.com/problemset/problem/339/A)", "sol_bodies": ["    return \"+\".join(sorted(inp.split(\"+\")))"], "sol_header": "def sol(inp=\"3+2+2\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"", "weight": 1.0, "sat": "def sat(s: str, inp=\"3+2+2\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "input": "def sat(s: str, inp=\"3+2+2\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "target": ""}
{"module": "codeforces.py", "name": "SortPlusPlus:3", "notes": "Inspired by [Codeforces Problem 339 A](https://codeforces.com/problemset/problem/339/A)", "sol_bodies": ["    return \"+\".join(sorted(inp.split(\"+\")))"], "sol_header": "def sol(inp=\"3+2+1+1+3+3+2+2+2+3+2+3+3+1+1\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"", "weight": 1.0, "sat": "def sat(s: str, inp=\"3+2+1+1+3+3+2+2+2+3+2+3+3+1+1\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "input": "def sat(s: str, inp=\"3+2+1+1+3+3+2+2+2+3+2+3+3+1+1\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "target": ""}
{"module": "codeforces.py", "name": "SortPlusPlus:4", "notes": "Inspired by [Codeforces Problem 339 A](https://codeforces.com/problemset/problem/339/A)", "sol_bodies": ["    return \"+\".join(sorted(inp.split(\"+\")))"], "sol_header": "def sol(inp=\"2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"", "weight": 1.0, "sat": "def sat(s: str, inp=\"2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "input": "def sat(s: str, inp=\"2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))", "target": ""}
{"module": "codeforces.py", "name": "FindHomogeneousSubstring:0", "notes": "Inspired by [Codeforces Problem 96 A](https://codeforces.com/problemset/problem/96/A)", "sol_bodies": ["    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)", "    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]", "    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)", "    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"], "sol_header": "def sol(s=\"0000101111111000010\", k=5):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, s=\"0000101111111000010\", k=5):\n    return s[n:n + k] == s[n] * k", "input": "def sat(n: int, s=\"0000101111111000010\", k=5):\n    return s[n:n + k] == s[n] * k", "target": ""}
{"module": "codeforces.py", "name": "FindHomogeneousSubstring:1", "notes": "Inspired by [Codeforces Problem 96 A](https://codeforces.com/problemset/problem/96/A)", "sol_bodies": ["    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)", "    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]", "    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)", "    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"], "sol_header": "def sol(s=\"000000\", k=4):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, s=\"000000\", k=4):\n    return s[n:n + k] == s[n] * k", "input": "def sat(n: int, s=\"000000\", k=4):\n    return s[n:n + k] == s[n] * k", "target": ""}
{"module": "codeforces.py", "name": "FindHomogeneousSubstring:2", "notes": "Inspired by [Codeforces Problem 96 A](https://codeforces.com/problemset/problem/96/A)", "sol_bodies": ["    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)", "    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]", "    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)", "    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"], "sol_header": "def sol(s=\"001100000000000000000000101010100111101110000100\", k=18):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, s=\"001100000000000000000000101010100111101110000100\", k=18):\n    return s[n:n + k] == s[n] * k", "input": "def sat(n: int, s=\"001100000000000000000000101010100111101110000100\", k=18):\n    return s[n:n + k] == s[n] * k", "target": ""}
{"module": "codeforces.py", "name": "FindHomogeneousSubstring:3", "notes": "Inspired by [Codeforces Problem 96 A](https://codeforces.com/problemset/problem/96/A)", "sol_bodies": ["    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)", "    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]", "    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)", "    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"], "sol_header": "def sol(s=\"10100111100110001010011110100111010110010000101101110100010\", k=3):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, s=\"10100111100110001010011110100111010110010000101101110100010\", k=3):\n    return s[n:n + k] == s[n] * k", "input": "def sat(n: int, s=\"10100111100110001010011110100111010110010000101101110100010\", k=3):\n    return s[n:n + k] == s[n] * k", "target": ""}
{"module": "codeforces.py", "name": "FindHomogeneousSubstring:4", "notes": "Inspired by [Codeforces Problem 96 A](https://codeforces.com/problemset/problem/96/A)", "sol_bodies": ["    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)", "    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]", "    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)", "    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"], "sol_header": "def sol(s=\"010110011110100000001010010010001101001110110001111011000000000000000000000011101010111000111011001100111101101\", k=18):", "ans_type": "int", "sol_docstring": "    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"", "weight": 1.0, "sat": "def sat(n: int, s=\"010110011110100000001010010010001101001110110001111011000000000000000000000011101010111000111011001100111101101\", k=18):\n    return s[n:n + k] == s[n] * k", "input": "def sat(n: int, s=\"010110011110100000001010010010001101001110110001111011000000000000000000000011101010111000111011001100111101101\", k=18):\n    return s[n:n + k] == s[n] * k", "target": ""}
{"module": "codeforces.py", "name": "ShortestDecDelta:0", "notes": "Inspired by [Codeforces Problem 617 A](https://codeforces.com/problemset/problem/617/A)", "sol_bodies": ["    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"], "sol_header": "def sol(n=149432, upper=14943):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=149432, upper=14943):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))", "input": "def sat(li: List[int], n=149432, upper=14943):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))", "target": ""}
{"module": "codeforces.py", "name": "ShortestDecDelta:1", "notes": "Inspired by [Codeforces Problem 617 A](https://codeforces.com/problemset/problem/617/A)", "sol_bodies": ["    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"], "sol_header": "def sol(n=493863, upper=49386):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=493863, upper=49386):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))", "input": "def sat(li: List[int], n=493863, upper=49386):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))", "target": ""}
{"module": "codeforces.py", "name": "ShortestDecDelta:2", "notes": "Inspired by [Codeforces Problem 617 A](https://codeforces.com/problemset/problem/617/A)", "sol_bodies": ["    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"], "sol_header": "def sol(n=827208, upper=82720):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=827208, upper=82720):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))", "input": "def sat(li: List[int], n=827208, upper=82720):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))", "target": ""}
{"module": "codeforces.py", "name": "ShortestDecDelta:3", "notes": "Inspired by [Codeforces Problem 617 A](https://codeforces.com/problemset/problem/617/A)", "sol_bodies": ["    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"], "sol_header": "def sol(n=176183, upper=17618):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=176183, upper=17618):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))", "input": "def sat(li: List[int], n=176183, upper=17618):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))", "target": ""}
{"module": "codeforces.py", "name": "ShortestDecDelta:4", "notes": "Inspired by [Codeforces Problem 617 A](https://codeforces.com/problemset/problem/617/A)", "sol_bodies": ["    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"], "sol_header": "def sol(n=483088, upper=48308):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], n=483088, upper=48308):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))", "input": "def sat(li: List[int], n=483088, upper=48308):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))", "target": ""}
{"module": "codeforces.py", "name": "Sssuubbstriiingg:0", "notes": "Inspired by [Codeforces Problem 58 A](https://codeforces.com/problemset/problem/58/A)", "sol_bodies": ["    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"], "sol_header": "def sol(string=\"Sssuubbstrissiingg\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find increasing indices to make the substring \"substring\"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], string=\"Sssuubbstrissiingg\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"", "input": "def sat(inds: List[int], string=\"Sssuubbstrissiingg\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"", "target": ""}
{"module": "codeforces.py", "name": "Sssuubbstriiingg:1", "notes": "Inspired by [Codeforces Problem 58 A](https://codeforces.com/problemset/problem/58/A)", "sol_bodies": ["    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"], "sol_header": "def sol(string=\"su absItIstrilnvgenw\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find increasing indices to make the substring \"substring\"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], string=\"su absItIstrilnvgenw\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"", "input": "def sat(inds: List[int], string=\"su absItIstrilnvgenw\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"", "target": ""}
{"module": "codeforces.py", "name": "Sssuubbstriiingg:2", "notes": "Inspired by [Codeforces Problem 58 A](https://codeforces.com/problemset/problem/58/A)", "sol_bodies": ["    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"], "sol_header": "def sol(string=\"sKubssB  tzCzPrZiL inCgN\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find increasing indices to make the substring \"substring\"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], string=\"sKubssB  tzCzPrZiL inCgN\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"", "input": "def sat(inds: List[int], string=\"sKubssB  tzCzPrZiL inCgN\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"", "target": ""}
{"module": "codeforces.py", "name": "Sssuubbstriiingg:3", "notes": "Inspired by [Codeforces Problem 58 A](https://codeforces.com/problemset/problem/58/A)", "sol_bodies": ["    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"], "sol_header": "def sol(string=\"suUbstriPng\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find increasing indices to make the substring \"substring\"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], string=\"suUbstriPng\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"", "input": "def sat(inds: List[int], string=\"suUbstriPng\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"", "target": ""}
{"module": "codeforces.py", "name": "Sssuubbstriiingg:4", "notes": "Inspired by [Codeforces Problem 58 A](https://codeforces.com/problemset/problem/58/A)", "sol_bodies": ["    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"], "sol_header": "def sol(string=\"stuqb VqsMJptxriWYe nmfgNfW\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find increasing indices to make the substring \"substring\"\"\"", "weight": 1.0, "sat": "def sat(inds: List[int], string=\"stuqb VqsMJptxriWYe nmfgNfW\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"", "input": "def sat(inds: List[int], string=\"stuqb VqsMJptxriWYe nmfgNfW\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"", "target": ""}
{"module": "codeforces.py", "name": "Moving0s:0", "notes": "Inspired by [Codeforces Problem 266 B](https://codeforces.com/problemset/problem/266/B)", "sol_bodies": ["    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"], "sol_header": "def sol(target=[1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], n_steps=4):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence\n    is achieved.\n    \"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], n_steps=4):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target", "input": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], n_steps=4):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target", "target": ""}
{"module": "codeforces.py", "name": "Moving0s:1", "notes": "Inspired by [Codeforces Problem 266 B](https://codeforces.com/problemset/problem/266/B)", "sol_bodies": ["    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"], "sol_header": "def sol(target=[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=9):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence\n    is achieved.\n    \"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=9):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target", "input": "def sat(seq: List[int], target=[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=9):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target", "target": ""}
{"module": "codeforces.py", "name": "Moving0s:2", "notes": "Inspired by [Codeforces Problem 266 B](https://codeforces.com/problemset/problem/266/B)", "sol_bodies": ["    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"], "sol_header": "def sol(target=[1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], n_steps=4):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence\n    is achieved.\n    \"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], n_steps=4):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target", "input": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], n_steps=4):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target", "target": ""}
{"module": "codeforces.py", "name": "Moving0s:3", "notes": "Inspired by [Codeforces Problem 266 B](https://codeforces.com/problemset/problem/266/B)", "sol_bodies": ["    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"], "sol_header": "def sol(target=[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=12):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence\n    is achieved.\n    \"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=12):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target", "input": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=12):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target", "target": ""}
{"module": "codeforces.py", "name": "Moving0s:4", "notes": "Inspired by [Codeforces Problem 266 B](https://codeforces.com/problemset/problem/266/B)", "sol_bodies": ["    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"], "sol_header": "def sol(target=[1, 1, 1, 0, 0, 0, 0], n_steps=3):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence\n    is achieved.\n    \"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], target=[1, 1, 1, 0, 0, 0, 0], n_steps=3):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target", "input": "def sat(seq: List[int], target=[1, 1, 1, 0, 0, 0, 0], n_steps=3):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target", "target": ""}
{"module": "codeforces.py", "name": "Factor47:0", "notes": "Inspired by [Codeforces Problem 122 A](https://codeforces.com/problemset/problem/122/A)", "sol_bodies": ["    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"], "sol_header": "def sol(n=6002685529):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"", "weight": 1.0, "sat": "def sat(d: int, n=6002685529):\n    return n % d == 0 and all(i in \"47\" for i in str(d))", "input": "def sat(d: int, n=6002685529):\n    return n % d == 0 and all(i in \"47\" for i in str(d))", "target": ""}
{"module": "codeforces.py", "name": "Factor47:1", "notes": "Inspired by [Codeforces Problem 122 A](https://codeforces.com/problemset/problem/122/A)", "sol_bodies": ["    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"], "sol_header": "def sol(n=16):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"", "weight": 1.0, "sat": "def sat(d: int, n=16):\n    return n % d == 0 and all(i in \"47\" for i in str(d))", "input": "def sat(d: int, n=16):\n    return n % d == 0 and all(i in \"47\" for i in str(d))", "target": ""}
{"module": "codeforces.py", "name": "Factor47:2", "notes": "Inspired by [Codeforces Problem 122 A](https://codeforces.com/problemset/problem/122/A)", "sol_bodies": ["    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"], "sol_header": "def sol(n=433459952851983617609247):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"", "weight": 1.0, "sat": "def sat(d: int, n=433459952851983617609247):\n    return n % d == 0 and all(i in \"47\" for i in str(d))", "input": "def sat(d: int, n=433459952851983617609247):\n    return n % d == 0 and all(i in \"47\" for i in str(d))", "target": ""}
{"module": "codeforces.py", "name": "Factor47:3", "notes": "Inspired by [Codeforces Problem 122 A](https://codeforces.com/problemset/problem/122/A)", "sol_bodies": ["    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"], "sol_header": "def sol(n=738195924589532712188415):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"", "weight": 1.0, "sat": "def sat(d: int, n=738195924589532712188415):\n    return n % d == 0 and all(i in \"47\" for i in str(d))", "input": "def sat(d: int, n=738195924589532712188415):\n    return n % d == 0 and all(i in \"47\" for i in str(d))", "target": ""}
{"module": "codeforces.py", "name": "Factor47:4", "notes": "Inspired by [Codeforces Problem 122 A](https://codeforces.com/problemset/problem/122/A)", "sol_bodies": ["    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"], "sol_header": "def sol(n=323190690645573746957862):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"", "weight": 1.0, "sat": "def sat(d: int, n=323190690645573746957862):\n    return n % d == 0 and all(i in \"47\" for i in str(d))", "input": "def sat(d: int, n=323190690645573746957862):\n    return n % d == 0 and all(i in \"47\" for i in str(d))", "target": ""}
{"module": "codeforces.py", "name": "MinBigger:0", "notes": "Inspired by [Codeforces Problem 160 A](https://codeforces.com/problemset/problem/160/A)", "sol_bodies": ["    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"], "sol_header": "def sol(val_counts=[[4, 3], [5, 2], [9, 3], [13, 13], [8, 11], [56, 1]], upper=11):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"", "weight": 1.0, "sat": "def sat(taken: List[int], val_counts=[[4, 3], [5, 2], [9, 3], [13, 13], [8, 11], [56, 1]], upper=11):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0", "input": "def sat(taken: List[int], val_counts=[[4, 3], [5, 2], [9, 3], [13, 13], [8, 11], [56, 1]], upper=11):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0", "target": ""}
{"module": "codeforces.py", "name": "MinBigger:1", "notes": "Inspired by [Codeforces Problem 160 A](https://codeforces.com/problemset/problem/160/A)", "sol_bodies": ["    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"], "sol_header": "def sol(val_counts=[[51, 67], [78, 13], [7, 68], [84, 54], [39, 38]], upper=66):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"", "weight": 1.0, "sat": "def sat(taken: List[int], val_counts=[[51, 67], [78, 13], [7, 68], [84, 54], [39, 38]], upper=66):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0", "input": "def sat(taken: List[int], val_counts=[[51, 67], [78, 13], [7, 68], [84, 54], [39, 38]], upper=66):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0", "target": ""}
{"module": "codeforces.py", "name": "MinBigger:2", "notes": "Inspired by [Codeforces Problem 160 A](https://codeforces.com/problemset/problem/160/A)", "sol_bodies": ["    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"], "sol_header": "def sol(val_counts=[[28, 29], [42, 54], [62, 85], [42, 95], [92, 32], [36, 35], [78, 56], [43, 20], [49, 17]], upper=153):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"", "weight": 1.0, "sat": "def sat(taken: List[int], val_counts=[[28, 29], [42, 54], [62, 85], [42, 95], [92, 32], [36, 35], [78, 56], [43, 20], [49, 17]], upper=153):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0", "input": "def sat(taken: List[int], val_counts=[[28, 29], [42, 54], [62, 85], [42, 95], [92, 32], [36, 35], [78, 56], [43, 20], [49, 17]], upper=153):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0", "target": ""}
{"module": "codeforces.py", "name": "MinBigger:3", "notes": "Inspired by [Codeforces Problem 160 A](https://codeforces.com/problemset/problem/160/A)", "sol_bodies": ["    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"], "sol_header": "def sol(val_counts=[[44, 92], [28, 7], [56, 37], [37, 66]], upper=90):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"", "weight": 1.0, "sat": "def sat(taken: List[int], val_counts=[[44, 92], [28, 7], [56, 37], [37, 66]], upper=90):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0", "input": "def sat(taken: List[int], val_counts=[[44, 92], [28, 7], [56, 37], [37, 66]], upper=90):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0", "target": ""}
{"module": "codeforces.py", "name": "MinBigger:4", "notes": "Inspired by [Codeforces Problem 160 A](https://codeforces.com/problemset/problem/160/A)", "sol_bodies": ["    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"], "sol_header": "def sol(val_counts=[[23, 93], [64, 14], [36, 8], [89, 92]], upper=65):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"", "weight": 1.0, "sat": "def sat(taken: List[int], val_counts=[[23, 93], [64, 14], [36, 8], [89, 92]], upper=65):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0", "input": "def sat(taken: List[int], val_counts=[[23, 93], [64, 14], [36, 8], [89, 92]], upper=65):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0", "target": ""}
{"module": "algebra.py", "name": "CubicRoot:0", "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).", "sol_bodies": ["    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"], "sol_header": "def sol(coeffs=[2.0, 1.0, 0.0, 8.0]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, coeffs=[2.0, 1.0, 0.0, 8.0]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6", "input": "def sat(x: float, coeffs=[2.0, 1.0, 0.0, 8.0]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6", "target": ""}
{"module": "algebra.py", "name": "CubicRoot:1", "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).", "sol_bodies": ["    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"], "sol_header": "def sol(coeffs=[0.009597657937719273, -10.297175825569942, 0.15891220226280925, 10.530249049250433]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, coeffs=[0.009597657937719273, -10.297175825569942, 0.15891220226280925, 10.530249049250433]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6", "input": "def sat(x: float, coeffs=[0.009597657937719273, -10.297175825569942, 0.15891220226280925, 10.530249049250433]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6", "target": ""}
{"module": "algebra.py", "name": "CubicRoot:2", "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).", "sol_bodies": ["    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"], "sol_header": "def sol(coeffs=[-0.17749172356645268, -1.3894267878542186, 0.03752944532850555, 0.2624916128068381]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, coeffs=[-0.17749172356645268, -1.3894267878542186, 0.03752944532850555, 0.2624916128068381]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6", "input": "def sat(x: float, coeffs=[-0.17749172356645268, -1.3894267878542186, 0.03752944532850555, 0.2624916128068381]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6", "target": ""}
{"module": "algebra.py", "name": "CubicRoot:3", "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).", "sol_bodies": ["    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"], "sol_header": "def sol(coeffs=[0.41725114111706524, 155.2589446092116, -0.10619077904258341, -0.024129284994425074]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, coeffs=[0.41725114111706524, 155.2589446092116, -0.10619077904258341, -0.024129284994425074]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6", "input": "def sat(x: float, coeffs=[0.41725114111706524, 155.2589446092116, -0.10619077904258341, -0.024129284994425074]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6", "target": ""}
{"module": "algebra.py", "name": "CubicRoot:4", "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).", "sol_bodies": ["    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"], "sol_header": "def sol(coeffs=[-2.3153234528266906, 11.247619504308075, -72.3705721705674, 53.97429005428236]):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"", "weight": 1.0, "sat": "def sat(x: float, coeffs=[-2.3153234528266906, 11.247619504308075, -72.3705721705674, 53.97429005428236]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6", "input": "def sat(x: float, coeffs=[-2.3153234528266906, 11.247619504308075, -72.3705721705674, 53.97429005428236]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6", "target": ""}
{"module": "algebra.py", "name": "AllCubicRoots:0", "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).", "sol_bodies": ["    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"], "sol_header": "def sol(coeffs=[1.0, -2.0, -1.0]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"", "weight": 1.0, "sat": "def sat(roots: List[float], coeffs=[1.0, -2.0, -1.0]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6", "input": "def sat(roots: List[float], coeffs=[1.0, -2.0, -1.0]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6", "target": ""}
{"module": "algebra.py", "name": "AllCubicRoots:1", "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).", "sol_bodies": ["    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"], "sol_header": "def sol(coeffs=[291.6393860094841, -235.56805995170293, 46.827662118172]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"", "weight": 1.0, "sat": "def sat(roots: List[float], coeffs=[291.6393860094841, -235.56805995170293, 46.827662118172]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6", "input": "def sat(roots: List[float], coeffs=[291.6393860094841, -235.56805995170293, 46.827662118172]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6", "target": ""}
{"module": "algebra.py", "name": "AllCubicRoots:2", "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).", "sol_bodies": ["    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"], "sol_header": "def sol(coeffs=[-0.25228902661371166, -0.1500677342820565, 0.04095001209455085]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"", "weight": 1.0, "sat": "def sat(roots: List[float], coeffs=[-0.25228902661371166, -0.1500677342820565, 0.04095001209455085]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6", "input": "def sat(roots: List[float], coeffs=[-0.25228902661371166, -0.1500677342820565, 0.04095001209455085]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6", "target": ""}
{"module": "algebra.py", "name": "AllCubicRoots:3", "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).", "sol_bodies": ["    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"], "sol_header": "def sol(coeffs=[-0.7564145326509102, -0.6902422688120567, 0.4732575941427041]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"", "weight": 1.0, "sat": "def sat(roots: List[float], coeffs=[-0.7564145326509102, -0.6902422688120567, 0.4732575941427041]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6", "input": "def sat(roots: List[float], coeffs=[-0.7564145326509102, -0.6902422688120567, 0.4732575941427041]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6", "target": ""}
{"module": "algebra.py", "name": "AllCubicRoots:4", "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).", "sol_bodies": ["    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"], "sol_header": "def sol(coeffs=[5.119999240806329, -7.551441647258393, -21.440710634524915]):", "ans_type": "List[float]", "sol_docstring": "    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"", "weight": 1.0, "sat": "def sat(roots: List[float], coeffs=[5.119999240806329, -7.551441647258393, -21.440710634524915]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6", "input": "def sat(roots: List[float], coeffs=[5.119999240806329, -7.551441647258393, -21.440710634524915]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6", "target": ""}
{"module": "basic.py", "name": "GeometricSequence:0", "notes": "", "sol_bodies": ["    return [a * r ** i for i in range(l)]"], "sol_header": "def sol(a=8, r=2, l=50):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], a=8, r=2, l=50):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])", "input": "def sat(x: List[int], a=8, r=2, l=50):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])", "target": ""}
{"module": "basic.py", "name": "GeometricSequence:1", "notes": "", "sol_bodies": ["    return [a * r ** i for i in range(l)]"], "sol_header": "def sol(a=-484, r=4, l=589):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], a=-484, r=4, l=589):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])", "input": "def sat(x: List[int], a=-484, r=4, l=589):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])", "target": ""}
{"module": "basic.py", "name": "GeometricSequence:2", "notes": "", "sol_bodies": ["    return [a * r ** i for i in range(l)]"], "sol_header": "def sol(a=889, r=7, l=393):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], a=889, r=7, l=393):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])", "input": "def sat(x: List[int], a=889, r=7, l=393):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])", "target": ""}
{"module": "basic.py", "name": "GeometricSequence:3", "notes": "", "sol_bodies": ["    return [a * r ** i for i in range(l)]"], "sol_header": "def sol(a=-777, r=4, l=103):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], a=-777, r=4, l=103):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])", "input": "def sat(x: List[int], a=-777, r=4, l=103):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])", "target": ""}
{"module": "basic.py", "name": "GeometricSequence:4", "notes": "", "sol_bodies": ["    return [a * r ** i for i in range(l)]"], "sol_header": "def sol(a=-736, r=4, l=92):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"", "weight": 1.0, "sat": "def sat(x: List[int], a=-736, r=4, l=92):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])", "input": "def sat(x: List[int], a=-736, r=4, l=92):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])", "target": ""}
{"module": "basic.py", "name": "IfProblem:0", "notes": "", "sol_bodies": ["    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"], "sol_header": "def sol(a=324554, b=1345345):", "ans_type": "int", "sol_docstring": "    \"\"\"Satisfy a simple if statement\"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=324554, b=1345345):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "input": "def sat(x: int, a=324554, b=1345345):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "target": ""}
{"module": "basic.py", "name": "IfProblem:1", "notes": "", "sol_bodies": ["    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"], "sol_header": "def sol(a=51, b=40553793):", "ans_type": "int", "sol_docstring": "    \"\"\"Satisfy a simple if statement\"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=51, b=40553793):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "input": "def sat(x: int, a=51, b=40553793):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "target": ""}
{"module": "basic.py", "name": "IfProblem:2", "notes": "", "sol_bodies": ["    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"], "sol_header": "def sol(a=50, b=72369383):", "ans_type": "int", "sol_docstring": "    \"\"\"Satisfy a simple if statement\"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=50, b=72369383):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "input": "def sat(x: int, a=50, b=72369383):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "target": ""}
{"module": "basic.py", "name": "IfProblem:3", "notes": "", "sol_bodies": ["    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"], "sol_header": "def sol(a=90, b=42412534):", "ans_type": "int", "sol_docstring": "    \"\"\"Satisfy a simple if statement\"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=90, b=42412534):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "input": "def sat(x: int, a=90, b=42412534):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "target": ""}
{"module": "basic.py", "name": "IfProblem:4", "notes": "", "sol_bodies": ["    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"], "sol_header": "def sol(a=62, b=-26538057):", "ans_type": "int", "sol_docstring": "    \"\"\"Satisfy a simple if statement\"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=62, b=-26538057):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "input": "def sat(x: int, a=62, b=-26538057):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b", "target": ""}
{"module": "basic.py", "name": "IfProblemWithAnd:0", "notes": "", "sol_bodies": ["    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"], "sol_header": "def sol(a=9384594, b=1343663):", "ans_type": "int", "sol_docstring": "    \"\"\"Satisfy a simple if statement with an and clause\"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=9384594, b=1343663):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "input": "def sat(x: int, a=9384594, b=1343663):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "target": ""}
{"module": "basic.py", "name": "IfProblemWithAnd:1", "notes": "", "sol_bodies": ["    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"], "sol_header": "def sol(a=57, b=40522966):", "ans_type": "int", "sol_docstring": "    \"\"\"Satisfy a simple if statement with an and clause\"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=57, b=40522966):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "input": "def sat(x: int, a=57, b=40522966):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "target": ""}
{"module": "basic.py", "name": "IfProblemWithAnd:2", "notes": "", "sol_bodies": ["    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"], "sol_header": "def sol(a=29, b=71683001):", "ans_type": "int", "sol_docstring": "    \"\"\"Satisfy a simple if statement with an and clause\"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=29, b=71683001):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "input": "def sat(x: int, a=29, b=71683001):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "target": ""}
{"module": "basic.py", "name": "IfProblemWithAnd:3", "notes": "", "sol_bodies": ["    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"], "sol_header": "def sol(a=92, b=8820402):", "ans_type": "int", "sol_docstring": "    \"\"\"Satisfy a simple if statement with an and clause\"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=92, b=8820402):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "input": "def sat(x: int, a=92, b=8820402):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "target": ""}
{"module": "basic.py", "name": "IfProblemWithAnd:4", "notes": "", "sol_bodies": ["    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"], "sol_header": "def sol(a=64, b=46712723):", "ans_type": "int", "sol_docstring": "    \"\"\"Satisfy a simple if statement with an and clause\"\"\"", "weight": 1.0, "sat": "def sat(x: int, a=64, b=46712723):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "input": "def sat(x: int, a=64, b=46712723):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "target": ""}
{"module": "basic.py", "name": "EngineerNumbers:0", "notes": "", "sol_bodies": ["    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"], "sol_header": "def sol(n=100, a=\"bar\", b=\"foo\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str], n=100, a=\"bar\", b=\"foo\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "input": "def sat(ls: List[str], n=100, a=\"bar\", b=\"foo\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "target": ""}
{"module": "basic.py", "name": "EngineerNumbers:1", "notes": "", "sol_bodies": ["    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"], "sol_header": "def sol(n=44, a=\"lychezothotextocev\", b=\"th\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str], n=44, a=\"lychezothotextocev\", b=\"th\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "input": "def sat(ls: List[str], n=44, a=\"lychezothotextocev\", b=\"th\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "target": ""}
{"module": "basic.py", "name": "EngineerNumbers:2", "notes": "", "sol_bodies": ["    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"], "sol_header": "def sol(n=13, a=\"kacukebyhapuniryh\", b=\"te\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str], n=13, a=\"kacukebyhapuniryh\", b=\"te\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "input": "def sat(ls: List[str], n=13, a=\"kacukebyhapuniryh\", b=\"te\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "target": ""}
{"module": "basic.py", "name": "EngineerNumbers:3", "notes": "", "sol_bodies": ["    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"], "sol_header": "def sol(n=61, a=\"cisoceratext\", b=\"milusicochylitextyco\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str], n=61, a=\"cisoceratext\", b=\"milusicochylitextyco\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "input": "def sat(ls: List[str], n=61, a=\"cisoceratext\", b=\"milusicochylitextyco\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "target": ""}
{"module": "basic.py", "name": "EngineerNumbers:4", "notes": "", "sol_bodies": ["    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"], "sol_header": "def sol(n=59, a=\"hokitextawelaxah\", b=\"maryhedu\"):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"", "weight": 1.0, "sat": "def sat(ls: List[str], n=59, a=\"hokitextawelaxah\", b=\"maryhedu\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "input": "def sat(ls: List[str], n=59, a=\"hokitextawelaxah\", b=\"maryhedu\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)", "target": ""}
{"module": "chess.py", "name": "MoreQueens:0", "notes": "See Wikipedia entry on [Eight Queens puzzle](https://en.wikipedia.org/w/index.php?title=Eight_queens_puzzle).\n\nA brute force approach will not work on many of these problems.", "sol_bodies": ["    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"], "sol_header": "def sol(m=9, n=9):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"", "weight": 1.0, "sat": "def sat(squares: List[List[int]], m=9, n=9):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True", "input": "def sat(squares: List[List[int]], m=9, n=9):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True", "target": ""}
{"module": "chess.py", "name": "MoreQueens:1", "notes": "See Wikipedia entry on [Eight Queens puzzle](https://en.wikipedia.org/w/index.php?title=Eight_queens_puzzle).\n\nA brute force approach will not work on many of these problems.", "sol_bodies": ["    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"], "sol_header": "def sol(m=79, n=95):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"", "weight": 1.0, "sat": "def sat(squares: List[List[int]], m=79, n=95):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True", "input": "def sat(squares: List[List[int]], m=79, n=95):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True", "target": ""}
{"module": "chess.py", "name": "MoreQueens:2", "notes": "See Wikipedia entry on [Eight Queens puzzle](https://en.wikipedia.org/w/index.php?title=Eight_queens_puzzle).\n\nA brute force approach will not work on many of these problems.", "sol_bodies": ["    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"], "sol_header": "def sol(m=80, n=88):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"", "weight": 1.0, "sat": "def sat(squares: List[List[int]], m=80, n=88):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True", "input": "def sat(squares: List[List[int]], m=80, n=88):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True", "target": ""}
{"module": "chess.py", "name": "MoreQueens:3", "notes": "See Wikipedia entry on [Eight Queens puzzle](https://en.wikipedia.org/w/index.php?title=Eight_queens_puzzle).\n\nA brute force approach will not work on many of these problems.", "sol_bodies": ["    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"], "sol_header": "def sol(m=56, n=16):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"", "weight": 1.0, "sat": "def sat(squares: List[List[int]], m=56, n=16):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True", "input": "def sat(squares: List[List[int]], m=56, n=16):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True", "target": ""}
{"module": "chess.py", "name": "MoreQueens:4", "notes": "See Wikipedia entry on [Eight Queens puzzle](https://en.wikipedia.org/w/index.php?title=Eight_queens_puzzle).\n\nA brute force approach will not work on many of these problems.", "sol_bodies": ["    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"], "sol_header": "def sol(m=23, n=45):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"", "weight": 1.0, "sat": "def sat(squares: List[List[int]], m=23, n=45):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True", "input": "def sat(squares: List[List[int]], m=23, n=45):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True", "target": ""}
{"module": "compression.py", "name": "LZW:0", "notes": "We have provided a simple version of the *decompression* algorithm of\n[Lempel-Ziv-Welch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\nso the solution is the *compression* algorithm.", "sol_bodies": ["    # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"], "sol_header": "def sol(compressed_len=17, text=\"Hellooooooooooooooooooooo world!\"):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], compressed_len=17, text=\"Hellooooooooooooooooooooo world!\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "input": "def sat(seq: List[int], compressed_len=17, text=\"Hellooooooooooooooooooooo world!\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "target": ""}
{"module": "compression.py", "name": "LZW:1", "notes": "We have provided a simple version of the *decompression* algorithm of\n[Lempel-Ziv-Welch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\nso the solution is the *compression* algorithm.", "sol_bodies": ["    # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"], "sol_header": "def sol(text=\"\", compressed_len=0):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], compressed_len=0, text=\"\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "input": "def sat(seq: List[int], compressed_len=0, text=\"\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "target": ""}
{"module": "compression.py", "name": "LZW:2", "notes": "We have provided a simple version of the *decompression* algorithm of\n[Lempel-Ziv-Welch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\nso the solution is the *compression* algorithm.", "sol_bodies": ["    # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"], "sol_header": "def sol(text=\"cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\", compressed_len=45):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], compressed_len=45, text=\"cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "input": "def sat(seq: List[int], compressed_len=45, text=\"cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "target": ""}
{"module": "compression.py", "name": "LZW:3", "notes": "We have provided a simple version of the *decompression* algorithm of\n[Lempel-Ziv-Welch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\nso the solution is the *compression* algorithm.", "sol_bodies": ["    # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"], "sol_header": "def sol(text=\"cupewoquabipemecacichytogycykythyzydizutextojokosapysetextethilabequypagichichimipyhuquithyzuwukychycokigomylotextoquochachikalocejiwyzagodothilythetiquypirabafusubasufylejulitudosisyrahezitextoluquevy\", compressed_len=154):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], compressed_len=154, text=\"cupewoquabipemecacichytogycykythyzydizutextojokosapysetextethilabequypagichichimipyhuquithyzuwukychycokigomylotextoquochachikalocejiwyzagodothilythetiquypirabafusubasufylejulitudosisyrahezitextoluquevy\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "input": "def sat(seq: List[int], compressed_len=154, text=\"cupewoquabipemecacichytogycykythyzydizutextojokosapysetextethilabequypagichichimipyhuquithyzuwukychycokigomylotextoquochachikalocejiwyzagodothilythetiquypirabafusubasufylejulitudosisyrahezitextoluquevy\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "target": ""}
{"module": "compression.py", "name": "LZW:4", "notes": "We have provided a simple version of the *decompression* algorithm of\n[Lempel-Ziv-Welch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\nso the solution is the *compression* algorithm.", "sol_bodies": ["    # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"], "sol_header": "def sol(text=\"si\", compressed_len=2):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"", "weight": 1.0, "sat": "def sat(seq: List[int], compressed_len=2, text=\"si\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "input": "def sat(seq: List[int], compressed_len=2, text=\"si\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len", "target": ""}
{"module": "compression.py", "name": "PackingHam:0", "notes": "This packing problem a [classic problem](https://en.wikipedia.org/wiki/Sphere_packing#Other_spaces)\nin coding theory.", "sol_bodies": ["    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"], "sol_header": "def sol(num=100, bits=100, dist=34):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"", "weight": 1.0, "sat": "def sat(words: List[str], num=100, bits=100, dist=34):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "input": "def sat(words: List[str], num=100, bits=100, dist=34):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "target": ""}
{"module": "compression.py", "name": "PackingHam:1", "notes": "This packing problem a [classic problem](https://en.wikipedia.org/wiki/Sphere_packing#Other_spaces)\nin coding theory.", "sol_bodies": ["    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"], "sol_header": "def sol(num=5, bits=81, dist=30):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"", "weight": 1.0, "sat": "def sat(words: List[str], num=5, bits=81, dist=30):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "input": "def sat(words: List[str], num=5, bits=81, dist=30):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "target": ""}
{"module": "compression.py", "name": "PackingHam:2", "notes": "This packing problem a [classic problem](https://en.wikipedia.org/wiki/Sphere_packing#Other_spaces)\nin coding theory.", "sol_bodies": ["    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"], "sol_header": "def sol(num=78, bits=64, dist=16):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"", "weight": 1.0, "sat": "def sat(words: List[str], num=78, bits=64, dist=16):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "input": "def sat(words: List[str], num=78, bits=64, dist=16):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "target": ""}
{"module": "compression.py", "name": "PackingHam:3", "notes": "This packing problem a [classic problem](https://en.wikipedia.org/wiki/Sphere_packing#Other_spaces)\nin coding theory.", "sol_bodies": ["    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"], "sol_header": "def sol(num=28, bits=11, dist=1):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"", "weight": 1.0, "sat": "def sat(words: List[str], num=28, bits=11, dist=1):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "input": "def sat(words: List[str], num=28, bits=11, dist=1):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "target": ""}
{"module": "compression.py", "name": "PackingHam:4", "notes": "This packing problem a [classic problem](https://en.wikipedia.org/wiki/Sphere_packing#Other_spaces)\nin coding theory.", "sol_bodies": ["    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"], "sol_header": "def sol(num=8, bits=75, dist=24):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"", "weight": 1.0, "sat": "def sat(words: List[str], num=8, bits=75, dist=24):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "input": "def sat(words: List[str], num=8, bits=75, dist=24):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))", "target": ""}
{"module": "conways_game_of_life.py", "name": "Oscillators:0", "notes": "Oscillators (including some unsolved, open problems)\n\nThis problem is *unsolved* for periods 19, 38, and 41.\n\nSee\n[discussion](https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life )\nin Wikipedia article on Cellular Automaton Oscillators.", "sol_bodies": ["    # # generate random patterns, slow solution\n    # def viz(live):\n    #     if not live:\n    #         return\n    #     a, b = min(z.real for z in live), min(z.imag for z in live)\n    #     live = {z - (a + b * 1j) for z in live}\n    #     m, n = int(max(z.real for z in live)) + 1, int(max(z.imag for z in live)) + 1\n    #     for x in range(m):\n    #         print(\"\".join(\"X\" if x + y * 1j in live else \",\" for y in range(n)))\n\n    import random\n    rand = random.Random(1)\n    # print(f\"Looking for {period}:\")\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    completes = [[x + y * 1j for x in range(n) for y in range(n)] for n in range(30)]\n\n    for _attempt in range(10 ** 5):\n        n = rand.randrange(3, 10)\n        m = rand.randrange(3, n * n)\n        live = set(rand.sample(completes[n], m))\n        if rand.randrange(2):\n            live.update([-z for z in live])\n        if rand.randrange(2):\n            live.update([z.conjugate() for z in live])\n        memory = {}\n        for step in range(period * 10):\n            key = sum((.123 - .99123j) ** z for z in live) * 10 ** 5\n            key = int(key.real), int(key.imag)\n            if key in memory:\n                if memory[key] == step - period:\n                    # print(period)\n                    # viz(live)\n                    return [[int(z.real), int(z.imag)] for z in live]\n                break\n            memory[key] = step\n            visible = {z + d for z in live for d in deltas}\n            live = {z for z in visible if sum(z + d in live for d in deltas) in range(3 - (z in live), 4)}\n\n    return None  # failed"], "sol_header": "def sol(period=3):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[List[int]], period=3):\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period", "input": "def sat(init: List[List[int]], period=3):\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period", "target": ""}
{"module": "conways_game_of_life.py", "name": "Oscillators:1", "notes": "Oscillators (including some unsolved, open problems)\n\nThis problem is *unsolved* for periods 19, 38, and 41.\n\nSee\n[discussion](https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life )\nin Wikipedia article on Cellular Automaton Oscillators.", "sol_bodies": ["    # # generate random patterns, slow solution\n    # def viz(live):\n    #     if not live:\n    #         return\n    #     a, b = min(z.real for z in live), min(z.imag for z in live)\n    #     live = {z - (a + b * 1j) for z in live}\n    #     m, n = int(max(z.real for z in live)) + 1, int(max(z.imag for z in live)) + 1\n    #     for x in range(m):\n    #         print(\"\".join(\"X\" if x + y * 1j in live else \",\" for y in range(n)))\n\n    import random\n    rand = random.Random(1)\n    # print(f\"Looking for {period}:\")\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    completes = [[x + y * 1j for x in range(n) for y in range(n)] for n in range(30)]\n\n    for _attempt in range(10 ** 5):\n        n = rand.randrange(3, 10)\n        m = rand.randrange(3, n * n)\n        live = set(rand.sample(completes[n], m))\n        if rand.randrange(2):\n            live.update([-z for z in live])\n        if rand.randrange(2):\n            live.update([z.conjugate() for z in live])\n        memory = {}\n        for step in range(period * 10):\n            key = sum((.123 - .99123j) ** z for z in live) * 10 ** 5\n            key = int(key.real), int(key.imag)\n            if key in memory:\n                if memory[key] == step - period:\n                    # print(period)\n                    # viz(live)\n                    return [[int(z.real), int(z.imag)] for z in live]\n                break\n            memory[key] = step\n            visible = {z + d for z in live for d in deltas}\n            live = {z for z in visible if sum(z + d in live for d in deltas) in range(3 - (z in live), 4)}\n\n    return None  # failed"], "sol_header": "def sol(period=1):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[List[int]], period=1):\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period", "input": "def sat(init: List[List[int]], period=1):\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period", "target": ""}
{"module": "conways_game_of_life.py", "name": "Oscillators:2", "notes": "Oscillators (including some unsolved, open problems)\n\nThis problem is *unsolved* for periods 19, 38, and 41.\n\nSee\n[discussion](https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life )\nin Wikipedia article on Cellular Automaton Oscillators.", "sol_bodies": ["    # # generate random patterns, slow solution\n    # def viz(live):\n    #     if not live:\n    #         return\n    #     a, b = min(z.real for z in live), min(z.imag for z in live)\n    #     live = {z - (a + b * 1j) for z in live}\n    #     m, n = int(max(z.real for z in live)) + 1, int(max(z.imag for z in live)) + 1\n    #     for x in range(m):\n    #         print(\"\".join(\"X\" if x + y * 1j in live else \",\" for y in range(n)))\n\n    import random\n    rand = random.Random(1)\n    # print(f\"Looking for {period}:\")\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    completes = [[x + y * 1j for x in range(n) for y in range(n)] for n in range(30)]\n\n    for _attempt in range(10 ** 5):\n        n = rand.randrange(3, 10)\n        m = rand.randrange(3, n * n)\n        live = set(rand.sample(completes[n], m))\n        if rand.randrange(2):\n            live.update([-z for z in live])\n        if rand.randrange(2):\n            live.update([z.conjugate() for z in live])\n        memory = {}\n        for step in range(period * 10):\n            key = sum((.123 - .99123j) ** z for z in live) * 10 ** 5\n            key = int(key.real), int(key.imag)\n            if key in memory:\n                if memory[key] == step - period:\n                    # print(period)\n                    # viz(live)\n                    return [[int(z.real), int(z.imag)] for z in live]\n                break\n            memory[key] = step\n            visible = {z + d for z in live for d in deltas}\n            live = {z for z in visible if sum(z + d in live for d in deltas) in range(3 - (z in live), 4)}\n\n    return None  # failed"], "sol_header": "def sol(period=2):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[List[int]], period=2):\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period", "input": "def sat(init: List[List[int]], period=2):\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period", "target": ""}
{"module": "conways_game_of_life.py", "name": "Oscillators:3", "notes": "Oscillators (including some unsolved, open problems)\n\nThis problem is *unsolved* for periods 19, 38, and 41.\n\nSee\n[discussion](https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life )\nin Wikipedia article on Cellular Automaton Oscillators.", "sol_bodies": [], "sol_header": "def sol(period=4):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"", "weight": 1.0, "sat": "def sat(init: List[List[int]], period=4):\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period", "input": "def sat(init: List[List[int]], period=4):\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period", "target": ""}
{"module": "games.py", "name": "Mastermind:0", "notes": "Compute a strategy for winning in [mastermind](https://en.wikipedia.org/wiki/Mastermind_%28board_game%29)\nin a given number of guesses.\n\nInstead of writing a program that plays the game interactively (since interaction is not allowed), we require\nthem to provide a provable winning game tree.", "sol_bodies": ["    COLORS = \"ABCDEF\"\n\n    transcripts = []\n\n    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]\n\n    def score(secret, guess):\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return f\"{sum(perfect.values())}{almost}\"\n\n    def mastermind(transcript=\"AABB\", feasible=ALL):  # mastermind moves\n        transcripts.append(transcript)\n        assert transcript.count(\"\\n\") <= max_moves\n        guess = transcript[-4:]\n        feasibles = {}\n        for secret in feasible:\n            scr = score(secret, guess)\n            if scr not in feasibles:\n                feasibles[scr] = []\n            feasibles[scr].append(secret)\n        for scr, secrets in feasibles.items():\n            if scr != \"40\":\n                guesser(transcript + f\" {scr}\\n\", secrets)\n\n    def guesser(transcript, feasible):  # guesser moves\n        def max_ambiguity(guess):\n            by_score = {}\n            for secret2 in feasible:\n                scr = score(secret2, guess)\n                if scr not in by_score:\n                    by_score[scr] = 0\n                by_score[scr] += 1\n            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:\n            return max(by_score.values())\n\n        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:\n        guess = min(feasible, key=max_ambiguity)\n\n        mastermind(transcript + guess, feasible)\n\n    mastermind()\n\n    return transcripts"], "sol_header": "def sol(max_moves=10):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Come up with a winning strategy for Mastermind in max_moves moves. Colors are represented by the letters A-F.\n    The solution representation is as follows.\n    A transcript is a string describing the game so far. It consists of rows separated by newlines.\n    Each row has 4 letters A-F followed by a space and then two numbers indicating how many are exactly right\n    and how many are right but in the wrong location. A sample transcript is as follows:\n    AABB 11\n    ABCD 21\n    ABDC\n\n    This is the transcript as the game is in progress. The complete transcript might be:\n    AABB 11\n    ABCD 21\n    ABDC 30\n    ABDE 40\n\n    A winning strategy is described by a list of transcripts to visit. The next guess can be determined from\n    those partial transcripts.\n    \"\"\"", "weight": 10.0, "sat": "def sat(transcripts: List[str], max_moves=10):\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)", "input": "def sat(transcripts: List[str], max_moves=10):\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)", "target": ""}
{"module": "games.py", "name": "Mastermind:1", "notes": "Compute a strategy for winning in [mastermind](https://en.wikipedia.org/wiki/Mastermind_%28board_game%29)\nin a given number of guesses.\n\nInstead of writing a program that plays the game interactively (since interaction is not allowed), we require\nthem to provide a provable winning game tree.", "sol_bodies": ["    COLORS = \"ABCDEF\"\n\n    transcripts = []\n\n    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]\n\n    def score(secret, guess):\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return f\"{sum(perfect.values())}{almost}\"\n\n    def mastermind(transcript=\"AABB\", feasible=ALL):  # mastermind moves\n        transcripts.append(transcript)\n        assert transcript.count(\"\\n\") <= max_moves\n        guess = transcript[-4:]\n        feasibles = {}\n        for secret in feasible:\n            scr = score(secret, guess)\n            if scr not in feasibles:\n                feasibles[scr] = []\n            feasibles[scr].append(secret)\n        for scr, secrets in feasibles.items():\n            if scr != \"40\":\n                guesser(transcript + f\" {scr}\\n\", secrets)\n\n    def guesser(transcript, feasible):  # guesser moves\n        def max_ambiguity(guess):\n            by_score = {}\n            for secret2 in feasible:\n                scr = score(secret2, guess)\n                if scr not in by_score:\n                    by_score[scr] = 0\n                by_score[scr] += 1\n            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:\n            return max(by_score.values())\n\n        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:\n        guess = min(feasible, key=max_ambiguity)\n\n        mastermind(transcript + guess, feasible)\n\n    mastermind()\n\n    return transcripts"], "sol_header": "def sol(max_moves=8):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Come up with a winning strategy for Mastermind in max_moves moves. Colors are represented by the letters A-F.\n    The solution representation is as follows.\n    A transcript is a string describing the game so far. It consists of rows separated by newlines.\n    Each row has 4 letters A-F followed by a space and then two numbers indicating how many are exactly right\n    and how many are right but in the wrong location. A sample transcript is as follows:\n    AABB 11\n    ABCD 21\n    ABDC\n\n    This is the transcript as the game is in progress. The complete transcript might be:\n    AABB 11\n    ABCD 21\n    ABDC 30\n    ABDE 40\n\n    A winning strategy is described by a list of transcripts to visit. The next guess can be determined from\n    those partial transcripts.\n    \"\"\"", "weight": 14.0, "sat": "def sat(transcripts: List[str], max_moves=8):\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)", "input": "def sat(transcripts: List[str], max_moves=8):\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)", "target": ""}
{"module": "games.py", "name": "Mastermind:2", "notes": "Compute a strategy for winning in [mastermind](https://en.wikipedia.org/wiki/Mastermind_%28board_game%29)\nin a given number of guesses.\n\nInstead of writing a program that plays the game interactively (since interaction is not allowed), we require\nthem to provide a provable winning game tree.", "sol_bodies": ["    COLORS = \"ABCDEF\"\n\n    transcripts = []\n\n    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]\n\n    def score(secret, guess):\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return f\"{sum(perfect.values())}{almost}\"\n\n    def mastermind(transcript=\"AABB\", feasible=ALL):  # mastermind moves\n        transcripts.append(transcript)\n        assert transcript.count(\"\\n\") <= max_moves\n        guess = transcript[-4:]\n        feasibles = {}\n        for secret in feasible:\n            scr = score(secret, guess)\n            if scr not in feasibles:\n                feasibles[scr] = []\n            feasibles[scr].append(secret)\n        for scr, secrets in feasibles.items():\n            if scr != \"40\":\n                guesser(transcript + f\" {scr}\\n\", secrets)\n\n    def guesser(transcript, feasible):  # guesser moves\n        def max_ambiguity(guess):\n            by_score = {}\n            for secret2 in feasible:\n                scr = score(secret2, guess)\n                if scr not in by_score:\n                    by_score[scr] = 0\n                by_score[scr] += 1\n            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:\n            return max(by_score.values())\n\n        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:\n        guess = min(feasible, key=max_ambiguity)\n\n        mastermind(transcript + guess, feasible)\n\n    mastermind()\n\n    return transcripts"], "sol_header": "def sol(max_moves=6):", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Come up with a winning strategy for Mastermind in max_moves moves. Colors are represented by the letters A-F.\n    The solution representation is as follows.\n    A transcript is a string describing the game so far. It consists of rows separated by newlines.\n    Each row has 4 letters A-F followed by a space and then two numbers indicating how many are exactly right\n    and how many are right but in the wrong location. A sample transcript is as follows:\n    AABB 11\n    ABCD 21\n    ABDC\n\n    This is the transcript as the game is in progress. The complete transcript might be:\n    AABB 11\n    ABCD 21\n    ABDC 30\n    ABDE 40\n\n    A winning strategy is described by a list of transcripts to visit. The next guess can be determined from\n    those partial transcripts.\n    \"\"\"", "weight": 18.0, "sat": "def sat(transcripts: List[str], max_moves=6):\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)", "input": "def sat(transcripts: List[str], max_moves=6):\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)", "target": ""}
{"module": "games.py", "name": "TicTacToeX:0", "notes": "Since we don't have interaction, this problem asks for a full tie-guranteeing strategy.", "sol_bodies": ["    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]  # 9-bit representation\n\n    good_boards = []\n\n    def x_move(x, o):  # returns True if x wins or ties, x's turn to move\n        if win[o]:\n            return False\n        if x | o == 511:\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and o_move(x | (1 << i), o):\n                good_boards.append(\"\".join(\".XO\"[((x >> j) & 1) + 2 * ((o >> j) & 1) + (i == j)] for j in range(9)))\n                return True\n        return False  # O wins\n\n    def o_move(x, o):  # returns True if x wins or ties, x's turn to move\n        if win[x] or x | o == 511:  # full board\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and not x_move(x, o | (1 << i)):\n                return False\n        return True  # O wins\n\n    res = x_move(0, 0)\n    assert res\n\n    return good_boards"], "sol_header": "def sol():", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Compute a strategy for X (first player) in tic-tac-toe that guarantees a tie. That is a strategy for X that,\n    no matter what the opponent does, X does not lose.\n\n    A board is represented as a 9-char string like an X in the middle would be \"....X....\" and a\n    move is an integer 0-8. The answer is a list of \"good boards\" that X aims for, so no matter what O does there\n    is always good board that X can get to with a single move.\n    \"\"\"", "weight": 1.0, "sat": "def sat(good_boards: List[str]):\n    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in \"XO\") for b in good_boards}\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]\n\n    def tie(x, o):  # returns True if X has a forced tie/win assuming it's X's turn to move.\n        x |= 1 << [i for i in range(9) if (x | (1 << i), o) in board_bit_reps][0]\n        return not win[o] and (win[x] or all((x | o) & (1 << i) or tie(x, o | (1 << i)) for i in range(9)))\n\n    return tie(0, 0)", "input": "def sat(good_boards: List[str]):\n    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in \"XO\") for b in good_boards}\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]\n\n    def tie(x, o):  # returns True if X has a forced tie/win assuming it's X's turn to move.\n        x |= 1 << [i for i in range(9) if (x | (1 << i), o) in board_bit_reps][0]\n        return not win[o] and (win[x] or all((x | o) & (1 << i) or tie(x, o | (1 << i)) for i in range(9)))\n\n    return tie(0, 0)", "target": ""}
{"module": "games.py", "name": "TicTacToeO:0", "notes": "Same as above but for 2nd player", "sol_bodies": ["    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]  # 9-bit representation\n\n    good_boards = []\n\n    def x_move(x, o):  # returns True if o wins or ties, x's turn to move\n        if win[o] or x | o == 511:  # full board\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and not o_move(x | (1 << i), o):\n                return False\n        return True  # O wins/ties\n\n    def o_move(x, o):  # returns True if o wins or ties, o's turn to move\n        if win[x]:\n            return False\n        if x | o == 511:\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and x_move(x, o | (1 << i)):\n                good_boards.append(\n                    \"\".join(\".XO\"[((x >> j) & 1) + 2 * ((o >> j) & 1) + 2 * (i == j)] for j in range(9)))\n                return True\n        return False  # X wins\n\n    res = x_move(0, 0)\n    assert res\n\n    return good_boards"], "sol_header": "def sol():", "ans_type": "List[str]", "sol_docstring": "    \"\"\"\n    Compute a strategy for O (second player) in tic-tac-toe that guarantees a tie. That is a strategy for O that,\n    no matter what the opponent does, O does not lose.\n\n    A board is represented as a 9-char string like an X in the middle would be \"....X....\" and a\n    move is an integer 0-8. The answer is a list of \"good boards\" that O aims for, so no matter what X does there\n    is always good board that O can get to with a single move.\n    \"\"\"", "weight": 1.0, "sat": "def sat(good_boards: List[str]):\n    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in \"XO\") for b in good_boards}\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]\n\n    def tie(x, o):  # returns True if O has a forced tie/win. It's O's turn to move.\n        if o | x != 511:  # complete board\n            o |= 1 << [i for i in range(9) if (x, o | (1 << i)) in board_bit_reps][0]\n        return not win[x] and (win[o] or all((x | o) & (1 << i) or tie(x | (1 << i), o) for i in range(9)))\n\n    return all(tie(1 << i, 0) for i in range(9))", "input": "def sat(good_boards: List[str]):\n    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in \"XO\") for b in good_boards}\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]\n\n    def tie(x, o):  # returns True if O has a forced tie/win. It's O's turn to move.\n        if o | x != 511:  # complete board\n            o |= 1 << [i for i in range(9) if (x, o | (1 << i)) in board_bit_reps][0]\n        return not win[x] and (win[o] or all((x | o) & (1 << i) or tie(x | (1 << i), o) for i in range(9)))\n\n    return all(tie(1 << i, 0) for i in range(9))", "target": ""}
{"module": "games.py", "name": "ZeroSum:0", "notes": "Compute minimax optimal strategies for a given\n[zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game). This problem is known to be equivalent to\nLinear Programming. Note that the provided instances are all quite easy---harder solutions could readily\nbe made by decreasing the accuracy tolerance `eps` at which point the solution we provided would fail and\nmore efficient algorithms would be needed.", "sol_bodies": ["    MAX_ITER = 10 ** 4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"], "sol_header": "def sol(A=[[0.0, -0.5, 1.0], [0.75, 0.0, -1.0], [-1.0, 0.4, 0.0]], eps=0.01):", "ans_type": "List[List[float]]", "sol_docstring": "    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"", "weight": 1.0, "sat": "def sat(strategies: List[List[float]], A=[[0.0, -0.5, 1.0], [0.75, 0.0, -1.0], [-1.0, 0.4, 0.0]], eps=0.01):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "input": "def sat(strategies: List[List[float]], A=[[0.0, -0.5, 1.0], [0.75, 0.0, -1.0], [-1.0, 0.4, 0.0]], eps=0.01):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "target": ""}
{"module": "games.py", "name": "ZeroSum:1", "notes": "Compute minimax optimal strategies for a given\n[zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game). This problem is known to be equivalent to\nLinear Programming. Note that the provided instances are all quite easy---harder solutions could readily\nbe made by decreasing the accuracy tolerance `eps` at which point the solution we provided would fail and\nmore efficient algorithms would be needed.", "sol_bodies": ["    MAX_ITER = 10 ** 4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"], "sol_header": "def sol(A=[[0.5303369225581901, 0.4458248560112187, 0.47857713121903245], [0.07696760921779966, 0.40492093882513336, 0.8351857615090292]], eps=0.5):", "ans_type": "List[List[float]]", "sol_docstring": "    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"", "weight": 1.0, "sat": "def sat(strategies: List[List[float]], A=[[0.5303369225581901, 0.4458248560112187, 0.47857713121903245], [0.07696760921779966, 0.40492093882513336, 0.8351857615090292]], eps=0.5):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "input": "def sat(strategies: List[List[float]], A=[[0.5303369225581901, 0.4458248560112187, 0.47857713121903245], [0.07696760921779966, 0.40492093882513336, 0.8351857615090292]], eps=0.5):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "target": ""}
{"module": "games.py", "name": "ZeroSum:2", "notes": "Compute minimax optimal strategies for a given\n[zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game). This problem is known to be equivalent to\nLinear Programming. Note that the provided instances are all quite easy---harder solutions could readily\nbe made by decreasing the accuracy tolerance `eps` at which point the solution we provided would fail and\nmore efficient algorithms would be needed.", "sol_bodies": ["    MAX_ITER = 10 ** 4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"], "sol_header": "def sol(A=[[0.8737161029595927, 0.3380931327691771, 0.20525289813478453, 0.9772812942597162, 0.6011469499669913, 0.5657635078441663, 0.007362594660960342, 0.5523386597843655, 0.06548815570594102], [0.8440989957774637, 0.11456946368545384, 0.6266416865322296, 0.6112942108318355, 0.15090892170912606, 0.19181369635746925, 0.23558304486799253, 0.08883158381322309, 0.5626427070785186], [0.5990766112287766, 0.16770300013300976, 0.7790082288508813, 0.8213933806929374, 0.8409107317631046, 0.32215242243482034, 0.04927911582647726, 0.18589922022642869, 0.4416673076660764]], eps=0.1):", "ans_type": "List[List[float]]", "sol_docstring": "    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"", "weight": 1.0, "sat": "def sat(strategies: List[List[float]], A=[[0.8737161029595927, 0.3380931327691771, 0.20525289813478453, 0.9772812942597162, 0.6011469499669913, 0.5657635078441663, 0.007362594660960342, 0.5523386597843655, 0.06548815570594102], [0.8440989957774637, 0.11456946368545384, 0.6266416865322296, 0.6112942108318355, 0.15090892170912606, 0.19181369635746925, 0.23558304486799253, 0.08883158381322309, 0.5626427070785186], [0.5990766112287766, 0.16770300013300976, 0.7790082288508813, 0.8213933806929374, 0.8409107317631046, 0.32215242243482034, 0.04927911582647726, 0.18589922022642869, 0.4416673076660764]], eps=0.1):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "input": "def sat(strategies: List[List[float]], A=[[0.8737161029595927, 0.3380931327691771, 0.20525289813478453, 0.9772812942597162, 0.6011469499669913, 0.5657635078441663, 0.007362594660960342, 0.5523386597843655, 0.06548815570594102], [0.8440989957774637, 0.11456946368545384, 0.6266416865322296, 0.6112942108318355, 0.15090892170912606, 0.19181369635746925, 0.23558304486799253, 0.08883158381322309, 0.5626427070785186], [0.5990766112287766, 0.16770300013300976, 0.7790082288508813, 0.8213933806929374, 0.8409107317631046, 0.32215242243482034, 0.04927911582647726, 0.18589922022642869, 0.4416673076660764]], eps=0.1):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "target": ""}
{"module": "games.py", "name": "ZeroSum:3", "notes": "Compute minimax optimal strategies for a given\n[zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game). This problem is known to be equivalent to\nLinear Programming. Note that the provided instances are all quite easy---harder solutions could readily\nbe made by decreasing the accuracy tolerance `eps` at which point the solution we provided would fail and\nmore efficient algorithms would be needed.", "sol_bodies": ["    MAX_ITER = 10 ** 4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"], "sol_header": "def sol(A=[[0.35120738216503444, 0.6305426964442432, 0.09361690123750299, 0.17215263015782456, 0.3569473010721259], [0.9341169088059124, 0.43769720086284414, 0.35911118735479475, 0.37956863261812823, 0.9170151449695092]], eps=0.1):", "ans_type": "List[List[float]]", "sol_docstring": "    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"", "weight": 1.0, "sat": "def sat(strategies: List[List[float]], A=[[0.35120738216503444, 0.6305426964442432, 0.09361690123750299, 0.17215263015782456, 0.3569473010721259], [0.9341169088059124, 0.43769720086284414, 0.35911118735479475, 0.37956863261812823, 0.9170151449695092]], eps=0.1):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "input": "def sat(strategies: List[List[float]], A=[[0.35120738216503444, 0.6305426964442432, 0.09361690123750299, 0.17215263015782456, 0.3569473010721259], [0.9341169088059124, 0.43769720086284414, 0.35911118735479475, 0.37956863261812823, 0.9170151449695092]], eps=0.1):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "target": ""}
{"module": "games.py", "name": "ZeroSum:4", "notes": "Compute minimax optimal strategies for a given\n[zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game). This problem is known to be equivalent to\nLinear Programming. Note that the provided instances are all quite easy---harder solutions could readily\nbe made by decreasing the accuracy tolerance `eps` at which point the solution we provided would fail and\nmore efficient algorithms would be needed.", "sol_bodies": ["    MAX_ITER = 10 ** 4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"], "sol_header": "def sol(A=[[0.6637255179009651, 0.9756262037263238, 0.4926064602986052, 0.4097654368373934, 0.9284930704872523], [0.21641001481296873, 0.3381822244340763, 0.10113277325663139, 0.867285215856176, 0.27100572371021947], [0.7831143244052009, 0.6045743236145783, 0.10582868480749341, 0.5591604978434377, 0.27602687543748194], [0.8431935916393734, 0.09227518008541435, 0.06352450108543961, 0.13377427705288458, 0.8928593671227156], [0.15573895145866545, 0.3897235344943152, 0.5095156356106815, 0.25893802778092634, 0.4730747656010391]], eps=0.1):", "ans_type": "List[List[float]]", "sol_docstring": "    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"", "weight": 1.0, "sat": "def sat(strategies: List[List[float]], A=[[0.6637255179009651, 0.9756262037263238, 0.4926064602986052, 0.4097654368373934, 0.9284930704872523], [0.21641001481296873, 0.3381822244340763, 0.10113277325663139, 0.867285215856176, 0.27100572371021947], [0.7831143244052009, 0.6045743236145783, 0.10582868480749341, 0.5591604978434377, 0.27602687543748194], [0.8431935916393734, 0.09227518008541435, 0.06352450108543961, 0.13377427705288458, 0.8928593671227156], [0.15573895145866545, 0.3897235344943152, 0.5095156356106815, 0.25893802778092634, 0.4730747656010391]], eps=0.1):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "input": "def sat(strategies: List[List[float]], A=[[0.6637255179009651, 0.9756262037263238, 0.4926064602986052, 0.4097654368373934, 0.9284930704872523], [0.21641001481296873, 0.3381822244340763, 0.10113277325663139, 0.867285215856176, 0.27100572371021947], [0.7831143244052009, 0.6045743236145783, 0.10582868480749341, 0.5591604978434377, 0.27602687543748194], [0.8431935916393734, 0.09227518008541435, 0.06352450108543961, 0.13377427705288458, 0.8928593671227156], [0.15573895145866545, 0.3897235344943152, 0.5095156356106815, 0.25893802778092634, 0.4730747656010391]], eps=0.1):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))", "target": ""}
{"module": "graphs.py", "name": "AnyEdge:0", "notes": "Trivial [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics)) problem.", "sol_bodies": ["    return edges[0]"], "sol_header": "def sol(edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find any edge in edges.\"\"\"", "weight": 1.0, "sat": "def sat(e: List[int], edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):\n    return e in edges", "input": "def sat(e: List[int], edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):\n    return e in edges", "target": ""}
{"module": "graphs.py", "name": "AnyEdge:1", "notes": "Trivial [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics)) problem.", "sol_bodies": ["    return edges[0]"], "sol_header": "def sol(edges=[[0, 1], [1, 1], [0, 0]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find any edge in edges.\"\"\"", "weight": 1.0, "sat": "def sat(e: List[int], edges=[[0, 1], [1, 1], [0, 0]]):\n    return e in edges", "input": "def sat(e: List[int], edges=[[0, 1], [1, 1], [0, 0]]):\n    return e in edges", "target": ""}
{"module": "graphs.py", "name": "AnyEdge:2", "notes": "Trivial [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics)) problem.", "sol_bodies": ["    return edges[0]"], "sol_header": "def sol(edges=[[1, 0], [0, 1], [1, 1]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find any edge in edges.\"\"\"", "weight": 1.0, "sat": "def sat(e: List[int], edges=[[1, 0], [0, 1], [1, 1]]):\n    return e in edges", "input": "def sat(e: List[int], edges=[[1, 0], [0, 1], [1, 1]]):\n    return e in edges", "target": ""}
{"module": "graphs.py", "name": "AnyEdge:3", "notes": "Trivial [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics)) problem.", "sol_bodies": ["    return edges[0]"], "sol_header": "def sol(edges=[[1, 15], [15, 3], [5, 12], [11, 0], [8, 5], [1, 9], [3, 6], [5, 10], [12, 0], [6, 6], [9, 2], [13, 15], [2, 9], [5, 1], [10, 11], [4, 12], [0, 6], [8, 12], [15, 14], [1, 13], [11, 7], [15, 4], [13, 5], [7, 14], [14, 5], [12, 2], [7, 8], [2, 14], [3, 15], [2, 2], [7, 2], [3, 4], [4, 2], [1, 3], [4, 4], [3, 11], [14, 6], [14, 8], [14, 12], [7, 15], [7, 3], [7, 10], [10, 8], [7, 13], [2, 15], [14, 0], [1, 5], [11, 15], [1, 8], [6, 4], [15, 8], [9, 3], [1, 10], [2, 3], [4, 13], [7, 5], [2, 11], [0, 1], [15, 6], [0, 2], [5, 5]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find any edge in edges.\"\"\"", "weight": 1.0, "sat": "def sat(e: List[int], edges=[[1, 15], [15, 3], [5, 12], [11, 0], [8, 5], [1, 9], [3, 6], [5, 10], [12, 0], [6, 6], [9, 2], [13, 15], [2, 9], [5, 1], [10, 11], [4, 12], [0, 6], [8, 12], [15, 14], [1, 13], [11, 7], [15, 4], [13, 5], [7, 14], [14, 5], [12, 2], [7, 8], [2, 14], [3, 15], [2, 2], [7, 2], [3, 4], [4, 2], [1, 3], [4, 4], [3, 11], [14, 6], [14, 8], [14, 12], [7, 15], [7, 3], [7, 10], [10, 8], [7, 13], [2, 15], [14, 0], [1, 5], [11, 15], [1, 8], [6, 4], [15, 8], [9, 3], [1, 10], [2, 3], [4, 13], [7, 5], [2, 11], [0, 1], [15, 6], [0, 2], [5, 5]]):\n    return e in edges", "input": "def sat(e: List[int], edges=[[1, 15], [15, 3], [5, 12], [11, 0], [8, 5], [1, 9], [3, 6], [5, 10], [12, 0], [6, 6], [9, 2], [13, 15], [2, 9], [5, 1], [10, 11], [4, 12], [0, 6], [8, 12], [15, 14], [1, 13], [11, 7], [15, 4], [13, 5], [7, 14], [14, 5], [12, 2], [7, 8], [2, 14], [3, 15], [2, 2], [7, 2], [3, 4], [4, 2], [1, 3], [4, 4], [3, 11], [14, 6], [14, 8], [14, 12], [7, 15], [7, 3], [7, 10], [10, 8], [7, 13], [2, 15], [14, 0], [1, 5], [11, 15], [1, 8], [6, 4], [15, 8], [9, 3], [1, 10], [2, 3], [4, 13], [7, 5], [2, 11], [0, 1], [15, 6], [0, 2], [5, 5]]):\n    return e in edges", "target": ""}
{"module": "graphs.py", "name": "AnyEdge:4", "notes": "Trivial [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics)) problem.", "sol_bodies": ["    return edges[0]"], "sol_header": "def sol(edges=[[7, 84], [72, 0], [65, 93], [66, 13], [39, 15], [91, 6], [16, 77], [43, 71], [34, 72], [83, 1], [91, 93], [41, 20], [71, 69], [51, 60], [75, 22], [25, 82], [93, 45], [54, 31], [38, 22], [76, 33], [18, 81], [91, 74], [28, 97], [39, 69], [15, 26], [83, 75], [57, 24], [94, 38], [26, 23], [40, 48], [37, 20], [90, 84], [75, 8], [36, 21], [93, 11], [97, 74], [79, 74], [69, 36], [3, 29], [66, 82], [49, 15], [52, 43], [76, 25], [39, 11], [9, 93], [68, 55], [53, 46], [29, 90], [12, 81], [44, 66], [54, 55], [2, 30], [1, 6], [8, 61], [67, 10], [61, 84], [72, 51], [13, 27], [93, 53], [44, 38], [86, 14], [90, 8], [22, 62], [5, 72], [63, 36], [31, 51], [83, 5], [36, 53], [92, 78], [44, 80], [23, 16], [43, 16], [18, 37], [34, 14], [23, 6], [19, 61], [59, 10], [85, 30], [25, 80], [76, 39], [21, 28], [60, 47], [15, 43], [26, 80], [59, 19], [83, 81], [4, 64], [3, 71], [52, 34], [90, 14], [44, 84], [37, 56], [76, 10], [69, 89], [30, 38], [17, 38], [42, 7], [79, 62], [15, 87], [45, 4], [96, 0], [44, 43], [84, 42], [26, 22], [1, 91], [1, 11], [68, 7], [72, 32], [8, 0], [64, 59], [16, 86], [25, 46], [65, 30], [10, 43], [89, 43], [55, 0], [91, 66], [49, 0], [22, 77], [80, 21], [16, 58], [55, 45], [64, 13], [55, 56], [89, 96], [84, 20], [11, 74], [92, 91], [36, 15], [51, 8], [4, 44], [55, 55], [6, 83], [76, 5], [3, 11], [15, 96], [18, 15], [43, 58], [19, 70], [87, 41], [43, 47], [2, 51], [47, 32], [14, 93], [27, 61], [21, 26], [78, 88], [52, 40], [21, 79], [12, 8], [74, 73], [5, 22], [50, 4], [15, 67], [87, 10], [90, 24], [17, 45], [75, 96], [27, 81], [76, 29], [52, 93], [74, 40], [48, 62], [5, 75], [68, 58], [61, 19], [56, 54], [4, 29], [26, 60], [24, 1], [37, 41], [95, 63], [49, 37], [81, 18], [79, 91], [82, 8], [29, 73], [55, 84], [18, 13], [32, 7], [77, 63], [26, 72], [90, 5], [95, 4], [46, 13], [0, 64], [84, 34], [52, 51], [32, 30], [24, 55], [51, 17], [12, 7], [73, 34], [54, 47], [96, 95], [65, 67], [46, 90], [58, 17], [54, 2], [45, 10], [84, 45], [46, 6], [0, 4], [16, 60], [50, 35], [86, 45], [89, 19], [48, 10], [4, 57], [43, 62], [19, 30], [2, 35], [83, 68], [36, 26], [69, 4], [41, 82], [12, 52], [77, 95], [90, 75], [78, 58], [93, 29], [38, 87], [15, 82], [42, 86], [39, 90], [20, 53], [79, 25], [68, 81], [64, 82], [45, 56], [14, 85], [97, 13], [46, 15], [46, 43], [8, 71], [90, 72], [97, 66], [80, 57], [25, 8], [90, 74]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find any edge in edges.\"\"\"", "weight": 1.0, "sat": "def sat(e: List[int], edges=[[7, 84], [72, 0], [65, 93], [66, 13], [39, 15], [91, 6], [16, 77], [43, 71], [34, 72], [83, 1], [91, 93], [41, 20], [71, 69], [51, 60], [75, 22], [25, 82], [93, 45], [54, 31], [38, 22], [76, 33], [18, 81], [91, 74], [28, 97], [39, 69], [15, 26], [83, 75], [57, 24], [94, 38], [26, 23], [40, 48], [37, 20], [90, 84], [75, 8], [36, 21], [93, 11], [97, 74], [79, 74], [69, 36], [3, 29], [66, 82], [49, 15], [52, 43], [76, 25], [39, 11], [9, 93], [68, 55], [53, 46], [29, 90], [12, 81], [44, 66], [54, 55], [2, 30], [1, 6], [8, 61], [67, 10], [61, 84], [72, 51], [13, 27], [93, 53], [44, 38], [86, 14], [90, 8], [22, 62], [5, 72], [63, 36], [31, 51], [83, 5], [36, 53], [92, 78], [44, 80], [23, 16], [43, 16], [18, 37], [34, 14], [23, 6], [19, 61], [59, 10], [85, 30], [25, 80], [76, 39], [21, 28], [60, 47], [15, 43], [26, 80], [59, 19], [83, 81], [4, 64], [3, 71], [52, 34], [90, 14], [44, 84], [37, 56], [76, 10], [69, 89], [30, 38], [17, 38], [42, 7], [79, 62], [15, 87], [45, 4], [96, 0], [44, 43], [84, 42], [26, 22], [1, 91], [1, 11], [68, 7], [72, 32], [8, 0], [64, 59], [16, 86], [25, 46], [65, 30], [10, 43], [89, 43], [55, 0], [91, 66], [49, 0], [22, 77], [80, 21], [16, 58], [55, 45], [64, 13], [55, 56], [89, 96], [84, 20], [11, 74], [92, 91], [36, 15], [51, 8], [4, 44], [55, 55], [6, 83], [76, 5], [3, 11], [15, 96], [18, 15], [43, 58], [19, 70], [87, 41], [43, 47], [2, 51], [47, 32], [14, 93], [27, 61], [21, 26], [78, 88], [52, 40], [21, 79], [12, 8], [74, 73], [5, 22], [50, 4], [15, 67], [87, 10], [90, 24], [17, 45], [75, 96], [27, 81], [76, 29], [52, 93], [74, 40], [48, 62], [5, 75], [68, 58], [61, 19], [56, 54], [4, 29], [26, 60], [24, 1], [37, 41], [95, 63], [49, 37], [81, 18], [79, 91], [82, 8], [29, 73], [55, 84], [18, 13], [32, 7], [77, 63], [26, 72], [90, 5], [95, 4], [46, 13], [0, 64], [84, 34], [52, 51], [32, 30], [24, 55], [51, 17], [12, 7], [73, 34], [54, 47], [96, 95], [65, 67], [46, 90], [58, 17], [54, 2], [45, 10], [84, 45], [46, 6], [0, 4], [16, 60], [50, 35], [86, 45], [89, 19], [48, 10], [4, 57], [43, 62], [19, 30], [2, 35], [83, 68], [36, 26], [69, 4], [41, 82], [12, 52], [77, 95], [90, 75], [78, 58], [93, 29], [38, 87], [15, 82], [42, 86], [39, 90], [20, 53], [79, 25], [68, 81], [64, 82], [45, 56], [14, 85], [97, 13], [46, 15], [46, 43], [8, 71], [90, 72], [97, 66], [80, 57], [25, 8], [90, 74]]):\n    return e in edges", "input": "def sat(e: List[int], edges=[[7, 84], [72, 0], [65, 93], [66, 13], [39, 15], [91, 6], [16, 77], [43, 71], [34, 72], [83, 1], [91, 93], [41, 20], [71, 69], [51, 60], [75, 22], [25, 82], [93, 45], [54, 31], [38, 22], [76, 33], [18, 81], [91, 74], [28, 97], [39, 69], [15, 26], [83, 75], [57, 24], [94, 38], [26, 23], [40, 48], [37, 20], [90, 84], [75, 8], [36, 21], [93, 11], [97, 74], [79, 74], [69, 36], [3, 29], [66, 82], [49, 15], [52, 43], [76, 25], [39, 11], [9, 93], [68, 55], [53, 46], [29, 90], [12, 81], [44, 66], [54, 55], [2, 30], [1, 6], [8, 61], [67, 10], [61, 84], [72, 51], [13, 27], [93, 53], [44, 38], [86, 14], [90, 8], [22, 62], [5, 72], [63, 36], [31, 51], [83, 5], [36, 53], [92, 78], [44, 80], [23, 16], [43, 16], [18, 37], [34, 14], [23, 6], [19, 61], [59, 10], [85, 30], [25, 80], [76, 39], [21, 28], [60, 47], [15, 43], [26, 80], [59, 19], [83, 81], [4, 64], [3, 71], [52, 34], [90, 14], [44, 84], [37, 56], [76, 10], [69, 89], [30, 38], [17, 38], [42, 7], [79, 62], [15, 87], [45, 4], [96, 0], [44, 43], [84, 42], [26, 22], [1, 91], [1, 11], [68, 7], [72, 32], [8, 0], [64, 59], [16, 86], [25, 46], [65, 30], [10, 43], [89, 43], [55, 0], [91, 66], [49, 0], [22, 77], [80, 21], [16, 58], [55, 45], [64, 13], [55, 56], [89, 96], [84, 20], [11, 74], [92, 91], [36, 15], [51, 8], [4, 44], [55, 55], [6, 83], [76, 5], [3, 11], [15, 96], [18, 15], [43, 58], [19, 70], [87, 41], [43, 47], [2, 51], [47, 32], [14, 93], [27, 61], [21, 26], [78, 88], [52, 40], [21, 79], [12, 8], [74, 73], [5, 22], [50, 4], [15, 67], [87, 10], [90, 24], [17, 45], [75, 96], [27, 81], [76, 29], [52, 93], [74, 40], [48, 62], [5, 75], [68, 58], [61, 19], [56, 54], [4, 29], [26, 60], [24, 1], [37, 41], [95, 63], [49, 37], [81, 18], [79, 91], [82, 8], [29, 73], [55, 84], [18, 13], [32, 7], [77, 63], [26, 72], [90, 5], [95, 4], [46, 13], [0, 64], [84, 34], [52, 51], [32, 30], [24, 55], [51, 17], [12, 7], [73, 34], [54, 47], [96, 95], [65, 67], [46, 90], [58, 17], [54, 2], [45, 10], [84, 45], [46, 6], [0, 4], [16, 60], [50, 35], [86, 45], [89, 19], [48, 10], [4, 57], [43, 62], [19, 30], [2, 35], [83, 68], [36, 26], [69, 4], [41, 82], [12, 52], [77, 95], [90, 75], [78, 58], [93, 29], [38, 87], [15, 82], [42, 86], [39, 90], [20, 53], [79, 25], [68, 81], [64, 82], [45, 56], [14, 85], [97, 13], [46, 15], [46, 43], [8, 71], [90, 72], [97, 66], [80, 57], [25, 8], [90, 74]]):\n    return e in edges", "target": ""}
{"module": "graphs.py", "name": "PlantedClique:0", "notes": "Find a [planted clique](https://en.wikipedia.org/w/index.php?title=Planted_clique) of a given size\nin an undirected graph. Finding a polynomial-time algorithm for this problem has been *unsolved* for\nsome time.", "sol_bodies": ["    # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""], "sol_header": "def sol(size=3, edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"", "weight": 1.0, "sat": "def sat(nodes: List[int], size=3, edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True", "input": "def sat(nodes: List[int], size=3, edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True", "target": ""}
{"module": "graphs.py", "name": "PlantedClique:1", "notes": "Find a [planted clique](https://en.wikipedia.org/w/index.php?title=Planted_clique) of a given size\nin an undirected graph. Finding a polynomial-time algorithm for this problem has been *unsolved* for\nsome time.", "sol_bodies": ["    # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""], "sol_header": "def sol(edges=[[1, 0]], size=0):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"", "weight": 1.0, "sat": "def sat(nodes: List[int], size=0, edges=[[1, 0]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True", "input": "def sat(nodes: List[int], size=0, edges=[[1, 0]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True", "target": ""}
{"module": "graphs.py", "name": "PlantedClique:2", "notes": "Find a [planted clique](https://en.wikipedia.org/w/index.php?title=Planted_clique) of a given size\nin an undirected graph. Finding a polynomial-time algorithm for this problem has been *unsolved* for\nsome time.", "sol_bodies": [], "sol_header": "def sol(edges=[[36, 31], [31, 39], [16, 41], [62, 39], [57, 38], [29, 46], [39, 30], [71, 41], [18, 0], [73, 71], [20, 23], [41, 53], [17, 12], [76, 23], [36, 29], [53, 32], [34, 61], [58, 29], [39, 46], [18, 73], [21, 51], [74, 26], [67, 10], [71, 74], [27, 71], [67, 39], [41, 26], [51, 20], [5, 2], [24, 3], [14, 60], [28, 21], [61, 1], [56, 75], [62, 37], [67, 41], [32, 69], [22, 16], [1, 67], [37, 14], [55, 40], [0, 58], [16, 63], [8, 59], [26, 61], [34, 51], [43, 66], [31, 33], [7, 51], [1, 0], [22, 9], [59, 68], [9, 10], [8, 74], [62, 8], [26, 16], [45, 69], [51, 52], [72, 67], [37, 53], [48, 5], [18, 41], [15, 11], [72, 43], [64, 51], [4, 9], [54, 42], [62, 15], [12, 38], [30, 31], [56, 37], [29, 2], [14, 9], [43, 43], [51, 28], [10, 15], [20, 5], [24, 61], [53, 2], [69, 1], [35, 63], [12, 64], [50, 12], [69, 65], [60, 75], [56, 48], [36, 67], [21, 6], [38, 67], [15, 34], [46, 54], [37, 18], [32, 2], [12, 49], [52, 15], [60, 2], [67, 43], [13, 49], [55, 59], [33, 72], [37, 30], [11, 27], [67, 2], [57, 55], [21, 65], [54, 66], [6, 63], [71, 59], [20, 59], [47, 34], [66, 67], [4, 8], [73, 61], [68, 41], [61, 7], [52, 38], [8, 51], [50, 15], [5, 12], [76, 74], [66, 33], [59, 18], [13, 55], [6, 16], [13, 26], [29, 44], [18, 43], [63, 47], [46, 30], [41, 18], [66, 18], [34, 26], [57, 28], [38, 10], [34, 57], [73, 41], [67, 3], [47, 57], [63, 62], [36, 30], [72, 45], [68, 19], [7, 28], [50, 23], [42, 29], [3, 66], [56, 45], [4, 25], [2, 43], [4, 38], [56, 74], [55, 10], [0, 13], [9, 19], [38, 69], [40, 57], [70, 41], [49, 45], [47, 27], [11, 8], [32, 5], [9, 38], [76, 64], [24, 33], [74, 63], [73, 58], [58, 41], [75, 0], [33, 55], [74, 2], [41, 72], [1, 64], [36, 74], [51, 71], [75, 9], [53, 36], [8, 70], [53, 42], [58, 25], [29, 37], [34, 46], [37, 39], [59, 61], [52, 20], [16, 58], [39, 43], [37, 40], [10, 72], [76, 14], [49, 13], [21, 37], [42, 2], [10, 29], [76, 19], [57, 66], [55, 62], [76, 53], [0, 0], [58, 5], [14, 2], [5, 32], [70, 57], [20, 18], [74, 66], [39, 57], [32, 36], [15, 30], [56, 23], [67, 16], [66, 51], [6, 74], [43, 59], [33, 70], [11, 71], [59, 28], [75, 29], [17, 13], [75, 67], [70, 1], [68, 10], [8, 46], [37, 27], [20, 24], [72, 75], [37, 41], [68, 24], [35, 10], [67, 66], [18, 24], [52, 3], [55, 34], [28, 75], [41, 3], [44, 3], [44, 30], [23, 17], [44, 4], [72, 73], [67, 12], [43, 21], [16, 55], [59, 71], [26, 62], [34, 60], [15, 22], [5, 10], [2, 55], [48, 15], [60, 34], [39, 35], [52, 36], [11, 46], [18, 10], [3, 43], [37, 6], [34, 47], [73, 29], [59, 29], [49, 72], [64, 73], [20, 76], [39, 39], [0, 16], [62, 73], [15, 36], [73, 18], [16, 34], [18, 68], [66, 45], [16, 66], [47, 52], [46, 66], [73, 43], [22, 55], [70, 58], [63, 11], [40, 2], [58, 60], [47, 29], [19, 45], [15, 41], [54, 5], [1, 18], [36, 38], [16, 19], [32, 4], [56, 14], [15, 51], [14, 35], [74, 10], [7, 20], [25, 38], [35, 13], [57, 34], [3, 16], [56, 28], [21, 56], [63, 65], [46, 35], [17, 57], [2, 30], [52, 73], [68, 73], [53, 10], [58, 59], [29, 16], [11, 20], [42, 27], [10, 66], [73, 5], [61, 58], [68, 67], [14, 47], [19, 59], [8, 42], [31, 12], [3, 2], [52, 66], [28, 72], [30, 56], [27, 12], [29, 18], [38, 56], [11, 17], [59, 66], [70, 7], [1, 54], [2, 16], [1, 14], [25, 20], [69, 72], [20, 74], [10, 59], [72, 52], [26, 15], [44, 42], [5, 51], [76, 69], [16, 10], [75, 39], [5, 44], [0, 46], [16, 76], [66, 73], [66, 72], [11, 11], [47, 13], [20, 26], [73, 59], [3, 10], [46, 49], [17, 38], [32, 62], [41, 2], [16, 72], [76, 61], [15, 37], [74, 69], [38, 46], [68, 58], [51, 70], [20, 46], [59, 2], [35, 21], [72, 37], [69, 20], [3, 72], [43, 71], [1, 71], [48, 59], [43, 58], [74, 5], [59, 72], [45, 24], [66, 69], [35, 38], [16, 5], [40, 24], [63, 30], [16, 18], [72, 29], [72, 58], [42, 5], [17, 30], [14, 21], [48, 23], [53, 44], [1, 47], [57, 33], [47, 69], [65, 52], [51, 44], [60, 35], [41, 9], [59, 75], [57, 73], [58, 28], [65, 23], [36, 48], [26, 40], [39, 41], [58, 3], [40, 42], [58, 49], [28, 42], [33, 36], [44, 24], [2, 68], [30, 57], [10, 51], [3, 68], [26, 42], [51, 13], [12, 69], [19, 60], [58, 39], [1, 45], [66, 16], [41, 27], [56, 1], [28, 18], [66, 29], [37, 49], [59, 4], [29, 67], [38, 29], [54, 57], [47, 61], [68, 29], [38, 9], [51, 41], [41, 10], [19, 61], [3, 22], [72, 23], [18, 11], [27, 17], [72, 74], [5, 37], [66, 68], [2, 3], [60, 27], [68, 72], [64, 20], [67, 18], [6, 66], [24, 60], [14, 75], [9, 11], [71, 50], [66, 43], [6, 60], [54, 22], [71, 53], [51, 7], [49, 40], [7, 74], [72, 30], [20, 71], [28, 74], [36, 55], [16, 17], [66, 2], [53, 8], [18, 2], [62, 63], [63, 26], [19, 34], [26, 27], [67, 51], [61, 46], [37, 29], [66, 41], [51, 54], [3, 17], [35, 6], [50, 51], [8, 15], [15, 55], [10, 65], [57, 59], [69, 21], [73, 70], [21, 30], [28, 28], [67, 59], [39, 76], [56, 12], [22, 69], [76, 7], [63, 66], [9, 40], [64, 28], [65, 31], [6, 59], [73, 73], [24, 29], [44, 18], [67, 1], [16, 12], [73, 2], [74, 27], [25, 58], [18, 52], [12, 66], [32, 25], [26, 4], [34, 27], [51, 39], [23, 11], [13, 65], [18, 28], [19, 6], [68, 59], [51, 72], [59, 74], [59, 3], [41, 29], [36, 6], [49, 37], [71, 39], [33, 13], [38, 68], [34, 19], [64, 36], [4, 29], [72, 60], [52, 41], [36, 66], [34, 70], [22, 32], [67, 40], [3, 73], [19, 12], [17, 0], [22, 8], [42, 35], [34, 54], [71, 29], [6, 7], [10, 43], [8, 56], [2, 58], [72, 2], [67, 65], [1, 23], [13, 21], [62, 38], [2, 66], [42, 62], [38, 27], [1, 22], [16, 29], [39, 54], [41, 0], [42, 54], [50, 58], [62, 45], [59, 76], [40, 44], [72, 18], [45, 40], [31, 3], [13, 45], [38, 64], [1, 21], [10, 32], [35, 12], [32, 6], [62, 75], [52, 59], [1, 42], [72, 31], [55, 17], [18, 50], [43, 29], [48, 37], [73, 16], [43, 68], [47, 12], [55, 46], [41, 30], [69, 32], [55, 14], [74, 61], [55, 72], [75, 24], [63, 40], [10, 58], [67, 73], [20, 11], [42, 40], [27, 53], [5, 8], [10, 2], [27, 49], [50, 48], [18, 58], [60, 25], [74, 71], [0, 30], [3, 29], [59, 5], [43, 16], [59, 41], [74, 4], [19, 20], [53, 19], [57, 50], [60, 11], [16, 68], [9, 50], [71, 17], [73, 66], [59, 43], [68, 32], [75, 31], [27, 56], [47, 24], [29, 7], [27, 25], [48, 36], [0, 53], [0, 72], [24, 53], [13, 64], [19, 44], [9, 56], [35, 75], [75, 17], [47, 16], [11, 42], [40, 45], [43, 60], [21, 59], [29, 50], [8, 9], [3, 18], [7, 57], [32, 9], [61, 6], [11, 6], [7, 72], [42, 61], [73, 75], [68, 44], [68, 66], [25, 56], [14, 20], [3, 50], [32, 57], [67, 58], [41, 68], [19, 26], [30, 3], [23, 45], [16, 60], [41, 43], [5, 30], [5, 25], [72, 16], [16, 73], [21, 17], [16, 59], [8, 34], [4, 39], [23, 72], [35, 53], [31, 50], [20, 44], [50, 13], [72, 1], [8, 8], [74, 54], [1, 1], [16, 43], [39, 36], [51, 2], [23, 54], [66, 58], [60, 33], [2, 63], [73, 10]], size=15):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"", "weight": 1.0, "sat": "def sat(nodes: List[int], size=15, edges=[[36, 31], [31, 39], [16, 41], [62, 39], [57, 38], [29, 46], [39, 30], [71, 41], [18, 0], [73, 71], [20, 23], [41, 53], [17, 12], [76, 23], [36, 29], [53, 32], [34, 61], [58, 29], [39, 46], [18, 73], [21, 51], [74, 26], [67, 10], [71, 74], [27, 71], [67, 39], [41, 26], [51, 20], [5, 2], [24, 3], [14, 60], [28, 21], [61, 1], [56, 75], [62, 37], [67, 41], [32, 69], [22, 16], [1, 67], [37, 14], [55, 40], [0, 58], [16, 63], [8, 59], [26, 61], [34, 51], [43, 66], [31, 33], [7, 51], [1, 0], [22, 9], [59, 68], [9, 10], [8, 74], [62, 8], [26, 16], [45, 69], [51, 52], [72, 67], [37, 53], [48, 5], [18, 41], [15, 11], [72, 43], [64, 51], [4, 9], [54, 42], [62, 15], [12, 38], [30, 31], [56, 37], [29, 2], [14, 9], [43, 43], [51, 28], [10, 15], [20, 5], [24, 61], [53, 2], [69, 1], [35, 63], [12, 64], [50, 12], [69, 65], [60, 75], [56, 48], [36, 67], [21, 6], [38, 67], [15, 34], [46, 54], [37, 18], [32, 2], [12, 49], [52, 15], [60, 2], [67, 43], [13, 49], [55, 59], [33, 72], [37, 30], [11, 27], [67, 2], [57, 55], [21, 65], [54, 66], [6, 63], [71, 59], [20, 59], [47, 34], [66, 67], [4, 8], [73, 61], [68, 41], [61, 7], [52, 38], [8, 51], [50, 15], [5, 12], [76, 74], [66, 33], [59, 18], [13, 55], [6, 16], [13, 26], [29, 44], [18, 43], [63, 47], [46, 30], [41, 18], [66, 18], [34, 26], [57, 28], [38, 10], [34, 57], [73, 41], [67, 3], [47, 57], [63, 62], [36, 30], [72, 45], [68, 19], [7, 28], [50, 23], [42, 29], [3, 66], [56, 45], [4, 25], [2, 43], [4, 38], [56, 74], [55, 10], [0, 13], [9, 19], [38, 69], [40, 57], [70, 41], [49, 45], [47, 27], [11, 8], [32, 5], [9, 38], [76, 64], [24, 33], [74, 63], [73, 58], [58, 41], [75, 0], [33, 55], [74, 2], [41, 72], [1, 64], [36, 74], [51, 71], [75, 9], [53, 36], [8, 70], [53, 42], [58, 25], [29, 37], [34, 46], [37, 39], [59, 61], [52, 20], [16, 58], [39, 43], [37, 40], [10, 72], [76, 14], [49, 13], [21, 37], [42, 2], [10, 29], [76, 19], [57, 66], [55, 62], [76, 53], [0, 0], [58, 5], [14, 2], [5, 32], [70, 57], [20, 18], [74, 66], [39, 57], [32, 36], [15, 30], [56, 23], [67, 16], [66, 51], [6, 74], [43, 59], [33, 70], [11, 71], [59, 28], [75, 29], [17, 13], [75, 67], [70, 1], [68, 10], [8, 46], [37, 27], [20, 24], [72, 75], [37, 41], [68, 24], [35, 10], [67, 66], [18, 24], [52, 3], [55, 34], [28, 75], [41, 3], [44, 3], [44, 30], [23, 17], [44, 4], [72, 73], [67, 12], [43, 21], [16, 55], [59, 71], [26, 62], [34, 60], [15, 22], [5, 10], [2, 55], [48, 15], [60, 34], [39, 35], [52, 36], [11, 46], [18, 10], [3, 43], [37, 6], [34, 47], [73, 29], [59, 29], [49, 72], [64, 73], [20, 76], [39, 39], [0, 16], [62, 73], [15, 36], [73, 18], [16, 34], [18, 68], [66, 45], [16, 66], [47, 52], [46, 66], [73, 43], [22, 55], [70, 58], [63, 11], [40, 2], [58, 60], [47, 29], [19, 45], [15, 41], [54, 5], [1, 18], [36, 38], [16, 19], [32, 4], [56, 14], [15, 51], [14, 35], [74, 10], [7, 20], [25, 38], [35, 13], [57, 34], [3, 16], [56, 28], [21, 56], [63, 65], [46, 35], [17, 57], [2, 30], [52, 73], [68, 73], [53, 10], [58, 59], [29, 16], [11, 20], [42, 27], [10, 66], [73, 5], [61, 58], [68, 67], [14, 47], [19, 59], [8, 42], [31, 12], [3, 2], [52, 66], [28, 72], [30, 56], [27, 12], [29, 18], [38, 56], [11, 17], [59, 66], [70, 7], [1, 54], [2, 16], [1, 14], [25, 20], [69, 72], [20, 74], [10, 59], [72, 52], [26, 15], [44, 42], [5, 51], [76, 69], [16, 10], [75, 39], [5, 44], [0, 46], [16, 76], [66, 73], [66, 72], [11, 11], [47, 13], [20, 26], [73, 59], [3, 10], [46, 49], [17, 38], [32, 62], [41, 2], [16, 72], [76, 61], [15, 37], [74, 69], [38, 46], [68, 58], [51, 70], [20, 46], [59, 2], [35, 21], [72, 37], [69, 20], [3, 72], [43, 71], [1, 71], [48, 59], [43, 58], [74, 5], [59, 72], [45, 24], [66, 69], [35, 38], [16, 5], [40, 24], [63, 30], [16, 18], [72, 29], [72, 58], [42, 5], [17, 30], [14, 21], [48, 23], [53, 44], [1, 47], [57, 33], [47, 69], [65, 52], [51, 44], [60, 35], [41, 9], [59, 75], [57, 73], [58, 28], [65, 23], [36, 48], [26, 40], [39, 41], [58, 3], [40, 42], [58, 49], [28, 42], [33, 36], [44, 24], [2, 68], [30, 57], [10, 51], [3, 68], [26, 42], [51, 13], [12, 69], [19, 60], [58, 39], [1, 45], [66, 16], [41, 27], [56, 1], [28, 18], [66, 29], [37, 49], [59, 4], [29, 67], [38, 29], [54, 57], [47, 61], [68, 29], [38, 9], [51, 41], [41, 10], [19, 61], [3, 22], [72, 23], [18, 11], [27, 17], [72, 74], [5, 37], [66, 68], [2, 3], [60, 27], [68, 72], [64, 20], [67, 18], [6, 66], [24, 60], [14, 75], [9, 11], [71, 50], [66, 43], [6, 60], [54, 22], [71, 53], [51, 7], [49, 40], [7, 74], [72, 30], [20, 71], [28, 74], [36, 55], [16, 17], [66, 2], [53, 8], [18, 2], [62, 63], [63, 26], [19, 34], [26, 27], [67, 51], [61, 46], [37, 29], [66, 41], [51, 54], [3, 17], [35, 6], [50, 51], [8, 15], [15, 55], [10, 65], [57, 59], [69, 21], [73, 70], [21, 30], [28, 28], [67, 59], [39, 76], [56, 12], [22, 69], [76, 7], [63, 66], [9, 40], [64, 28], [65, 31], [6, 59], [73, 73], [24, 29], [44, 18], [67, 1], [16, 12], [73, 2], [74, 27], [25, 58], [18, 52], [12, 66], [32, 25], [26, 4], [34, 27], [51, 39], [23, 11], [13, 65], [18, 28], [19, 6], [68, 59], [51, 72], [59, 74], [59, 3], [41, 29], [36, 6], [49, 37], [71, 39], [33, 13], [38, 68], [34, 19], [64, 36], [4, 29], [72, 60], [52, 41], [36, 66], [34, 70], [22, 32], [67, 40], [3, 73], [19, 12], [17, 0], [22, 8], [42, 35], [34, 54], [71, 29], [6, 7], [10, 43], [8, 56], [2, 58], [72, 2], [67, 65], [1, 23], [13, 21], [62, 38], [2, 66], [42, 62], [38, 27], [1, 22], [16, 29], [39, 54], [41, 0], [42, 54], [50, 58], [62, 45], [59, 76], [40, 44], [72, 18], [45, 40], [31, 3], [13, 45], [38, 64], [1, 21], [10, 32], [35, 12], [32, 6], [62, 75], [52, 59], [1, 42], [72, 31], [55, 17], [18, 50], [43, 29], [48, 37], [73, 16], [43, 68], [47, 12], [55, 46], [41, 30], [69, 32], [55, 14], [74, 61], [55, 72], [75, 24], [63, 40], [10, 58], [67, 73], [20, 11], [42, 40], [27, 53], [5, 8], [10, 2], [27, 49], [50, 48], [18, 58], [60, 25], [74, 71], [0, 30], [3, 29], [59, 5], [43, 16], [59, 41], [74, 4], [19, 20], [53, 19], [57, 50], [60, 11], [16, 68], [9, 50], [71, 17], [73, 66], [59, 43], [68, 32], [75, 31], [27, 56], [47, 24], [29, 7], [27, 25], [48, 36], [0, 53], [0, 72], [24, 53], [13, 64], [19, 44], [9, 56], [35, 75], [75, 17], [47, 16], [11, 42], [40, 45], [43, 60], [21, 59], [29, 50], [8, 9], [3, 18], [7, 57], [32, 9], [61, 6], [11, 6], [7, 72], [42, 61], [73, 75], [68, 44], [68, 66], [25, 56], [14, 20], [3, 50], [32, 57], [67, 58], [41, 68], [19, 26], [30, 3], [23, 45], [16, 60], [41, 43], [5, 30], [5, 25], [72, 16], [16, 73], [21, 17], [16, 59], [8, 34], [4, 39], [23, 72], [35, 53], [31, 50], [20, 44], [50, 13], [72, 1], [8, 8], [74, 54], [1, 1], [16, 43], [39, 36], [51, 2], [23, 54], [66, 58], [60, 33], [2, 63], [73, 10]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True", "input": "def sat(nodes: List[int], size=15, edges=[[36, 31], [31, 39], [16, 41], [62, 39], [57, 38], [29, 46], [39, 30], [71, 41], [18, 0], [73, 71], [20, 23], [41, 53], [17, 12], [76, 23], [36, 29], [53, 32], [34, 61], [58, 29], [39, 46], [18, 73], [21, 51], [74, 26], [67, 10], [71, 74], [27, 71], [67, 39], [41, 26], [51, 20], [5, 2], [24, 3], [14, 60], [28, 21], [61, 1], [56, 75], [62, 37], [67, 41], [32, 69], [22, 16], [1, 67], [37, 14], [55, 40], [0, 58], [16, 63], [8, 59], [26, 61], [34, 51], [43, 66], [31, 33], [7, 51], [1, 0], [22, 9], [59, 68], [9, 10], [8, 74], [62, 8], [26, 16], [45, 69], [51, 52], [72, 67], [37, 53], [48, 5], [18, 41], [15, 11], [72, 43], [64, 51], [4, 9], [54, 42], [62, 15], [12, 38], [30, 31], [56, 37], [29, 2], [14, 9], [43, 43], [51, 28], [10, 15], [20, 5], [24, 61], [53, 2], [69, 1], [35, 63], [12, 64], [50, 12], [69, 65], [60, 75], [56, 48], [36, 67], [21, 6], [38, 67], [15, 34], [46, 54], [37, 18], [32, 2], [12, 49], [52, 15], [60, 2], [67, 43], [13, 49], [55, 59], [33, 72], [37, 30], [11, 27], [67, 2], [57, 55], [21, 65], [54, 66], [6, 63], [71, 59], [20, 59], [47, 34], [66, 67], [4, 8], [73, 61], [68, 41], [61, 7], [52, 38], [8, 51], [50, 15], [5, 12], [76, 74], [66, 33], [59, 18], [13, 55], [6, 16], [13, 26], [29, 44], [18, 43], [63, 47], [46, 30], [41, 18], [66, 18], [34, 26], [57, 28], [38, 10], [34, 57], [73, 41], [67, 3], [47, 57], [63, 62], [36, 30], [72, 45], [68, 19], [7, 28], [50, 23], [42, 29], [3, 66], [56, 45], [4, 25], [2, 43], [4, 38], [56, 74], [55, 10], [0, 13], [9, 19], [38, 69], [40, 57], [70, 41], [49, 45], [47, 27], [11, 8], [32, 5], [9, 38], [76, 64], [24, 33], [74, 63], [73, 58], [58, 41], [75, 0], [33, 55], [74, 2], [41, 72], [1, 64], [36, 74], [51, 71], [75, 9], [53, 36], [8, 70], [53, 42], [58, 25], [29, 37], [34, 46], [37, 39], [59, 61], [52, 20], [16, 58], [39, 43], [37, 40], [10, 72], [76, 14], [49, 13], [21, 37], [42, 2], [10, 29], [76, 19], [57, 66], [55, 62], [76, 53], [0, 0], [58, 5], [14, 2], [5, 32], [70, 57], [20, 18], [74, 66], [39, 57], [32, 36], [15, 30], [56, 23], [67, 16], [66, 51], [6, 74], [43, 59], [33, 70], [11, 71], [59, 28], [75, 29], [17, 13], [75, 67], [70, 1], [68, 10], [8, 46], [37, 27], [20, 24], [72, 75], [37, 41], [68, 24], [35, 10], [67, 66], [18, 24], [52, 3], [55, 34], [28, 75], [41, 3], [44, 3], [44, 30], [23, 17], [44, 4], [72, 73], [67, 12], [43, 21], [16, 55], [59, 71], [26, 62], [34, 60], [15, 22], [5, 10], [2, 55], [48, 15], [60, 34], [39, 35], [52, 36], [11, 46], [18, 10], [3, 43], [37, 6], [34, 47], [73, 29], [59, 29], [49, 72], [64, 73], [20, 76], [39, 39], [0, 16], [62, 73], [15, 36], [73, 18], [16, 34], [18, 68], [66, 45], [16, 66], [47, 52], [46, 66], [73, 43], [22, 55], [70, 58], [63, 11], [40, 2], [58, 60], [47, 29], [19, 45], [15, 41], [54, 5], [1, 18], [36, 38], [16, 19], [32, 4], [56, 14], [15, 51], [14, 35], [74, 10], [7, 20], [25, 38], [35, 13], [57, 34], [3, 16], [56, 28], [21, 56], [63, 65], [46, 35], [17, 57], [2, 30], [52, 73], [68, 73], [53, 10], [58, 59], [29, 16], [11, 20], [42, 27], [10, 66], [73, 5], [61, 58], [68, 67], [14, 47], [19, 59], [8, 42], [31, 12], [3, 2], [52, 66], [28, 72], [30, 56], [27, 12], [29, 18], [38, 56], [11, 17], [59, 66], [70, 7], [1, 54], [2, 16], [1, 14], [25, 20], [69, 72], [20, 74], [10, 59], [72, 52], [26, 15], [44, 42], [5, 51], [76, 69], [16, 10], [75, 39], [5, 44], [0, 46], [16, 76], [66, 73], [66, 72], [11, 11], [47, 13], [20, 26], [73, 59], [3, 10], [46, 49], [17, 38], [32, 62], [41, 2], [16, 72], [76, 61], [15, 37], [74, 69], [38, 46], [68, 58], [51, 70], [20, 46], [59, 2], [35, 21], [72, 37], [69, 20], [3, 72], [43, 71], [1, 71], [48, 59], [43, 58], [74, 5], [59, 72], [45, 24], [66, 69], [35, 38], [16, 5], [40, 24], [63, 30], [16, 18], [72, 29], [72, 58], [42, 5], [17, 30], [14, 21], [48, 23], [53, 44], [1, 47], [57, 33], [47, 69], [65, 52], [51, 44], [60, 35], [41, 9], [59, 75], [57, 73], [58, 28], [65, 23], [36, 48], [26, 40], [39, 41], [58, 3], [40, 42], [58, 49], [28, 42], [33, 36], [44, 24], [2, 68], [30, 57], [10, 51], [3, 68], [26, 42], [51, 13], [12, 69], [19, 60], [58, 39], [1, 45], [66, 16], [41, 27], [56, 1], [28, 18], [66, 29], [37, 49], [59, 4], [29, 67], [38, 29], [54, 57], [47, 61], [68, 29], [38, 9], [51, 41], [41, 10], [19, 61], [3, 22], [72, 23], [18, 11], [27, 17], [72, 74], [5, 37], [66, 68], [2, 3], [60, 27], [68, 72], [64, 20], [67, 18], [6, 66], [24, 60], [14, 75], [9, 11], [71, 50], [66, 43], [6, 60], [54, 22], [71, 53], [51, 7], [49, 40], [7, 74], [72, 30], [20, 71], [28, 74], [36, 55], [16, 17], [66, 2], [53, 8], [18, 2], [62, 63], [63, 26], [19, 34], [26, 27], [67, 51], [61, 46], [37, 29], [66, 41], [51, 54], [3, 17], [35, 6], [50, 51], [8, 15], [15, 55], [10, 65], [57, 59], [69, 21], [73, 70], [21, 30], [28, 28], [67, 59], [39, 76], [56, 12], [22, 69], [76, 7], [63, 66], [9, 40], [64, 28], [65, 31], [6, 59], [73, 73], [24, 29], [44, 18], [67, 1], [16, 12], [73, 2], [74, 27], [25, 58], [18, 52], [12, 66], [32, 25], [26, 4], [34, 27], [51, 39], [23, 11], [13, 65], [18, 28], [19, 6], [68, 59], [51, 72], [59, 74], [59, 3], [41, 29], [36, 6], [49, 37], [71, 39], [33, 13], [38, 68], [34, 19], [64, 36], [4, 29], [72, 60], [52, 41], [36, 66], [34, 70], [22, 32], [67, 40], [3, 73], [19, 12], [17, 0], [22, 8], [42, 35], [34, 54], [71, 29], [6, 7], [10, 43], [8, 56], [2, 58], [72, 2], [67, 65], [1, 23], [13, 21], [62, 38], [2, 66], [42, 62], [38, 27], [1, 22], [16, 29], [39, 54], [41, 0], [42, 54], [50, 58], [62, 45], [59, 76], [40, 44], [72, 18], [45, 40], [31, 3], [13, 45], [38, 64], [1, 21], [10, 32], [35, 12], [32, 6], [62, 75], [52, 59], [1, 42], [72, 31], [55, 17], [18, 50], [43, 29], [48, 37], [73, 16], [43, 68], [47, 12], [55, 46], [41, 30], [69, 32], [55, 14], [74, 61], [55, 72], [75, 24], [63, 40], [10, 58], [67, 73], [20, 11], [42, 40], [27, 53], [5, 8], [10, 2], [27, 49], [50, 48], [18, 58], [60, 25], [74, 71], [0, 30], [3, 29], [59, 5], [43, 16], [59, 41], [74, 4], [19, 20], [53, 19], [57, 50], [60, 11], [16, 68], [9, 50], [71, 17], [73, 66], [59, 43], [68, 32], [75, 31], [27, 56], [47, 24], [29, 7], [27, 25], [48, 36], [0, 53], [0, 72], [24, 53], [13, 64], [19, 44], [9, 56], [35, 75], [75, 17], [47, 16], [11, 42], [40, 45], [43, 60], [21, 59], [29, 50], [8, 9], [3, 18], [7, 57], [32, 9], [61, 6], [11, 6], [7, 72], [42, 61], [73, 75], [68, 44], [68, 66], [25, 56], [14, 20], [3, 50], [32, 57], [67, 58], [41, 68], [19, 26], [30, 3], [23, 45], [16, 60], [41, 43], [5, 30], [5, 25], [72, 16], [16, 73], [21, 17], [16, 59], [8, 34], [4, 39], [23, 72], [35, 53], [31, 50], [20, 44], [50, 13], [72, 1], [8, 8], [74, 54], [1, 1], [16, 43], [39, 36], [51, 2], [23, 54], [66, 58], [60, 33], [2, 63], [73, 10]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True", "target": ""}
{"module": "graphs.py", "name": "PlantedClique:3", "notes": "Find a [planted clique](https://en.wikipedia.org/w/index.php?title=Planted_clique) of a given size\nin an undirected graph. Finding a polynomial-time algorithm for this problem has been *unsolved* for\nsome time.", "sol_bodies": [], "sol_header": "def sol(edges=[[34, 43], [45, 8], [7, 46], [53, 11], [48, 24], [47, 46], [20, 46], [11, 57], [39, 17], [25, 13], [9, 49], [47, 51], [5, 22], [56, 8], [5, 20], [11, 26], [40, 20], [30, 42], [46, 35], [41, 11], [49, 57], [24, 46], [40, 27], [3, 13], [25, 36], [20, 49], [57, 24], [56, 26], [1, 52], [8, 26], [17, 44], [1, 21], [5, 6], [45, 45], [39, 25], [48, 27], [26, 17], [37, 25], [17, 16], [49, 0], [17, 56], [33, 43], [20, 43], [24, 20], [31, 56], [54, 28], [25, 27], [50, 5], [21, 43], [54, 25], [57, 45], [48, 5], [45, 34], [18, 46], [25, 47], [56, 48], [17, 57], [15, 29], [40, 22], [23, 57], [17, 27], [1, 14], [7, 54], [15, 24], [27, 44], [24, 44], [6, 7], [59, 13], [56, 51], [49, 46], [1, 32], [20, 36], [46, 13], [15, 46], [6, 46], [59, 51], [35, 5], [27, 10], [3, 16], [24, 33], [34, 49], [4, 38], [46, 24], [46, 3], [41, 39], [12, 9], [44, 39], [27, 23], [33, 11], [16, 24], [29, 59], [47, 39], [32, 10], [23, 36], [48, 30], [48, 20], [18, 43], [36, 9], [36, 16], [27, 57], [29, 35], [13, 41], [52, 12], [32, 20], [9, 50], [29, 27], [47, 44], [57, 39], [48, 57], [35, 45], [9, 23], [25, 55], [32, 25], [5, 57], [44, 16], [5, 27], [16, 37], [15, 25], [39, 51], [43, 14], [13, 44], [2, 5], [40, 4], [58, 30], [43, 6], [25, 28], [16, 35], [57, 44], [51, 54], [21, 11], [18, 19], [41, 20], [44, 48], [14, 54], [57, 16], [15, 5], [37, 15], [44, 49], [15, 20], [11, 20], [45, 1], [3, 32], [7, 22], [48, 39], [28, 37], [11, 51], [20, 16], [32, 4], [13, 17], [16, 15], [20, 37], [37, 46], [33, 59], [46, 25], [42, 1], [32, 33], [13, 53], [46, 18], [44, 23], [17, 48], [5, 24], [10, 40], [19, 11], [37, 47], [11, 42], [13, 24], [13, 27], [42, 9], [13, 5], [29, 17], [57, 4], [31, 25], [38, 32], [21, 45], [0, 21], [1, 0], [20, 13], [24, 37], [20, 25], [5, 17], [20, 47], [46, 41], [11, 0], [25, 22], [5, 28], [44, 5], [10, 11], [41, 22], [17, 25], [25, 20], [20, 17], [39, 46], [49, 25], [41, 0], [12, 44], [41, 49], [55, 8], [47, 49], [27, 49], [2, 11], [38, 11], [27, 46], [16, 9], [41, 47], [17, 15], [37, 31], [48, 48], [53, 59], [25, 24], [3, 44], [34, 48], [33, 13], [15, 47], [16, 39], [48, 8], [32, 55], [38, 22], [11, 23], [41, 16], [21, 44], [20, 27], [13, 57], [27, 41], [29, 32], [56, 39], [31, 51], [46, 20], [24, 49], [25, 3], [57, 37], [15, 44], [9, 41], [15, 48], [42, 57], [47, 5], [48, 37], [45, 49], [44, 41], [7, 3], [39, 49], [49, 37], [24, 16], [57, 41], [56, 2], [49, 20], [19, 5], [58, 18], [7, 31], [24, 5], [41, 32], [34, 23], [17, 5], [47, 27], [49, 41], [31, 12], [0, 11], [49, 15], [13, 15], [29, 31], [14, 56], [24, 41], [35, 1], [16, 25], [26, 28], [16, 49], [12, 46], [47, 16], [17, 37], [37, 39], [3, 22], [27, 24], [20, 39], [24, 4], [33, 15], [53, 50], [32, 1], [23, 40], [33, 25], [4, 24], [48, 25], [47, 57], [25, 8], [39, 30], [17, 53], [41, 53], [31, 8], [39, 33], [33, 16], [32, 19], [41, 5], [49, 17], [53, 40], [42, 52], [24, 17], [30, 59], [13, 14], [43, 27], [48, 16], [24, 47], [37, 23], [30, 47], [49, 10], [47, 12], [5, 37], [48, 47], [59, 27], [57, 17], [27, 33], [12, 30], [41, 48], [5, 46], [12, 25], [53, 46], [54, 8], [48, 1], [22, 25], [20, 44], [14, 38], [48, 13], [3, 3], [59, 4], [14, 7], [49, 26], [36, 5], [28, 32], [57, 46], [22, 34], [11, 54], [27, 58], [4, 11], [24, 39], [57, 25], [15, 27], [6, 15], [27, 29], [51, 37], [48, 23], [15, 57], [27, 25], [0, 57], [49, 48], [27, 34], [21, 5], [31, 40], [38, 45], [15, 1], [17, 42], [5, 16], [59, 32], [13, 51], [17, 47], [38, 54], [4, 43], [54, 9], [42, 31], [16, 13], [20, 57], [58, 10], [41, 30], [52, 19], [52, 35], [46, 44], [51, 4], [30, 39], [47, 13], [30, 32], [36, 42], [39, 15], [3, 19], [12, 16], [46, 16], [12, 37], [46, 48], [58, 46], [5, 25], [46, 6], [49, 44], [18, 23], [50, 24], [16, 16], [49, 53], [37, 33], [4, 15], [46, 17], [7, 20], [25, 41], [27, 56], [37, 41], [38, 55], [59, 28], [31, 7], [10, 47], [40, 23], [49, 5], [44, 25], [8, 36], [26, 39], [34, 3], [5, 12], [54, 22], [15, 41], [40, 19], [21, 12], [16, 5], [13, 49], [39, 5], [9, 9], [11, 53], [27, 16], [27, 39], [52, 14], [3, 56], [27, 37], [30, 15], [41, 17], [1, 34], [55, 32], [28, 22], [49, 27], [10, 55], [39, 37], [30, 17], [23, 9], [22, 11], [44, 37], [41, 37], [37, 13], [51, 18], [4, 34], [23, 12], [39, 13], [32, 9], [58, 14], [25, 48], [29, 14], [52, 2]], size=18):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"", "weight": 1.0, "sat": "def sat(nodes: List[int], size=18, edges=[[34, 43], [45, 8], [7, 46], [53, 11], [48, 24], [47, 46], [20, 46], [11, 57], [39, 17], [25, 13], [9, 49], [47, 51], [5, 22], [56, 8], [5, 20], [11, 26], [40, 20], [30, 42], [46, 35], [41, 11], [49, 57], [24, 46], [40, 27], [3, 13], [25, 36], [20, 49], [57, 24], [56, 26], [1, 52], [8, 26], [17, 44], [1, 21], [5, 6], [45, 45], [39, 25], [48, 27], [26, 17], [37, 25], [17, 16], [49, 0], [17, 56], [33, 43], [20, 43], [24, 20], [31, 56], [54, 28], [25, 27], [50, 5], [21, 43], [54, 25], [57, 45], [48, 5], [45, 34], [18, 46], [25, 47], [56, 48], [17, 57], [15, 29], [40, 22], [23, 57], [17, 27], [1, 14], [7, 54], [15, 24], [27, 44], [24, 44], [6, 7], [59, 13], [56, 51], [49, 46], [1, 32], [20, 36], [46, 13], [15, 46], [6, 46], [59, 51], [35, 5], [27, 10], [3, 16], [24, 33], [34, 49], [4, 38], [46, 24], [46, 3], [41, 39], [12, 9], [44, 39], [27, 23], [33, 11], [16, 24], [29, 59], [47, 39], [32, 10], [23, 36], [48, 30], [48, 20], [18, 43], [36, 9], [36, 16], [27, 57], [29, 35], [13, 41], [52, 12], [32, 20], [9, 50], [29, 27], [47, 44], [57, 39], [48, 57], [35, 45], [9, 23], [25, 55], [32, 25], [5, 57], [44, 16], [5, 27], [16, 37], [15, 25], [39, 51], [43, 14], [13, 44], [2, 5], [40, 4], [58, 30], [43, 6], [25, 28], [16, 35], [57, 44], [51, 54], [21, 11], [18, 19], [41, 20], [44, 48], [14, 54], [57, 16], [15, 5], [37, 15], [44, 49], [15, 20], [11, 20], [45, 1], [3, 32], [7, 22], [48, 39], [28, 37], [11, 51], [20, 16], [32, 4], [13, 17], [16, 15], [20, 37], [37, 46], [33, 59], [46, 25], [42, 1], [32, 33], [13, 53], [46, 18], [44, 23], [17, 48], [5, 24], [10, 40], [19, 11], [37, 47], [11, 42], [13, 24], [13, 27], [42, 9], [13, 5], [29, 17], [57, 4], [31, 25], [38, 32], [21, 45], [0, 21], [1, 0], [20, 13], [24, 37], [20, 25], [5, 17], [20, 47], [46, 41], [11, 0], [25, 22], [5, 28], [44, 5], [10, 11], [41, 22], [17, 25], [25, 20], [20, 17], [39, 46], [49, 25], [41, 0], [12, 44], [41, 49], [55, 8], [47, 49], [27, 49], [2, 11], [38, 11], [27, 46], [16, 9], [41, 47], [17, 15], [37, 31], [48, 48], [53, 59], [25, 24], [3, 44], [34, 48], [33, 13], [15, 47], [16, 39], [48, 8], [32, 55], [38, 22], [11, 23], [41, 16], [21, 44], [20, 27], [13, 57], [27, 41], [29, 32], [56, 39], [31, 51], [46, 20], [24, 49], [25, 3], [57, 37], [15, 44], [9, 41], [15, 48], [42, 57], [47, 5], [48, 37], [45, 49], [44, 41], [7, 3], [39, 49], [49, 37], [24, 16], [57, 41], [56, 2], [49, 20], [19, 5], [58, 18], [7, 31], [24, 5], [41, 32], [34, 23], [17, 5], [47, 27], [49, 41], [31, 12], [0, 11], [49, 15], [13, 15], [29, 31], [14, 56], [24, 41], [35, 1], [16, 25], [26, 28], [16, 49], [12, 46], [47, 16], [17, 37], [37, 39], [3, 22], [27, 24], [20, 39], [24, 4], [33, 15], [53, 50], [32, 1], [23, 40], [33, 25], [4, 24], [48, 25], [47, 57], [25, 8], [39, 30], [17, 53], [41, 53], [31, 8], [39, 33], [33, 16], [32, 19], [41, 5], [49, 17], [53, 40], [42, 52], [24, 17], [30, 59], [13, 14], [43, 27], [48, 16], [24, 47], [37, 23], [30, 47], [49, 10], [47, 12], [5, 37], [48, 47], [59, 27], [57, 17], [27, 33], [12, 30], [41, 48], [5, 46], [12, 25], [53, 46], [54, 8], [48, 1], [22, 25], [20, 44], [14, 38], [48, 13], [3, 3], [59, 4], [14, 7], [49, 26], [36, 5], [28, 32], [57, 46], [22, 34], [11, 54], [27, 58], [4, 11], [24, 39], [57, 25], [15, 27], [6, 15], [27, 29], [51, 37], [48, 23], [15, 57], [27, 25], [0, 57], [49, 48], [27, 34], [21, 5], [31, 40], [38, 45], [15, 1], [17, 42], [5, 16], [59, 32], [13, 51], [17, 47], [38, 54], [4, 43], [54, 9], [42, 31], [16, 13], [20, 57], [58, 10], [41, 30], [52, 19], [52, 35], [46, 44], [51, 4], [30, 39], [47, 13], [30, 32], [36, 42], [39, 15], [3, 19], [12, 16], [46, 16], [12, 37], [46, 48], [58, 46], [5, 25], [46, 6], [49, 44], [18, 23], [50, 24], [16, 16], [49, 53], [37, 33], [4, 15], [46, 17], [7, 20], [25, 41], [27, 56], [37, 41], [38, 55], [59, 28], [31, 7], [10, 47], [40, 23], [49, 5], [44, 25], [8, 36], [26, 39], [34, 3], [5, 12], [54, 22], [15, 41], [40, 19], [21, 12], [16, 5], [13, 49], [39, 5], [9, 9], [11, 53], [27, 16], [27, 39], [52, 14], [3, 56], [27, 37], [30, 15], [41, 17], [1, 34], [55, 32], [28, 22], [49, 27], [10, 55], [39, 37], [30, 17], [23, 9], [22, 11], [44, 37], [41, 37], [37, 13], [51, 18], [4, 34], [23, 12], [39, 13], [32, 9], [58, 14], [25, 48], [29, 14], [52, 2]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True", "input": "def sat(nodes: List[int], size=18, edges=[[34, 43], [45, 8], [7, 46], [53, 11], [48, 24], [47, 46], [20, 46], [11, 57], [39, 17], [25, 13], [9, 49], [47, 51], [5, 22], [56, 8], [5, 20], [11, 26], [40, 20], [30, 42], [46, 35], [41, 11], [49, 57], [24, 46], [40, 27], [3, 13], [25, 36], [20, 49], [57, 24], [56, 26], [1, 52], [8, 26], [17, 44], [1, 21], [5, 6], [45, 45], [39, 25], [48, 27], [26, 17], [37, 25], [17, 16], [49, 0], [17, 56], [33, 43], [20, 43], [24, 20], [31, 56], [54, 28], [25, 27], [50, 5], [21, 43], [54, 25], [57, 45], [48, 5], [45, 34], [18, 46], [25, 47], [56, 48], [17, 57], [15, 29], [40, 22], [23, 57], [17, 27], [1, 14], [7, 54], [15, 24], [27, 44], [24, 44], [6, 7], [59, 13], [56, 51], [49, 46], [1, 32], [20, 36], [46, 13], [15, 46], [6, 46], [59, 51], [35, 5], [27, 10], [3, 16], [24, 33], [34, 49], [4, 38], [46, 24], [46, 3], [41, 39], [12, 9], [44, 39], [27, 23], [33, 11], [16, 24], [29, 59], [47, 39], [32, 10], [23, 36], [48, 30], [48, 20], [18, 43], [36, 9], [36, 16], [27, 57], [29, 35], [13, 41], [52, 12], [32, 20], [9, 50], [29, 27], [47, 44], [57, 39], [48, 57], [35, 45], [9, 23], [25, 55], [32, 25], [5, 57], [44, 16], [5, 27], [16, 37], [15, 25], [39, 51], [43, 14], [13, 44], [2, 5], [40, 4], [58, 30], [43, 6], [25, 28], [16, 35], [57, 44], [51, 54], [21, 11], [18, 19], [41, 20], [44, 48], [14, 54], [57, 16], [15, 5], [37, 15], [44, 49], [15, 20], [11, 20], [45, 1], [3, 32], [7, 22], [48, 39], [28, 37], [11, 51], [20, 16], [32, 4], [13, 17], [16, 15], [20, 37], [37, 46], [33, 59], [46, 25], [42, 1], [32, 33], [13, 53], [46, 18], [44, 23], [17, 48], [5, 24], [10, 40], [19, 11], [37, 47], [11, 42], [13, 24], [13, 27], [42, 9], [13, 5], [29, 17], [57, 4], [31, 25], [38, 32], [21, 45], [0, 21], [1, 0], [20, 13], [24, 37], [20, 25], [5, 17], [20, 47], [46, 41], [11, 0], [25, 22], [5, 28], [44, 5], [10, 11], [41, 22], [17, 25], [25, 20], [20, 17], [39, 46], [49, 25], [41, 0], [12, 44], [41, 49], [55, 8], [47, 49], [27, 49], [2, 11], [38, 11], [27, 46], [16, 9], [41, 47], [17, 15], [37, 31], [48, 48], [53, 59], [25, 24], [3, 44], [34, 48], [33, 13], [15, 47], [16, 39], [48, 8], [32, 55], [38, 22], [11, 23], [41, 16], [21, 44], [20, 27], [13, 57], [27, 41], [29, 32], [56, 39], [31, 51], [46, 20], [24, 49], [25, 3], [57, 37], [15, 44], [9, 41], [15, 48], [42, 57], [47, 5], [48, 37], [45, 49], [44, 41], [7, 3], [39, 49], [49, 37], [24, 16], [57, 41], [56, 2], [49, 20], [19, 5], [58, 18], [7, 31], [24, 5], [41, 32], [34, 23], [17, 5], [47, 27], [49, 41], [31, 12], [0, 11], [49, 15], [13, 15], [29, 31], [14, 56], [24, 41], [35, 1], [16, 25], [26, 28], [16, 49], [12, 46], [47, 16], [17, 37], [37, 39], [3, 22], [27, 24], [20, 39], [24, 4], [33, 15], [53, 50], [32, 1], [23, 40], [33, 25], [4, 24], [48, 25], [47, 57], [25, 8], [39, 30], [17, 53], [41, 53], [31, 8], [39, 33], [33, 16], [32, 19], [41, 5], [49, 17], [53, 40], [42, 52], [24, 17], [30, 59], [13, 14], [43, 27], [48, 16], [24, 47], [37, 23], [30, 47], [49, 10], [47, 12], [5, 37], [48, 47], [59, 27], [57, 17], [27, 33], [12, 30], [41, 48], [5, 46], [12, 25], [53, 46], [54, 8], [48, 1], [22, 25], [20, 44], [14, 38], [48, 13], [3, 3], [59, 4], [14, 7], [49, 26], [36, 5], [28, 32], [57, 46], [22, 34], [11, 54], [27, 58], [4, 11], [24, 39], [57, 25], [15, 27], [6, 15], [27, 29], [51, 37], [48, 23], [15, 57], [27, 25], [0, 57], [49, 48], [27, 34], [21, 5], [31, 40], [38, 45], [15, 1], [17, 42], [5, 16], [59, 32], [13, 51], [17, 47], [38, 54], [4, 43], [54, 9], [42, 31], [16, 13], [20, 57], [58, 10], [41, 30], [52, 19], [52, 35], [46, 44], [51, 4], [30, 39], [47, 13], [30, 32], [36, 42], [39, 15], [3, 19], [12, 16], [46, 16], [12, 37], [46, 48], [58, 46], [5, 25], [46, 6], [49, 44], [18, 23], [50, 24], [16, 16], [49, 53], [37, 33], [4, 15], [46, 17], [7, 20], [25, 41], [27, 56], [37, 41], [38, 55], [59, 28], [31, 7], [10, 47], [40, 23], [49, 5], [44, 25], [8, 36], [26, 39], [34, 3], [5, 12], [54, 22], [15, 41], [40, 19], [21, 12], [16, 5], [13, 49], [39, 5], [9, 9], [11, 53], [27, 16], [27, 39], [52, 14], [3, 56], [27, 37], [30, 15], [41, 17], [1, 34], [55, 32], [28, 22], [49, 27], [10, 55], [39, 37], [30, 17], [23, 9], [22, 11], [44, 37], [41, 37], [37, 13], [51, 18], [4, 34], [23, 12], [39, 13], [32, 9], [58, 14], [25, 48], [29, 14], [52, 2]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True", "target": ""}
{"module": "graphs.py", "name": "PlantedClique:4", "notes": "Find a [planted clique](https://en.wikipedia.org/w/index.php?title=Planted_clique) of a given size\nin an undirected graph. Finding a polynomial-time algorithm for this problem has been *unsolved* for\nsome time.", "sol_bodies": ["    # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""], "sol_header": "def sol(edges=[[0, 1], [1, 0]], size=0):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"", "weight": 1.0, "sat": "def sat(nodes: List[int], size=0, edges=[[0, 1], [1, 0]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True", "input": "def sat(nodes: List[int], size=0, edges=[[0, 1], [1, 0]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True", "target": ""}
{"module": "graphs.py", "name": "Zarankiewicz:0", "notes": "[Zarankiewicz problem](https://en.wikipedia.org/wiki/Zarankiewicz_problem)", "sol_bodies": ["    from itertools import combinations\n    all_edges = [(a, b) for a in range(n) for b in range(n)]\n    for edges in combinations(all_edges, z):\n        edge_set = set(edges)\n        if all(any((a, b) not in edge_set for a in left for b in right)\n               for left in combinations(range(n), t)\n               for right in combinations(range(n), t)):\n            return [[a, b] for a, b in edges]"], "sol_header": "def sol(z=20, n=5, t=3):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find a bipartite graph with n vertices on each side, z edges, and no K_3,3 subgraph.\"\"\"", "weight": 1.0, "sat": "def sat(edges: List[List[int]], z=20, n=5, t=3):\n    from itertools import combinations\n    edges = {(a, b) for a, b in edges if a in range(n) and b in range(n)}  # convert to a set for efficiency\n    assert len(edges) >= z\n\n    return all(\n        any((a, b) not in edges for a in left for b in right)\n        for left in combinations(range(n), t)\n        for right in combinations(range(n), t)\n    )", "input": "def sat(edges: List[List[int]], z=20, n=5, t=3):\n    from itertools import combinations\n    edges = {(a, b) for a, b in edges if a in range(n) and b in range(n)}  # convert to a set for efficiency\n    assert len(edges) >= z\n\n    return all(\n        any((a, b) not in edges for a in left for b in right)\n        for left in combinations(range(n), t)\n        for right in combinations(range(n), t)\n    )", "target": ""}
{"module": "graphs.py", "name": "Zarankiewicz:1", "notes": "[Zarankiewicz problem](https://en.wikipedia.org/wiki/Zarankiewicz_problem)", "sol_bodies": [], "sol_header": "def sol(z=26, n=6, t=3):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find a bipartite graph with n vertices on each side, z edges, and no K_3,3 subgraph.\"\"\"", "weight": 1.0, "sat": "def sat(edges: List[List[int]], z=26, n=6, t=3):\n    from itertools import combinations\n    edges = {(a, b) for a, b in edges if a in range(n) and b in range(n)}  # convert to a set for efficiency\n    assert len(edges) >= z\n\n    return all(\n        any((a, b) not in edges for a in left for b in right)\n        for left in combinations(range(n), t)\n        for right in combinations(range(n), t)\n    )", "input": "def sat(edges: List[List[int]], z=26, n=6, t=3):\n    from itertools import combinations\n    edges = {(a, b) for a, b in edges if a in range(n) and b in range(n)}  # convert to a set for efficiency\n    assert len(edges) >= z\n\n    return all(\n        any((a, b) not in edges for a in left for b in right)\n        for left in combinations(range(n), t)\n        for right in combinations(range(n), t)\n    )", "target": ""}
{"module": "graphs.py", "name": "Zarankiewicz:2", "notes": "[Zarankiewicz problem](https://en.wikipedia.org/wiki/Zarankiewicz_problem)", "sol_bodies": ["    from itertools import combinations\n    all_edges = [(a, b) for a in range(n) for b in range(n)]\n    for edges in combinations(all_edges, z):\n        edge_set = set(edges)\n        if all(any((a, b) not in edge_set for a in left for b in right)\n               for left in combinations(range(n), t)\n               for right in combinations(range(n), t)):\n            return [[a, b] for a, b in edges]"], "sol_header": "def sol(z=13, n=4, t=3):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"Find a bipartite graph with n vertices on each side, z edges, and no K_3,3 subgraph.\"\"\"", "weight": 1.0, "sat": "def sat(edges: List[List[int]], z=13, n=4, t=3):\n    from itertools import combinations\n    edges = {(a, b) for a, b in edges if a in range(n) and b in range(n)}  # convert to a set for efficiency\n    assert len(edges) >= z\n\n    return all(\n        any((a, b) not in edges for a in left for b in right)\n        for left in combinations(range(n), t)\n        for right in combinations(range(n), t)\n    )", "input": "def sat(edges: List[List[int]], z=13, n=4, t=3):\n    from itertools import combinations\n    edges = {(a, b) for a, b in edges if a in range(n) and b in range(n)}  # convert to a set for efficiency\n    assert len(edges) >= z\n\n    return all(\n        any((a, b) not in edges for a in left for b in right)\n        for left in combinations(range(n), t)\n        for right in combinations(range(n), t)\n    )", "target": ""}
{"module": "graphs.py", "name": "ShortIntegerPath:0", "notes": "This is a more interesting version of Study_20 with an additional length constraint. One can think of the graph\ndefined by the integer pairs.", "sol_bodies": ["    return [1, 3, 4, 12, 13, 14, 42, 126, 127]"], "sol_header": "def sol():", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    Find a list of nine integers, starting with 0 and ending with 128, such that each integer either differs from\n    the previous one by one or is thrice the previous one.\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int]):\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128])) and len(li) == 9", "input": "def sat(li: List[int]):\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128])) and len(li) == 9", "target": ""}
{"module": "ICPC.py", "name": "BiPermutations:0", "notes": "Inspired by\n[ICPC 2019 Problem A: Azulejos](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 2,287 characters.", "sol_bodies": ["    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"], "sol_header": "def sol(prices0=[7, 7, 9, 5, 3, 7, 1, 2], prices1=[5, 5, 5, 4, 2, 5, 1, 1], heights0=[2, 4, 9, 3, 8, 5, 5, 4], heights1=[1, 3, 8, 1, 5, 4, 4, 2]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"", "weight": 1.0, "sat": "def sat(perms: List[List[int]], prices0=[7, 7, 9, 5, 3, 7, 1, 2], prices1=[5, 5, 5, 4, 2, 5, 1, 1], heights0=[2, 4, 9, 3, 8, 5, 5, 4], heights1=[1, 3, 8, 1, 5, 4, 4, 2]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))", "input": "def sat(perms: List[List[int]], prices0=[7, 7, 9, 5, 3, 7, 1, 2], prices1=[5, 5, 5, 4, 2, 5, 1, 1], heights0=[2, 4, 9, 3, 8, 5, 5, 4], heights1=[1, 3, 8, 1, 5, 4, 4, 2]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))", "target": ""}
{"module": "ICPC.py", "name": "BiPermutations:1", "notes": "Inspired by\n[ICPC 2019 Problem A: Azulejos](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 2,287 characters.", "sol_bodies": ["    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"], "sol_header": "def sol(prices0=[0, 0, 0, 0, 0], heights0=[12, 5, 8, 13, 7], prices1=[0, 0, 0, 0, 0], heights1=[2, 10, 4, 5, 9]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"", "weight": 1.0, "sat": "def sat(perms: List[List[int]], prices0=[0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0], heights0=[12, 5, 8, 13, 7], heights1=[2, 10, 4, 5, 9]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))", "input": "def sat(perms: List[List[int]], prices0=[0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0], heights0=[12, 5, 8, 13, 7], heights1=[2, 10, 4, 5, 9]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))", "target": ""}
{"module": "ICPC.py", "name": "BiPermutations:2", "notes": "Inspired by\n[ICPC 2019 Problem A: Azulejos](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 2,287 characters.", "sol_bodies": ["    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"], "sol_header": "def sol(prices0=[0, 0, 0, 0, 0], heights0=[9, 10, 12, 14, 14], prices1=[0, 0, 0, 0, 0], heights1=[6, 5, 7, 10, 10]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"", "weight": 1.0, "sat": "def sat(perms: List[List[int]], prices0=[0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0], heights0=[9, 10, 12, 14, 14], heights1=[6, 5, 7, 10, 10]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))", "input": "def sat(perms: List[List[int]], prices0=[0, 0, 0, 0, 0], prices1=[0, 0, 0, 0, 0], heights0=[9, 10, 12, 14, 14], heights1=[6, 5, 7, 10, 10]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))", "target": ""}
{"module": "ICPC.py", "name": "BiPermutations:3", "notes": "Inspired by\n[ICPC 2019 Problem A: Azulejos](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 2,287 characters.", "sol_bodies": ["    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"], "sol_header": "def sol(prices0=[2, 5, 4, 2, 7, 3, 4, 5, 2, 3, 2, 1, 2, 7, 6, 1, 5, 2, 4, 6, 3, 7, 1, 2, 3, 5, 2, 2, 2, 2, 6, 5, 0, 2, 2, 0, 7, 3, 6, 4, 7, 0, 1, 5, 6, 1, 7, 6, 5, 4, 7, 7, 2, 5, 4, 5, 1, 4, 3, 3, 0, 2, 4, 0, 3, 0, 6, 4, 2, 6, 7, 5, 0, 5, 6, 2], heights0=[5, 4, 8, 9, 9, 11, 13, 6, 6, 6, 9, 13, 15, 8, 7, 14, 6, 5, 12, 7, 14, 9, 6, 13, 3, 10, 11, 8, 4, 14, 10, 10, 4, 8, 3, 7, 11, 8, 5, 5, 10, 11, 9, 9, 7, 11, 3, 13, 15, 5, 3, 7, 8, 10, 8, 13, 12, 3, 4, 13, 7, 7, 5, 5, 6, 10, 8, 11, 7, 5, 10, 15, 4, 15, 6, 8], prices1=[4, 5, 2, 5, 7, 0, 6, 6, 4, 5, 5, 6, 6, 2, 5, 4, 6, 0, 3, 3, 4, 5, 7, 7, 3, 3, 2, 5, 1, 7, 5, 6, 6, 3, 1, 4, 5, 0, 6, 7, 3, 7, 1, 5, 7, 4, 1, 0, 3, 6, 0, 1, 3, 3, 3, 5, 0, 4, 7, 3, 3, 2, 2, 3, 7, 7, 1, 1, 2, 2, 2, 5, 4, 7, 3, 0], heights1=[5, 9, 4, 4, 8, 7, 10, 1, 2, 5, 5, 3, 4, 1, 10, 1, 5, 3, 3, 5, 4, 8, 3, 9, 10, 5, 6, 9, 10, 2, 10, 4, 6, 10, 4, 3, 2, 4, 9, 2, 7, 8, 7, 7, 9, 10, 9, 1, 7, 6, 2, 4, 2, 10, 6, 6, 10, 2, 5, 3, 10, 5, 10, 4, 6, 2, 8, 5, 3, 10, 1, 8, 6, 2, 2, 2]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"", "weight": 1.0, "sat": "def sat(perms: List[List[int]], prices0=[2, 5, 4, 2, 7, 3, 4, 5, 2, 3, 2, 1, 2, 7, 6, 1, 5, 2, 4, 6, 3, 7, 1, 2, 3, 5, 2, 2, 2, 2, 6, 5, 0, 2, 2, 0, 7, 3, 6, 4, 7, 0, 1, 5, 6, 1, 7, 6, 5, 4, 7, 7, 2, 5, 4, 5, 1, 4, 3, 3, 0, 2, 4, 0, 3, 0, 6, 4, 2, 6, 7, 5, 0, 5, 6, 2], prices1=[4, 5, 2, 5, 7, 0, 6, 6, 4, 5, 5, 6, 6, 2, 5, 4, 6, 0, 3, 3, 4, 5, 7, 7, 3, 3, 2, 5, 1, 7, 5, 6, 6, 3, 1, 4, 5, 0, 6, 7, 3, 7, 1, 5, 7, 4, 1, 0, 3, 6, 0, 1, 3, 3, 3, 5, 0, 4, 7, 3, 3, 2, 2, 3, 7, 7, 1, 1, 2, 2, 2, 5, 4, 7, 3, 0], heights0=[5, 4, 8, 9, 9, 11, 13, 6, 6, 6, 9, 13, 15, 8, 7, 14, 6, 5, 12, 7, 14, 9, 6, 13, 3, 10, 11, 8, 4, 14, 10, 10, 4, 8, 3, 7, 11, 8, 5, 5, 10, 11, 9, 9, 7, 11, 3, 13, 15, 5, 3, 7, 8, 10, 8, 13, 12, 3, 4, 13, 7, 7, 5, 5, 6, 10, 8, 11, 7, 5, 10, 15, 4, 15, 6, 8], heights1=[5, 9, 4, 4, 8, 7, 10, 1, 2, 5, 5, 3, 4, 1, 10, 1, 5, 3, 3, 5, 4, 8, 3, 9, 10, 5, 6, 9, 10, 2, 10, 4, 6, 10, 4, 3, 2, 4, 9, 2, 7, 8, 7, 7, 9, 10, 9, 1, 7, 6, 2, 4, 2, 10, 6, 6, 10, 2, 5, 3, 10, 5, 10, 4, 6, 2, 8, 5, 3, 10, 1, 8, 6, 2, 2, 2]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))", "input": "def sat(perms: List[List[int]], prices0=[2, 5, 4, 2, 7, 3, 4, 5, 2, 3, 2, 1, 2, 7, 6, 1, 5, 2, 4, 6, 3, 7, 1, 2, 3, 5, 2, 2, 2, 2, 6, 5, 0, 2, 2, 0, 7, 3, 6, 4, 7, 0, 1, 5, 6, 1, 7, 6, 5, 4, 7, 7, 2, 5, 4, 5, 1, 4, 3, 3, 0, 2, 4, 0, 3, 0, 6, 4, 2, 6, 7, 5, 0, 5, 6, 2], prices1=[4, 5, 2, 5, 7, 0, 6, 6, 4, 5, 5, 6, 6, 2, 5, 4, 6, 0, 3, 3, 4, 5, 7, 7, 3, 3, 2, 5, 1, 7, 5, 6, 6, 3, 1, 4, 5, 0, 6, 7, 3, 7, 1, 5, 7, 4, 1, 0, 3, 6, 0, 1, 3, 3, 3, 5, 0, 4, 7, 3, 3, 2, 2, 3, 7, 7, 1, 1, 2, 2, 2, 5, 4, 7, 3, 0], heights0=[5, 4, 8, 9, 9, 11, 13, 6, 6, 6, 9, 13, 15, 8, 7, 14, 6, 5, 12, 7, 14, 9, 6, 13, 3, 10, 11, 8, 4, 14, 10, 10, 4, 8, 3, 7, 11, 8, 5, 5, 10, 11, 9, 9, 7, 11, 3, 13, 15, 5, 3, 7, 8, 10, 8, 13, 12, 3, 4, 13, 7, 7, 5, 5, 6, 10, 8, 11, 7, 5, 10, 15, 4, 15, 6, 8], heights1=[5, 9, 4, 4, 8, 7, 10, 1, 2, 5, 5, 3, 4, 1, 10, 1, 5, 3, 3, 5, 4, 8, 3, 9, 10, 5, 6, 9, 10, 2, 10, 4, 6, 10, 4, 3, 2, 4, 9, 2, 7, 8, 7, 7, 9, 10, 9, 1, 7, 6, 2, 4, 2, 10, 6, 6, 10, 2, 5, 3, 10, 5, 10, 4, 6, 2, 8, 5, 3, 10, 1, 8, 6, 2, 2, 2]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))", "target": ""}
{"module": "ICPC.py", "name": "BiPermutations:4", "notes": "Inspired by\n[ICPC 2019 Problem A: Azulejos](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 2,287 characters.", "sol_bodies": ["    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"], "sol_header": "def sol(prices0=[3, 6, 4, 0, 5, 6, 4, 3, 1, 7, 0, 4, 7, 5, 6, 1, 3, 3, 7, 4, 2, 5, 1, 7, 6, 7, 6, 3, 0, 2, 1, 7, 4, 3, 2, 7, 1, 3, 7, 6, 7, 0, 2, 0, 1, 1, 1, 3, 1, 1, 0, 0, 5, 2, 4, 6, 1, 5, 2, 5, 1, 5, 5, 3, 1, 7, 7, 1, 3, 6, 0, 6, 0, 0, 3, 6, 1], heights0=[12, 13, 8, 14, 12, 10, 15, 4, 13, 8, 7, 4, 8, 4, 7, 13, 7, 11, 6, 7, 11, 14, 11, 13, 10, 10, 5, 9, 12, 5, 11, 12, 12, 6, 4, 11, 5, 3, 4, 6, 3, 4, 3, 15, 4, 13, 8, 10, 10, 10, 14, 6, 10, 7, 6, 4, 6, 12, 8, 11, 7, 9, 7, 12, 6, 8, 6, 7, 8, 5, 13, 6, 10, 13, 5, 7, 10], prices1=[1, 4, 0, 6, 3, 1, 4, 6, 3, 0, 4, 7, 2, 6, 4, 0, 2, 4, 6, 7, 7, 0, 4, 2, 6, 1, 6, 3, 0, 5, 3, 6, 0, 1, 4, 1, 0, 5, 1, 3, 4, 0, 0, 2, 5, 5, 5, 1, 2, 7, 7, 0, 7, 0, 7, 7, 5, 0, 1, 1, 0, 5, 7, 1, 0, 0, 2, 4, 1, 2, 6, 2, 3, 4, 0, 7, 6], heights1=[5, 8, 9, 3, 4, 7, 2, 7, 10, 10, 10, 3, 3, 8, 3, 9, 4, 5, 8, 9, 1, 4, 2, 2, 5, 3, 4, 4, 2, 6, 8, 2, 6, 9, 9, 6, 10, 7, 2, 7, 1, 10, 8, 6, 2, 10, 6, 8, 4, 3, 3, 9, 5, 9, 3, 7, 5, 10, 3, 1, 8, 10, 5, 6, 3, 8, 1, 7, 3, 1, 10, 4, 8, 1, 2, 5, 2]):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"", "weight": 1.0, "sat": "def sat(perms: List[List[int]], prices0=[3, 6, 4, 0, 5, 6, 4, 3, 1, 7, 0, 4, 7, 5, 6, 1, 3, 3, 7, 4, 2, 5, 1, 7, 6, 7, 6, 3, 0, 2, 1, 7, 4, 3, 2, 7, 1, 3, 7, 6, 7, 0, 2, 0, 1, 1, 1, 3, 1, 1, 0, 0, 5, 2, 4, 6, 1, 5, 2, 5, 1, 5, 5, 3, 1, 7, 7, 1, 3, 6, 0, 6, 0, 0, 3, 6, 1], prices1=[1, 4, 0, 6, 3, 1, 4, 6, 3, 0, 4, 7, 2, 6, 4, 0, 2, 4, 6, 7, 7, 0, 4, 2, 6, 1, 6, 3, 0, 5, 3, 6, 0, 1, 4, 1, 0, 5, 1, 3, 4, 0, 0, 2, 5, 5, 5, 1, 2, 7, 7, 0, 7, 0, 7, 7, 5, 0, 1, 1, 0, 5, 7, 1, 0, 0, 2, 4, 1, 2, 6, 2, 3, 4, 0, 7, 6], heights0=[12, 13, 8, 14, 12, 10, 15, 4, 13, 8, 7, 4, 8, 4, 7, 13, 7, 11, 6, 7, 11, 14, 11, 13, 10, 10, 5, 9, 12, 5, 11, 12, 12, 6, 4, 11, 5, 3, 4, 6, 3, 4, 3, 15, 4, 13, 8, 10, 10, 10, 14, 6, 10, 7, 6, 4, 6, 12, 8, 11, 7, 9, 7, 12, 6, 8, 6, 7, 8, 5, 13, 6, 10, 13, 5, 7, 10], heights1=[5, 8, 9, 3, 4, 7, 2, 7, 10, 10, 10, 3, 3, 8, 3, 9, 4, 5, 8, 9, 1, 4, 2, 2, 5, 3, 4, 4, 2, 6, 8, 2, 6, 9, 9, 6, 10, 7, 2, 7, 1, 10, 8, 6, 2, 10, 6, 8, 4, 3, 3, 9, 5, 9, 3, 7, 5, 10, 3, 1, 8, 10, 5, 6, 3, 8, 1, 7, 3, 1, 10, 4, 8, 1, 2, 5, 2]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))", "input": "def sat(perms: List[List[int]], prices0=[3, 6, 4, 0, 5, 6, 4, 3, 1, 7, 0, 4, 7, 5, 6, 1, 3, 3, 7, 4, 2, 5, 1, 7, 6, 7, 6, 3, 0, 2, 1, 7, 4, 3, 2, 7, 1, 3, 7, 6, 7, 0, 2, 0, 1, 1, 1, 3, 1, 1, 0, 0, 5, 2, 4, 6, 1, 5, 2, 5, 1, 5, 5, 3, 1, 7, 7, 1, 3, 6, 0, 6, 0, 0, 3, 6, 1], prices1=[1, 4, 0, 6, 3, 1, 4, 6, 3, 0, 4, 7, 2, 6, 4, 0, 2, 4, 6, 7, 7, 0, 4, 2, 6, 1, 6, 3, 0, 5, 3, 6, 0, 1, 4, 1, 0, 5, 1, 3, 4, 0, 0, 2, 5, 5, 5, 1, 2, 7, 7, 0, 7, 0, 7, 7, 5, 0, 1, 1, 0, 5, 7, 1, 0, 0, 2, 4, 1, 2, 6, 2, 3, 4, 0, 7, 6], heights0=[12, 13, 8, 14, 12, 10, 15, 4, 13, 8, 7, 4, 8, 4, 7, 13, 7, 11, 6, 7, 11, 14, 11, 13, 10, 10, 5, 9, 12, 5, 11, 12, 12, 6, 4, 11, 5, 3, 4, 6, 3, 4, 3, 15, 4, 13, 8, 10, 10, 10, 14, 6, 10, 7, 6, 4, 6, 12, 8, 11, 7, 9, 7, 12, 6, 8, 6, 7, 8, 5, 13, 6, 10, 13, 5, 7, 10], heights1=[5, 8, 9, 3, 4, 7, 2, 7, 10, 10, 10, 3, 3, 8, 3, 9, 4, 5, 8, 9, 1, 4, 2, 2, 5, 3, 4, 4, 2, 6, 8, 2, 6, 9, 9, 6, 10, 7, 2, 7, 1, 10, 8, 6, 2, 10, 6, 8, 4, 3, 3, 9, 5, 9, 3, 7, 5, 10, 3, 1, 8, 10, 5, 6, 3, 8, 1, 7, 3, 1, 10, 4, 8, 1, 2, 5, 2]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))", "target": ""}
{"module": "ICPC.py", "name": "OptimalBridges:0", "notes": "Inspired by\n[ICPC 2019 Problem B: Bridges](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 3,003 characters.", "sol_bodies": ["    # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"], "sol_header": "def sol(H=60, alpha=18, beta=2, xs=[0, 10, 20, 30, 50, 80, 100, 120, 160, 190, 200], ys=[0, 30, 10, 30, 50, 40, 10, 20, 20, 55, 10], thresh=26020):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[int], H=60, alpha=18, beta=2, xs=[0, 10, 20, 30, 50, 80, 100, 120, 160, 190, 200], ys=[0, 30, 10, 30, 50, 40, 10, 20, 20, 55, 10], thresh=26020):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh", "input": "def sat(indices: List[int], H=60, alpha=18, beta=2, xs=[0, 10, 20, 30, 50, 80, 100, 120, 160, 190, 200], ys=[0, 30, 10, 30, 50, 40, 10, 20, 20, 55, 10], thresh=26020):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh", "target": ""}
{"module": "ICPC.py", "name": "OptimalBridges:1", "notes": "Inspired by\n[ICPC 2019 Problem B: Bridges](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 3,003 characters.", "sol_bodies": ["    # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"], "sol_header": "def sol(H=100000, alpha=17, beta=6, xs=[0, 3069, 5319, 5373, 5466, 5479, 5519, 6629, 9652, 9919, 11009, 11175, 11348, 12167, 13016, 13109, 13216, 13250, 13253, 14265, 15018, 16389, 20993, 22240, 23259, 23276, 23410, 25158, 27034, 30140, 31404, 31521, 31619, 31683, 31692, 31705, 34207, 55515, 64781, 71416, 76305, 77516, 81021, 85257, 85806, 86243, 91008, 97806, 100000], ys=[81112, 12485, 94379, 88854, 987, 76485, 42941, 64723, 81743, 86552, 93967, 41028, 583, 23986, 45831, 34204, 5856, 40242, 63968, 6777, 16745, 36621, 70993, 45840, 41901, 19003, 56321, 76109, 36482, 43746, 94401, 24752, 56908, 76875, 59498, 38391, 6693, 23419, 73740, 47413, 27170, 34095, 80071, 53942, 76129, 80538, 44026, 72982, 75701], thresh=4786941056):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[int], H=100000, alpha=17, beta=6, xs=[0, 3069, 5319, 5373, 5466, 5479, 5519, 6629, 9652, 9919, 11009, 11175, 11348, 12167, 13016, 13109, 13216, 13250, 13253, 14265, 15018, 16389, 20993, 22240, 23259, 23276, 23410, 25158, 27034, 30140, 31404, 31521, 31619, 31683, 31692, 31705, 34207, 55515, 64781, 71416, 76305, 77516, 81021, 85257, 85806, 86243, 91008, 97806, 100000], ys=[81112, 12485, 94379, 88854, 987, 76485, 42941, 64723, 81743, 86552, 93967, 41028, 583, 23986, 45831, 34204, 5856, 40242, 63968, 6777, 16745, 36621, 70993, 45840, 41901, 19003, 56321, 76109, 36482, 43746, 94401, 24752, 56908, 76875, 59498, 38391, 6693, 23419, 73740, 47413, 27170, 34095, 80071, 53942, 76129, 80538, 44026, 72982, 75701], thresh=4786941056):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh", "input": "def sat(indices: List[int], H=100000, alpha=17, beta=6, xs=[0, 3069, 5319, 5373, 5466, 5479, 5519, 6629, 9652, 9919, 11009, 11175, 11348, 12167, 13016, 13109, 13216, 13250, 13253, 14265, 15018, 16389, 20993, 22240, 23259, 23276, 23410, 25158, 27034, 30140, 31404, 31521, 31619, 31683, 31692, 31705, 34207, 55515, 64781, 71416, 76305, 77516, 81021, 85257, 85806, 86243, 91008, 97806, 100000], ys=[81112, 12485, 94379, 88854, 987, 76485, 42941, 64723, 81743, 86552, 93967, 41028, 583, 23986, 45831, 34204, 5856, 40242, 63968, 6777, 16745, 36621, 70993, 45840, 41901, 19003, 56321, 76109, 36482, 43746, 94401, 24752, 56908, 76875, 59498, 38391, 6693, 23419, 73740, 47413, 27170, 34095, 80071, 53942, 76129, 80538, 44026, 72982, 75701], thresh=4786941056):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh", "target": ""}
{"module": "ICPC.py", "name": "OptimalBridges:2", "notes": "Inspired by\n[ICPC 2019 Problem B: Bridges](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 3,003 characters.", "sol_bodies": ["    # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"], "sol_header": "def sol(H=100000, alpha=21, beta=40, xs=[0, 8094, 57578, 62776, 83547, 87398, 95828, 100000], ys=[14832, 27072, 77311, 50782, 82688, 11061, 50767, 3696], thresh=143624404582):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[int], H=100000, alpha=21, beta=40, xs=[0, 8094, 57578, 62776, 83547, 87398, 95828, 100000], ys=[14832, 27072, 77311, 50782, 82688, 11061, 50767, 3696], thresh=143624404582):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh", "input": "def sat(indices: List[int], H=100000, alpha=21, beta=40, xs=[0, 8094, 57578, 62776, 83547, 87398, 95828, 100000], ys=[14832, 27072, 77311, 50782, 82688, 11061, 50767, 3696], thresh=143624404582):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh", "target": ""}
{"module": "ICPC.py", "name": "OptimalBridges:3", "notes": "Inspired by\n[ICPC 2019 Problem B: Bridges](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 3,003 characters.", "sol_bodies": ["    # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"], "sol_header": "def sol(H=100000, alpha=975, beta=546, xs=[0, 102, 174, 281, 458, 554, 583, 590, 646, 1592, 1795, 1805, 1835, 1839, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1843, 2357, 2683, 3152, 3159, 3167, 3170, 3170, 3171, 3171, 3172, 3172, 3172, 3172, 3172, 3173, 4025, 4274, 4282, 4465, 4520, 4529, 4666, 4676, 4901, 4905, 5003, 5295, 5510, 5553, 5585, 5585, 5638, 5973, 6136, 6317, 6329, 6374, 6400, 6405, 6407, 6407, 6409, 6409, 6409, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6411, 6456, 6462, 6462, 6469, 6482, 6486, 6881, 6919, 7240, 7510, 7599, 7995, 8173, 8249, 8284, 8296, 8298, 8298, 8299, 8301, 8427, 8701, 8751, 8945, 9141, 9166, 9208, 9308, 9321, 9327, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9333, 10630, 11062, 11173, 11286, 11294, 11319, 11322, 11367, 11372, 11376, 11398, 11399, 11403, 11409, 11451, 11459, 11519, 11660, 11687, 11691, 11694, 11694, 11697, 12232, 12313, 12314, 12316, 12321, 12322, 12322, 12322, 12323, 13101, 13207, 13274, 13445, 13512, 13687, 13911, 13987, 14251, 14255, 14306, 14570, 14594, 14606, 14606, 14608, 14998, 15232, 15237, 15633, 15795, 15831, 15991, 16176, 16179, 16189, 16228, 16339, 16450, 16540, 16777, 16851, 16889, 17291, 17694, 18333, 18356, 19390, 19449, 19454, 19750, 20562, 22013, 22332, 22374, 22591, 23234, 23276, 23281, 23296, 23351, 23397, 23762, 23844, 23859, 23866, 23894, 23943, 24311, 24379, 24958, 25140, 25160, 25178, 25211, 25219, 25235, 25378, 25929, 26078, 26181, 26474, 26804, 26821, 26838, 26843, 26858, 26894, 26894, 26894, 26895, 27181, 27302, 27329, 27365, 27374, 27380, 27381, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27383, 27386, 27418, 27450, 27463, 27525, 27529, 27552, 27559, 27562, 27562, 27563, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27565, 27721, 27801, 27818, 27882, 28083, 28148, 28673, 29079, 29102, 29155, 29158, 29162, 29193, 29256, 29576, 29991, 29992, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29997, 30025, 30083, 30088, 30146, 30173, 30182, 30305, 30408, 30596, 30905, 31000, 31405, 31558, 31588, 31663, 31664, 31664, 31667, 31670, 31674, 31676, 31703, 32815, 32821, 32949, 33977, 34036, 34403, 34413, 34464, 34505, 34509, 34511, 34772, 34972, 35021, 35068, 35259, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35273, 35311, 35343, 35611, 35950, 36192, 36400, 36410, 36622, 36820, 36883, 36959, 36960, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36964, 37010, 37035, 37311, 37660, 37733, 37934, 38287, 38539, 39425, 39441, 39473, 40033, 40124, 40319, 40609, 40643, 40673, 40727, 40741, 40742, 40744, 40750, 41021, 41080, 41311, 41319, 41321, 41335, 41344, 41344, 41345, 41345, 41345, 41345, 41345, 41346, 41532, 41554, 42011, 42164, 42187, 42276, 42566, 42675, 43393, 43473, 43480, 43504, 43504, 43504, 43504, 43504, 43505, 44026, 44718, 45006, 45128, 45193, 45581, 45643, 45679, 45684, 45687, 45858, 45958, 46022, 46126, 46367, 46712, 46849, 47743, 47968, 48262, 49272, 49376, 50058, 50436, 51804, 51966, 52122, 52374, 53401, 53638, 54722, 55797, 55906, 56812, 56839, 57005, 58384, 58720, 58959, 59074, 59209, 59512, 59785, 60798, 61136, 61198, 61505, 62052, 62540, 62555, 62783, 63241, 63829, 64155, 64422, 64520, 65271, 65297, 67452, 67628, 68258, 68379, 69233, 69496, 69613, 69774, 70090, 70092, 70759, 70770, 70809, 71196, 71265, 71529, 72250, 72476, 72523, 72556, 72829, 73209, 73477, 73739, 73843, 74249, 74728, 74988, 75425, 75988, 76032, 76096, 76152, 76222, 76751, 77227, 77631, 77995, 78061, 78169, 78400, 78784, 79499, 80385, 80551, 80627, 80660, 81059, 81143, 81405, 81665, 82904, 83595, 83957, 83996, 84043, 84739, 85031, 85987, 86319, 86864, 86933, 86947, 87127, 87520, 87543, 87848, 88057, 88437, 89195, 89401, 90469, 90756, 90761, 91175, 91975, 92907, 92987, 94337, 94470, 95290, 96267, 96378, 96635, 97113, 97608, 97663, 97721, 98148, 98536, 98629, 98960, 99036, 99763, 99793, 100000], ys=[2773, 47376, 17008, 24785, 21921, 60359, 33137, 72146, 76002, 49654, 25696, 25832, 72474, 2917, 18229, 2385, 66151, 51868, 4760, 69187, 67221, 14320, 24425, 88890, 24553, 78751, 70869, 11279, 12625, 84959, 28885, 87499, 61816, 41222, 81997, 1265, 63632, 12863, 54939, 56081, 35629, 37122, 49133, 24893, 41731, 9182, 34407, 90952, 42360, 43861, 99296, 80331, 78826, 19484, 90699, 30578, 71697, 10304, 61318, 89870, 38599, 71160, 22805, 17850, 60106, 76742, 14571, 74280, 88847, 53537, 84726, 7279, 55376, 47707, 78111, 14855, 20855, 89936, 20706, 98672, 5385, 76357, 90172, 48891, 6243, 82298, 64602, 99637, 83220, 87261, 26190, 39457, 12610, 44567, 54545, 71246, 96608, 5086, 65811, 15907, 21012, 17278, 1139, 54815, 52416, 19440, 44857, 16066, 22379, 73573, 36087, 54255, 60304, 30497, 1202, 95520, 48378, 68296, 14032, 50456, 60555, 80390, 70975, 17531, 3761, 46399, 48927, 96320, 79008, 25360, 67058, 26409, 29891, 324, 67141, 24534, 69987, 11711, 99837, 82260, 8818, 67647, 66046, 76727, 25049, 48694, 96244, 42767, 13120, 53729, 90754, 47498, 40257, 7844, 79665, 35900, 33567, 80332, 68427, 29914, 91621, 38959, 35796, 7435, 65460, 434, 2785, 4710, 80793, 20827, 22155, 90320, 5066, 24178, 18875, 51294, 5222, 95816, 14268, 68478, 96761, 66479, 67335, 51513, 78673, 73143, 11679, 85300, 88785, 1004, 18064, 91085, 18999, 25640, 45379, 74924, 94706, 46916, 32682, 31715, 3086, 49466, 85098, 49913, 44647, 82331, 27219, 13875, 58769, 3667, 10298, 44795, 62204, 21497, 58731, 12965, 62569, 72238, 49525, 22899, 84200, 3845, 98178, 924, 35984, 32417, 22686, 22620, 47458, 87867, 29566, 77085, 10960, 14876, 89730, 21641, 13636, 79167, 53472, 30103, 56335, 39274, 74071, 68958, 66408, 47354, 84728, 28113, 99860, 49955, 79844, 1186, 85981, 39037, 60464, 80363, 89186, 92541, 16343, 48363, 7581, 73306, 68325, 65829, 84163, 74355, 53786, 58715, 98906, 39439, 27860, 76391, 76589, 39834, 27137, 81688, 64132, 49120, 56144, 86941, 95518, 72009, 82728, 96067, 97712, 79469, 44330, 67454, 39941, 97408, 58132, 5066, 93590, 77162, 72882, 39621, 31441, 23172, 65710, 88436, 34469, 86816, 9665, 5643, 68076, 70549, 80805, 94994, 91769, 84542, 62168, 74918, 61406, 45287, 5793, 54563, 3652, 92584, 61367, 28505, 30248, 20120, 86422, 81094, 83631, 58464, 55958, 40896, 81384, 55062, 40915, 58556, 32091, 34368, 54084, 77250, 25828, 15620, 90399, 20250, 73405, 26695, 2032, 83486, 95048, 94554, 30946, 28573, 74157, 43422, 85194, 47436, 36847, 40337, 44865, 44811, 69652, 13169, 41240, 48298, 72630, 51768, 49849, 81558, 51868, 75819, 14511, 36733, 35093, 77864, 36881, 97122, 60008, 48465, 10154, 94832, 12514, 47840, 15591, 65517, 68261, 63597, 80341, 6530, 76786, 97631, 2526, 47318, 83685, 23732, 20477, 36378, 4066, 79691, 93070, 83021, 37168, 52019, 85092, 72854, 20879, 55104, 61225, 87611, 84521, 9011, 27496, 39666, 61677, 49131, 80714, 29320, 98393, 71579, 39547, 34736, 99974, 53333, 26106, 50745, 92975, 84628, 24607, 5133, 38793, 24284, 43324, 50981, 51005, 22088, 10404, 59675, 84882, 52975, 94861, 17852, 74017, 42533, 53763, 1986, 59478, 96769, 77976, 58875, 25744, 68724, 10130, 52144, 73428, 10610, 97509, 64410, 37812, 59809, 8455, 65712, 89789, 87542, 22274, 94253, 59627, 42450, 26524, 12018, 35043, 27433, 94055, 79108, 64297, 39011, 68974, 69586, 87982, 71372, 62430, 43056, 15425, 80083, 68963, 38661, 45853, 44335, 71876, 28982, 2264, 61889, 6454, 58072, 242, 93781, 71755, 66290, 90497, 54071, 55444, 64765, 4058, 79429, 41630, 15024, 64603, 98934, 48326, 56618, 55522, 37470, 57495, 31975, 70970, 31709, 31945, 64378, 12831, 51921, 76994, 31476, 72360, 63265, 35422, 88813, 58864, 74401, 91076, 37836, 55027, 95549, 15618, 34969, 60039, 61528, 3321, 94087, 37316, 81288, 81268, 71368, 95150, 57625, 34979, 60444, 45713, 87417, 17729, 30256, 98375, 2527, 95619, 71929, 47741, 59345, 50186, 73234, 74055, 49179, 14980, 21318, 96240, 9917, 75849, 56534, 85371, 63765, 23611, 47419, 34402, 48943, 26048, 69611, 29375, 29430, 6553, 97428, 97806, 80481, 26953, 42600, 59032, 65854, 66035, 48964, 22269, 52171, 14513, 65468, 66339, 25356, 52393, 7853, 24853, 78187, 83930, 67307, 45091, 41518, 52101, 76047, 40529, 36318, 3755, 62784, 77519, 22200, 70689, 33135, 81934, 72265, 2971, 91369, 53872, 45818, 57790, 21607, 66120, 26696, 92619, 47305, 65861, 60602, 66559, 2054, 57820, 19261, 6596, 56435, 12167, 29581, 17598, 1729, 77111, 26411, 66914, 14722, 39615, 27758, 96587, 69153, 65407, 65952, 52604, 28856, 58297, 94511, 71028, 75000, 60829, 12334, 21754, 20048, 5488, 11184, 80078, 64552, 23655, 75130, 79850, 40299, 92970, 89686, 72265, 49906, 84405, 90304, 74509, 97608, 32383, 77555, 89457, 96493, 25090, 79130, 5238, 44242, 54197, 87027, 77862, 44899, 39596, 50314, 66002, 34789, 83144, 62992, 9580, 89205, 9252, 54862, 53171, 64280, 13361, 17974, 66583, 40129, 4768, 25940, 96021, 80579, 7235, 63726, 87348, 21304, 86007, 94534, 57733, 43068, 31145, 34295, 12128, 97580, 83653, 28797, 69504, 29790, 73946, 59341, 48155, 1463, 80083, 32469, 71782, 20850, 96205, 42015, 73041, 55026, 56528, 41902, 12404, 62462, 81533, 16708, 7415, 68387, 80571, 32027, 35225, 10946, 94144, 4194, 43504, 49796, 50362, 95023, 52994, 95205, 36035, 71247, 41720, 6865, 17427, 36924, 61894, 38538, 67742, 44575, 14625, 79002, 90627, 8841, 84462, 7945, 24927, 82064, 46459, 52759, 31226, 5657, 79441, 64942, 70601, 84159, 3713, 5819, 33208, 82518, 79984, 11805, 65691, 27461, 79491, 31649, 44872, 55358, 59545, 43403, 25937, 57129, 95086, 33073, 66761, 54601, 58418, 97317, 55033, 52664, 98134, 37723, 11301, 82638, 57741, 7107, 3684, 12886, 23805, 51818, 91767, 69982, 49206, 31880, 98404, 66281, 65126, 58401, 7132, 42216, 82869, 16032, 26488, 60581, 34013, 63817, 6519, 89872, 31855, 22997, 69212, 73604, 76079, 64953, 98735, 44812, 4732, 94488, 84054, 42787, 46869, 45010, 20732, 5560, 56309, 77803, 42883, 66324, 49402, 64847, 31627, 94225, 77195, 95635, 68166, 31386, 63128, 31631, 70432, 46143, 52182, 8113, 84606, 51625, 55982, 29418, 64146, 69813, 44592, 79603, 46634, 32362, 62318, 18402, 68531, 53415, 19852, 28919, 62513, 79532, 49718, 33065, 56835, 64306, 60638, 70658, 79161, 27512, 68976, 89331, 29937, 12813, 57173, 27550, 84813, 60721, 11582, 44931, 88702, 7688, 52433, 55498, 95194, 39528, 6913, 6693, 94386, 842, 12398, 45874, 68922, 71749, 4672, 93255, 10276, 30051, 18146, 1369, 34708, 13026, 81431, 18801, 4379, 1238, 53213, 33648, 8064, 76802, 41132, 22338, 2817, 16671, 85926, 86066, 41124, 36200, 37286, 96525, 59693, 83181, 87393, 35298, 17208, 90473, 22239, 61861, 41594, 2519, 54614, 59722, 37429, 49717, 81394, 55456, 64709, 76277, 23690, 55080, 41336, 29750, 97329, 28604, 24728, 76992, 67044, 34563, 32395, 24170, 30848, 56474, 78881, 4772, 23177, 28993, 11230, 77390, 62191, 24747, 29986, 50371, 34979, 66772, 80075, 19549, 78848, 11352, 48373, 96733, 93428, 45892, 86184, 62894, 19948, 70176, 16630, 69200, 28933, 93458, 73504, 54975, 55489, 8787, 47519, 97887, 16335], thresh=44238370995):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[int], H=100000, alpha=975, beta=546, xs=[0, 102, 174, 281, 458, 554, 583, 590, 646, 1592, 1795, 1805, 1835, 1839, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1843, 2357, 2683, 3152, 3159, 3167, 3170, 3170, 3171, 3171, 3172, 3172, 3172, 3172, 3172, 3173, 4025, 4274, 4282, 4465, 4520, 4529, 4666, 4676, 4901, 4905, 5003, 5295, 5510, 5553, 5585, 5585, 5638, 5973, 6136, 6317, 6329, 6374, 6400, 6405, 6407, 6407, 6409, 6409, 6409, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6411, 6456, 6462, 6462, 6469, 6482, 6486, 6881, 6919, 7240, 7510, 7599, 7995, 8173, 8249, 8284, 8296, 8298, 8298, 8299, 8301, 8427, 8701, 8751, 8945, 9141, 9166, 9208, 9308, 9321, 9327, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9333, 10630, 11062, 11173, 11286, 11294, 11319, 11322, 11367, 11372, 11376, 11398, 11399, 11403, 11409, 11451, 11459, 11519, 11660, 11687, 11691, 11694, 11694, 11697, 12232, 12313, 12314, 12316, 12321, 12322, 12322, 12322, 12323, 13101, 13207, 13274, 13445, 13512, 13687, 13911, 13987, 14251, 14255, 14306, 14570, 14594, 14606, 14606, 14608, 14998, 15232, 15237, 15633, 15795, 15831, 15991, 16176, 16179, 16189, 16228, 16339, 16450, 16540, 16777, 16851, 16889, 17291, 17694, 18333, 18356, 19390, 19449, 19454, 19750, 20562, 22013, 22332, 22374, 22591, 23234, 23276, 23281, 23296, 23351, 23397, 23762, 23844, 23859, 23866, 23894, 23943, 24311, 24379, 24958, 25140, 25160, 25178, 25211, 25219, 25235, 25378, 25929, 26078, 26181, 26474, 26804, 26821, 26838, 26843, 26858, 26894, 26894, 26894, 26895, 27181, 27302, 27329, 27365, 27374, 27380, 27381, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27383, 27386, 27418, 27450, 27463, 27525, 27529, 27552, 27559, 27562, 27562, 27563, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27565, 27721, 27801, 27818, 27882, 28083, 28148, 28673, 29079, 29102, 29155, 29158, 29162, 29193, 29256, 29576, 29991, 29992, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29997, 30025, 30083, 30088, 30146, 30173, 30182, 30305, 30408, 30596, 30905, 31000, 31405, 31558, 31588, 31663, 31664, 31664, 31667, 31670, 31674, 31676, 31703, 32815, 32821, 32949, 33977, 34036, 34403, 34413, 34464, 34505, 34509, 34511, 34772, 34972, 35021, 35068, 35259, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35273, 35311, 35343, 35611, 35950, 36192, 36400, 36410, 36622, 36820, 36883, 36959, 36960, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36964, 37010, 37035, 37311, 37660, 37733, 37934, 38287, 38539, 39425, 39441, 39473, 40033, 40124, 40319, 40609, 40643, 40673, 40727, 40741, 40742, 40744, 40750, 41021, 41080, 41311, 41319, 41321, 41335, 41344, 41344, 41345, 41345, 41345, 41345, 41345, 41346, 41532, 41554, 42011, 42164, 42187, 42276, 42566, 42675, 43393, 43473, 43480, 43504, 43504, 43504, 43504, 43504, 43505, 44026, 44718, 45006, 45128, 45193, 45581, 45643, 45679, 45684, 45687, 45858, 45958, 46022, 46126, 46367, 46712, 46849, 47743, 47968, 48262, 49272, 49376, 50058, 50436, 51804, 51966, 52122, 52374, 53401, 53638, 54722, 55797, 55906, 56812, 56839, 57005, 58384, 58720, 58959, 59074, 59209, 59512, 59785, 60798, 61136, 61198, 61505, 62052, 62540, 62555, 62783, 63241, 63829, 64155, 64422, 64520, 65271, 65297, 67452, 67628, 68258, 68379, 69233, 69496, 69613, 69774, 70090, 70092, 70759, 70770, 70809, 71196, 71265, 71529, 72250, 72476, 72523, 72556, 72829, 73209, 73477, 73739, 73843, 74249, 74728, 74988, 75425, 75988, 76032, 76096, 76152, 76222, 76751, 77227, 77631, 77995, 78061, 78169, 78400, 78784, 79499, 80385, 80551, 80627, 80660, 81059, 81143, 81405, 81665, 82904, 83595, 83957, 83996, 84043, 84739, 85031, 85987, 86319, 86864, 86933, 86947, 87127, 87520, 87543, 87848, 88057, 88437, 89195, 89401, 90469, 90756, 90761, 91175, 91975, 92907, 92987, 94337, 94470, 95290, 96267, 96378, 96635, 97113, 97608, 97663, 97721, 98148, 98536, 98629, 98960, 99036, 99763, 99793, 100000], ys=[2773, 47376, 17008, 24785, 21921, 60359, 33137, 72146, 76002, 49654, 25696, 25832, 72474, 2917, 18229, 2385, 66151, 51868, 4760, 69187, 67221, 14320, 24425, 88890, 24553, 78751, 70869, 11279, 12625, 84959, 28885, 87499, 61816, 41222, 81997, 1265, 63632, 12863, 54939, 56081, 35629, 37122, 49133, 24893, 41731, 9182, 34407, 90952, 42360, 43861, 99296, 80331, 78826, 19484, 90699, 30578, 71697, 10304, 61318, 89870, 38599, 71160, 22805, 17850, 60106, 76742, 14571, 74280, 88847, 53537, 84726, 7279, 55376, 47707, 78111, 14855, 20855, 89936, 20706, 98672, 5385, 76357, 90172, 48891, 6243, 82298, 64602, 99637, 83220, 87261, 26190, 39457, 12610, 44567, 54545, 71246, 96608, 5086, 65811, 15907, 21012, 17278, 1139, 54815, 52416, 19440, 44857, 16066, 22379, 73573, 36087, 54255, 60304, 30497, 1202, 95520, 48378, 68296, 14032, 50456, 60555, 80390, 70975, 17531, 3761, 46399, 48927, 96320, 79008, 25360, 67058, 26409, 29891, 324, 67141, 24534, 69987, 11711, 99837, 82260, 8818, 67647, 66046, 76727, 25049, 48694, 96244, 42767, 13120, 53729, 90754, 47498, 40257, 7844, 79665, 35900, 33567, 80332, 68427, 29914, 91621, 38959, 35796, 7435, 65460, 434, 2785, 4710, 80793, 20827, 22155, 90320, 5066, 24178, 18875, 51294, 5222, 95816, 14268, 68478, 96761, 66479, 67335, 51513, 78673, 73143, 11679, 85300, 88785, 1004, 18064, 91085, 18999, 25640, 45379, 74924, 94706, 46916, 32682, 31715, 3086, 49466, 85098, 49913, 44647, 82331, 27219, 13875, 58769, 3667, 10298, 44795, 62204, 21497, 58731, 12965, 62569, 72238, 49525, 22899, 84200, 3845, 98178, 924, 35984, 32417, 22686, 22620, 47458, 87867, 29566, 77085, 10960, 14876, 89730, 21641, 13636, 79167, 53472, 30103, 56335, 39274, 74071, 68958, 66408, 47354, 84728, 28113, 99860, 49955, 79844, 1186, 85981, 39037, 60464, 80363, 89186, 92541, 16343, 48363, 7581, 73306, 68325, 65829, 84163, 74355, 53786, 58715, 98906, 39439, 27860, 76391, 76589, 39834, 27137, 81688, 64132, 49120, 56144, 86941, 95518, 72009, 82728, 96067, 97712, 79469, 44330, 67454, 39941, 97408, 58132, 5066, 93590, 77162, 72882, 39621, 31441, 23172, 65710, 88436, 34469, 86816, 9665, 5643, 68076, 70549, 80805, 94994, 91769, 84542, 62168, 74918, 61406, 45287, 5793, 54563, 3652, 92584, 61367, 28505, 30248, 20120, 86422, 81094, 83631, 58464, 55958, 40896, 81384, 55062, 40915, 58556, 32091, 34368, 54084, 77250, 25828, 15620, 90399, 20250, 73405, 26695, 2032, 83486, 95048, 94554, 30946, 28573, 74157, 43422, 85194, 47436, 36847, 40337, 44865, 44811, 69652, 13169, 41240, 48298, 72630, 51768, 49849, 81558, 51868, 75819, 14511, 36733, 35093, 77864, 36881, 97122, 60008, 48465, 10154, 94832, 12514, 47840, 15591, 65517, 68261, 63597, 80341, 6530, 76786, 97631, 2526, 47318, 83685, 23732, 20477, 36378, 4066, 79691, 93070, 83021, 37168, 52019, 85092, 72854, 20879, 55104, 61225, 87611, 84521, 9011, 27496, 39666, 61677, 49131, 80714, 29320, 98393, 71579, 39547, 34736, 99974, 53333, 26106, 50745, 92975, 84628, 24607, 5133, 38793, 24284, 43324, 50981, 51005, 22088, 10404, 59675, 84882, 52975, 94861, 17852, 74017, 42533, 53763, 1986, 59478, 96769, 77976, 58875, 25744, 68724, 10130, 52144, 73428, 10610, 97509, 64410, 37812, 59809, 8455, 65712, 89789, 87542, 22274, 94253, 59627, 42450, 26524, 12018, 35043, 27433, 94055, 79108, 64297, 39011, 68974, 69586, 87982, 71372, 62430, 43056, 15425, 80083, 68963, 38661, 45853, 44335, 71876, 28982, 2264, 61889, 6454, 58072, 242, 93781, 71755, 66290, 90497, 54071, 55444, 64765, 4058, 79429, 41630, 15024, 64603, 98934, 48326, 56618, 55522, 37470, 57495, 31975, 70970, 31709, 31945, 64378, 12831, 51921, 76994, 31476, 72360, 63265, 35422, 88813, 58864, 74401, 91076, 37836, 55027, 95549, 15618, 34969, 60039, 61528, 3321, 94087, 37316, 81288, 81268, 71368, 95150, 57625, 34979, 60444, 45713, 87417, 17729, 30256, 98375, 2527, 95619, 71929, 47741, 59345, 50186, 73234, 74055, 49179, 14980, 21318, 96240, 9917, 75849, 56534, 85371, 63765, 23611, 47419, 34402, 48943, 26048, 69611, 29375, 29430, 6553, 97428, 97806, 80481, 26953, 42600, 59032, 65854, 66035, 48964, 22269, 52171, 14513, 65468, 66339, 25356, 52393, 7853, 24853, 78187, 83930, 67307, 45091, 41518, 52101, 76047, 40529, 36318, 3755, 62784, 77519, 22200, 70689, 33135, 81934, 72265, 2971, 91369, 53872, 45818, 57790, 21607, 66120, 26696, 92619, 47305, 65861, 60602, 66559, 2054, 57820, 19261, 6596, 56435, 12167, 29581, 17598, 1729, 77111, 26411, 66914, 14722, 39615, 27758, 96587, 69153, 65407, 65952, 52604, 28856, 58297, 94511, 71028, 75000, 60829, 12334, 21754, 20048, 5488, 11184, 80078, 64552, 23655, 75130, 79850, 40299, 92970, 89686, 72265, 49906, 84405, 90304, 74509, 97608, 32383, 77555, 89457, 96493, 25090, 79130, 5238, 44242, 54197, 87027, 77862, 44899, 39596, 50314, 66002, 34789, 83144, 62992, 9580, 89205, 9252, 54862, 53171, 64280, 13361, 17974, 66583, 40129, 4768, 25940, 96021, 80579, 7235, 63726, 87348, 21304, 86007, 94534, 57733, 43068, 31145, 34295, 12128, 97580, 83653, 28797, 69504, 29790, 73946, 59341, 48155, 1463, 80083, 32469, 71782, 20850, 96205, 42015, 73041, 55026, 56528, 41902, 12404, 62462, 81533, 16708, 7415, 68387, 80571, 32027, 35225, 10946, 94144, 4194, 43504, 49796, 50362, 95023, 52994, 95205, 36035, 71247, 41720, 6865, 17427, 36924, 61894, 38538, 67742, 44575, 14625, 79002, 90627, 8841, 84462, 7945, 24927, 82064, 46459, 52759, 31226, 5657, 79441, 64942, 70601, 84159, 3713, 5819, 33208, 82518, 79984, 11805, 65691, 27461, 79491, 31649, 44872, 55358, 59545, 43403, 25937, 57129, 95086, 33073, 66761, 54601, 58418, 97317, 55033, 52664, 98134, 37723, 11301, 82638, 57741, 7107, 3684, 12886, 23805, 51818, 91767, 69982, 49206, 31880, 98404, 66281, 65126, 58401, 7132, 42216, 82869, 16032, 26488, 60581, 34013, 63817, 6519, 89872, 31855, 22997, 69212, 73604, 76079, 64953, 98735, 44812, 4732, 94488, 84054, 42787, 46869, 45010, 20732, 5560, 56309, 77803, 42883, 66324, 49402, 64847, 31627, 94225, 77195, 95635, 68166, 31386, 63128, 31631, 70432, 46143, 52182, 8113, 84606, 51625, 55982, 29418, 64146, 69813, 44592, 79603, 46634, 32362, 62318, 18402, 68531, 53415, 19852, 28919, 62513, 79532, 49718, 33065, 56835, 64306, 60638, 70658, 79161, 27512, 68976, 89331, 29937, 12813, 57173, 27550, 84813, 60721, 11582, 44931, 88702, 7688, 52433, 55498, 95194, 39528, 6913, 6693, 94386, 842, 12398, 45874, 68922, 71749, 4672, 93255, 10276, 30051, 18146, 1369, 34708, 13026, 81431, 18801, 4379, 1238, 53213, 33648, 8064, 76802, 41132, 22338, 2817, 16671, 85926, 86066, 41124, 36200, 37286, 96525, 59693, 83181, 87393, 35298, 17208, 90473, 22239, 61861, 41594, 2519, 54614, 59722, 37429, 49717, 81394, 55456, 64709, 76277, 23690, 55080, 41336, 29750, 97329, 28604, 24728, 76992, 67044, 34563, 32395, 24170, 30848, 56474, 78881, 4772, 23177, 28993, 11230, 77390, 62191, 24747, 29986, 50371, 34979, 66772, 80075, 19549, 78848, 11352, 48373, 96733, 93428, 45892, 86184, 62894, 19948, 70176, 16630, 69200, 28933, 93458, 73504, 54975, 55489, 8787, 47519, 97887, 16335], thresh=44238370995):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh", "input": "def sat(indices: List[int], H=100000, alpha=975, beta=546, xs=[0, 102, 174, 281, 458, 554, 583, 590, 646, 1592, 1795, 1805, 1835, 1839, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1843, 2357, 2683, 3152, 3159, 3167, 3170, 3170, 3171, 3171, 3172, 3172, 3172, 3172, 3172, 3173, 4025, 4274, 4282, 4465, 4520, 4529, 4666, 4676, 4901, 4905, 5003, 5295, 5510, 5553, 5585, 5585, 5638, 5973, 6136, 6317, 6329, 6374, 6400, 6405, 6407, 6407, 6409, 6409, 6409, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6411, 6456, 6462, 6462, 6469, 6482, 6486, 6881, 6919, 7240, 7510, 7599, 7995, 8173, 8249, 8284, 8296, 8298, 8298, 8299, 8301, 8427, 8701, 8751, 8945, 9141, 9166, 9208, 9308, 9321, 9327, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9333, 10630, 11062, 11173, 11286, 11294, 11319, 11322, 11367, 11372, 11376, 11398, 11399, 11403, 11409, 11451, 11459, 11519, 11660, 11687, 11691, 11694, 11694, 11697, 12232, 12313, 12314, 12316, 12321, 12322, 12322, 12322, 12323, 13101, 13207, 13274, 13445, 13512, 13687, 13911, 13987, 14251, 14255, 14306, 14570, 14594, 14606, 14606, 14608, 14998, 15232, 15237, 15633, 15795, 15831, 15991, 16176, 16179, 16189, 16228, 16339, 16450, 16540, 16777, 16851, 16889, 17291, 17694, 18333, 18356, 19390, 19449, 19454, 19750, 20562, 22013, 22332, 22374, 22591, 23234, 23276, 23281, 23296, 23351, 23397, 23762, 23844, 23859, 23866, 23894, 23943, 24311, 24379, 24958, 25140, 25160, 25178, 25211, 25219, 25235, 25378, 25929, 26078, 26181, 26474, 26804, 26821, 26838, 26843, 26858, 26894, 26894, 26894, 26895, 27181, 27302, 27329, 27365, 27374, 27380, 27381, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27383, 27386, 27418, 27450, 27463, 27525, 27529, 27552, 27559, 27562, 27562, 27563, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27565, 27721, 27801, 27818, 27882, 28083, 28148, 28673, 29079, 29102, 29155, 29158, 29162, 29193, 29256, 29576, 29991, 29992, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29997, 30025, 30083, 30088, 30146, 30173, 30182, 30305, 30408, 30596, 30905, 31000, 31405, 31558, 31588, 31663, 31664, 31664, 31667, 31670, 31674, 31676, 31703, 32815, 32821, 32949, 33977, 34036, 34403, 34413, 34464, 34505, 34509, 34511, 34772, 34972, 35021, 35068, 35259, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35273, 35311, 35343, 35611, 35950, 36192, 36400, 36410, 36622, 36820, 36883, 36959, 36960, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36964, 37010, 37035, 37311, 37660, 37733, 37934, 38287, 38539, 39425, 39441, 39473, 40033, 40124, 40319, 40609, 40643, 40673, 40727, 40741, 40742, 40744, 40750, 41021, 41080, 41311, 41319, 41321, 41335, 41344, 41344, 41345, 41345, 41345, 41345, 41345, 41346, 41532, 41554, 42011, 42164, 42187, 42276, 42566, 42675, 43393, 43473, 43480, 43504, 43504, 43504, 43504, 43504, 43505, 44026, 44718, 45006, 45128, 45193, 45581, 45643, 45679, 45684, 45687, 45858, 45958, 46022, 46126, 46367, 46712, 46849, 47743, 47968, 48262, 49272, 49376, 50058, 50436, 51804, 51966, 52122, 52374, 53401, 53638, 54722, 55797, 55906, 56812, 56839, 57005, 58384, 58720, 58959, 59074, 59209, 59512, 59785, 60798, 61136, 61198, 61505, 62052, 62540, 62555, 62783, 63241, 63829, 64155, 64422, 64520, 65271, 65297, 67452, 67628, 68258, 68379, 69233, 69496, 69613, 69774, 70090, 70092, 70759, 70770, 70809, 71196, 71265, 71529, 72250, 72476, 72523, 72556, 72829, 73209, 73477, 73739, 73843, 74249, 74728, 74988, 75425, 75988, 76032, 76096, 76152, 76222, 76751, 77227, 77631, 77995, 78061, 78169, 78400, 78784, 79499, 80385, 80551, 80627, 80660, 81059, 81143, 81405, 81665, 82904, 83595, 83957, 83996, 84043, 84739, 85031, 85987, 86319, 86864, 86933, 86947, 87127, 87520, 87543, 87848, 88057, 88437, 89195, 89401, 90469, 90756, 90761, 91175, 91975, 92907, 92987, 94337, 94470, 95290, 96267, 96378, 96635, 97113, 97608, 97663, 97721, 98148, 98536, 98629, 98960, 99036, 99763, 99793, 100000], ys=[2773, 47376, 17008, 24785, 21921, 60359, 33137, 72146, 76002, 49654, 25696, 25832, 72474, 2917, 18229, 2385, 66151, 51868, 4760, 69187, 67221, 14320, 24425, 88890, 24553, 78751, 70869, 11279, 12625, 84959, 28885, 87499, 61816, 41222, 81997, 1265, 63632, 12863, 54939, 56081, 35629, 37122, 49133, 24893, 41731, 9182, 34407, 90952, 42360, 43861, 99296, 80331, 78826, 19484, 90699, 30578, 71697, 10304, 61318, 89870, 38599, 71160, 22805, 17850, 60106, 76742, 14571, 74280, 88847, 53537, 84726, 7279, 55376, 47707, 78111, 14855, 20855, 89936, 20706, 98672, 5385, 76357, 90172, 48891, 6243, 82298, 64602, 99637, 83220, 87261, 26190, 39457, 12610, 44567, 54545, 71246, 96608, 5086, 65811, 15907, 21012, 17278, 1139, 54815, 52416, 19440, 44857, 16066, 22379, 73573, 36087, 54255, 60304, 30497, 1202, 95520, 48378, 68296, 14032, 50456, 60555, 80390, 70975, 17531, 3761, 46399, 48927, 96320, 79008, 25360, 67058, 26409, 29891, 324, 67141, 24534, 69987, 11711, 99837, 82260, 8818, 67647, 66046, 76727, 25049, 48694, 96244, 42767, 13120, 53729, 90754, 47498, 40257, 7844, 79665, 35900, 33567, 80332, 68427, 29914, 91621, 38959, 35796, 7435, 65460, 434, 2785, 4710, 80793, 20827, 22155, 90320, 5066, 24178, 18875, 51294, 5222, 95816, 14268, 68478, 96761, 66479, 67335, 51513, 78673, 73143, 11679, 85300, 88785, 1004, 18064, 91085, 18999, 25640, 45379, 74924, 94706, 46916, 32682, 31715, 3086, 49466, 85098, 49913, 44647, 82331, 27219, 13875, 58769, 3667, 10298, 44795, 62204, 21497, 58731, 12965, 62569, 72238, 49525, 22899, 84200, 3845, 98178, 924, 35984, 32417, 22686, 22620, 47458, 87867, 29566, 77085, 10960, 14876, 89730, 21641, 13636, 79167, 53472, 30103, 56335, 39274, 74071, 68958, 66408, 47354, 84728, 28113, 99860, 49955, 79844, 1186, 85981, 39037, 60464, 80363, 89186, 92541, 16343, 48363, 7581, 73306, 68325, 65829, 84163, 74355, 53786, 58715, 98906, 39439, 27860, 76391, 76589, 39834, 27137, 81688, 64132, 49120, 56144, 86941, 95518, 72009, 82728, 96067, 97712, 79469, 44330, 67454, 39941, 97408, 58132, 5066, 93590, 77162, 72882, 39621, 31441, 23172, 65710, 88436, 34469, 86816, 9665, 5643, 68076, 70549, 80805, 94994, 91769, 84542, 62168, 74918, 61406, 45287, 5793, 54563, 3652, 92584, 61367, 28505, 30248, 20120, 86422, 81094, 83631, 58464, 55958, 40896, 81384, 55062, 40915, 58556, 32091, 34368, 54084, 77250, 25828, 15620, 90399, 20250, 73405, 26695, 2032, 83486, 95048, 94554, 30946, 28573, 74157, 43422, 85194, 47436, 36847, 40337, 44865, 44811, 69652, 13169, 41240, 48298, 72630, 51768, 49849, 81558, 51868, 75819, 14511, 36733, 35093, 77864, 36881, 97122, 60008, 48465, 10154, 94832, 12514, 47840, 15591, 65517, 68261, 63597, 80341, 6530, 76786, 97631, 2526, 47318, 83685, 23732, 20477, 36378, 4066, 79691, 93070, 83021, 37168, 52019, 85092, 72854, 20879, 55104, 61225, 87611, 84521, 9011, 27496, 39666, 61677, 49131, 80714, 29320, 98393, 71579, 39547, 34736, 99974, 53333, 26106, 50745, 92975, 84628, 24607, 5133, 38793, 24284, 43324, 50981, 51005, 22088, 10404, 59675, 84882, 52975, 94861, 17852, 74017, 42533, 53763, 1986, 59478, 96769, 77976, 58875, 25744, 68724, 10130, 52144, 73428, 10610, 97509, 64410, 37812, 59809, 8455, 65712, 89789, 87542, 22274, 94253, 59627, 42450, 26524, 12018, 35043, 27433, 94055, 79108, 64297, 39011, 68974, 69586, 87982, 71372, 62430, 43056, 15425, 80083, 68963, 38661, 45853, 44335, 71876, 28982, 2264, 61889, 6454, 58072, 242, 93781, 71755, 66290, 90497, 54071, 55444, 64765, 4058, 79429, 41630, 15024, 64603, 98934, 48326, 56618, 55522, 37470, 57495, 31975, 70970, 31709, 31945, 64378, 12831, 51921, 76994, 31476, 72360, 63265, 35422, 88813, 58864, 74401, 91076, 37836, 55027, 95549, 15618, 34969, 60039, 61528, 3321, 94087, 37316, 81288, 81268, 71368, 95150, 57625, 34979, 60444, 45713, 87417, 17729, 30256, 98375, 2527, 95619, 71929, 47741, 59345, 50186, 73234, 74055, 49179, 14980, 21318, 96240, 9917, 75849, 56534, 85371, 63765, 23611, 47419, 34402, 48943, 26048, 69611, 29375, 29430, 6553, 97428, 97806, 80481, 26953, 42600, 59032, 65854, 66035, 48964, 22269, 52171, 14513, 65468, 66339, 25356, 52393, 7853, 24853, 78187, 83930, 67307, 45091, 41518, 52101, 76047, 40529, 36318, 3755, 62784, 77519, 22200, 70689, 33135, 81934, 72265, 2971, 91369, 53872, 45818, 57790, 21607, 66120, 26696, 92619, 47305, 65861, 60602, 66559, 2054, 57820, 19261, 6596, 56435, 12167, 29581, 17598, 1729, 77111, 26411, 66914, 14722, 39615, 27758, 96587, 69153, 65407, 65952, 52604, 28856, 58297, 94511, 71028, 75000, 60829, 12334, 21754, 20048, 5488, 11184, 80078, 64552, 23655, 75130, 79850, 40299, 92970, 89686, 72265, 49906, 84405, 90304, 74509, 97608, 32383, 77555, 89457, 96493, 25090, 79130, 5238, 44242, 54197, 87027, 77862, 44899, 39596, 50314, 66002, 34789, 83144, 62992, 9580, 89205, 9252, 54862, 53171, 64280, 13361, 17974, 66583, 40129, 4768, 25940, 96021, 80579, 7235, 63726, 87348, 21304, 86007, 94534, 57733, 43068, 31145, 34295, 12128, 97580, 83653, 28797, 69504, 29790, 73946, 59341, 48155, 1463, 80083, 32469, 71782, 20850, 96205, 42015, 73041, 55026, 56528, 41902, 12404, 62462, 81533, 16708, 7415, 68387, 80571, 32027, 35225, 10946, 94144, 4194, 43504, 49796, 50362, 95023, 52994, 95205, 36035, 71247, 41720, 6865, 17427, 36924, 61894, 38538, 67742, 44575, 14625, 79002, 90627, 8841, 84462, 7945, 24927, 82064, 46459, 52759, 31226, 5657, 79441, 64942, 70601, 84159, 3713, 5819, 33208, 82518, 79984, 11805, 65691, 27461, 79491, 31649, 44872, 55358, 59545, 43403, 25937, 57129, 95086, 33073, 66761, 54601, 58418, 97317, 55033, 52664, 98134, 37723, 11301, 82638, 57741, 7107, 3684, 12886, 23805, 51818, 91767, 69982, 49206, 31880, 98404, 66281, 65126, 58401, 7132, 42216, 82869, 16032, 26488, 60581, 34013, 63817, 6519, 89872, 31855, 22997, 69212, 73604, 76079, 64953, 98735, 44812, 4732, 94488, 84054, 42787, 46869, 45010, 20732, 5560, 56309, 77803, 42883, 66324, 49402, 64847, 31627, 94225, 77195, 95635, 68166, 31386, 63128, 31631, 70432, 46143, 52182, 8113, 84606, 51625, 55982, 29418, 64146, 69813, 44592, 79603, 46634, 32362, 62318, 18402, 68531, 53415, 19852, 28919, 62513, 79532, 49718, 33065, 56835, 64306, 60638, 70658, 79161, 27512, 68976, 89331, 29937, 12813, 57173, 27550, 84813, 60721, 11582, 44931, 88702, 7688, 52433, 55498, 95194, 39528, 6913, 6693, 94386, 842, 12398, 45874, 68922, 71749, 4672, 93255, 10276, 30051, 18146, 1369, 34708, 13026, 81431, 18801, 4379, 1238, 53213, 33648, 8064, 76802, 41132, 22338, 2817, 16671, 85926, 86066, 41124, 36200, 37286, 96525, 59693, 83181, 87393, 35298, 17208, 90473, 22239, 61861, 41594, 2519, 54614, 59722, 37429, 49717, 81394, 55456, 64709, 76277, 23690, 55080, 41336, 29750, 97329, 28604, 24728, 76992, 67044, 34563, 32395, 24170, 30848, 56474, 78881, 4772, 23177, 28993, 11230, 77390, 62191, 24747, 29986, 50371, 34979, 66772, 80075, 19549, 78848, 11352, 48373, 96733, 93428, 45892, 86184, 62894, 19948, 70176, 16630, 69200, 28933, 93458, 73504, 54975, 55489, 8787, 47519, 97887, 16335], thresh=44238370995):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh", "target": ""}
{"module": "ICPC.py", "name": "OptimalBridges:4", "notes": "Inspired by\n[ICPC 2019 Problem B: Bridges](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 3,003 characters.", "sol_bodies": ["    # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"], "sol_header": "def sol(H=100000, alpha=6, beta=2, xs=[0, 75202, 97997, 100000], ys=[24586, 7488, 4413, 30235], thresh=12359929344):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"", "weight": 1.0, "sat": "def sat(indices: List[int], H=100000, alpha=6, beta=2, xs=[0, 75202, 97997, 100000], ys=[24586, 7488, 4413, 30235], thresh=12359929344):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh", "input": "def sat(indices: List[int], H=100000, alpha=6, beta=2, xs=[0, 75202, 97997, 100000], ys=[24586, 7488, 4413, 30235], thresh=12359929344):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh", "target": ""}
{"module": "IMO.py", "name": "ExponentialCoinMoves:0", "notes": "This problem has *long* answers, not that the code to solve it is long but that what the solution outputs is long.\n\nThe version below uses only 5 boxes (unlike the IMO problem with 6 boxes since 2010^2010^2010 is too big\nfor computers) but the solution is quite similar to the solution to the IMO problem. Because the solution\nrequires exponential many moves, our representation allows combining multiple Type-1 (advance) operations\ninto a single step.\n\nInspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)", "sol_bodies": ["    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"], "sol_header": "def sol(n=16385):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"", "weight": 10.0, "sat": "def sat(states: List[List[int]], n=16385):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n", "input": "def sat(states: List[List[int]], n=16385):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n", "target": ""}
{"module": "IMO.py", "name": "ExponentialCoinMoves:1", "notes": "This problem has *long* answers, not that the code to solve it is long but that what the solution outputs is long.\n\nThe version below uses only 5 boxes (unlike the IMO problem with 6 boxes since 2010^2010^2010 is too big\nfor computers) but the solution is quite similar to the solution to the IMO problem. Because the solution\nrequires exponential many moves, our representation allows combining multiple Type-1 (advance) operations\ninto a single step.\n\nInspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)", "sol_bodies": ["    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"], "sol_header": "def sol(n=1):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"", "weight": 1.0, "sat": "def sat(states: List[List[int]], n=1):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n", "input": "def sat(states: List[List[int]], n=1):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n", "target": ""}
{"module": "IMO.py", "name": "ExponentialCoinMoves:2", "notes": "This problem has *long* answers, not that the code to solve it is long but that what the solution outputs is long.\n\nThe version below uses only 5 boxes (unlike the IMO problem with 6 boxes since 2010^2010^2010 is too big\nfor computers) but the solution is quite similar to the solution to the IMO problem. Because the solution\nrequires exponential many moves, our representation allows combining multiple Type-1 (advance) operations\ninto a single step.\n\nInspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)", "sol_bodies": ["    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"], "sol_header": "def sol(n=2):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"", "weight": 1.0, "sat": "def sat(states: List[List[int]], n=2):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n", "input": "def sat(states: List[List[int]], n=2):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n", "target": ""}
{"module": "IMO.py", "name": "ExponentialCoinMoves:3", "notes": "This problem has *long* answers, not that the code to solve it is long but that what the solution outputs is long.\n\nThe version below uses only 5 boxes (unlike the IMO problem with 6 boxes since 2010^2010^2010 is too big\nfor computers) but the solution is quite similar to the solution to the IMO problem. Because the solution\nrequires exponential many moves, our representation allows combining multiple Type-1 (advance) operations\ninto a single step.\n\nInspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)", "sol_bodies": ["    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"], "sol_header": "def sol(n=4):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"", "weight": 1.0, "sat": "def sat(states: List[List[int]], n=4):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n", "input": "def sat(states: List[List[int]], n=4):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n", "target": ""}
{"module": "IMO.py", "name": "ExponentialCoinMoves:4", "notes": "This problem has *long* answers, not that the code to solve it is long but that what the solution outputs is long.\n\nThe version below uses only 5 boxes (unlike the IMO problem with 6 boxes since 2010^2010^2010 is too big\nfor computers) but the solution is quite similar to the solution to the IMO problem. Because the solution\nrequires exponential many moves, our representation allows combining multiple Type-1 (advance) operations\ninto a single step.\n\nInspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)", "sol_bodies": ["    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"], "sol_header": "def sol(n=8):", "ans_type": "List[List[int]]", "sol_docstring": "    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"", "weight": 8.0, "sat": "def sat(states: List[List[int]], n=8):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n", "input": "def sat(states: List[List[int]], n=8):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n", "target": ""}
{"module": "IMO.py", "name": "PickNearNeighbors:0", "notes": "Inspired by [IMO 2017 Problem 5](https://www.imo-official.org/problems.aspx)\n\nThe puzzle solution follows the judge's proof closely.", "sol_bodies": ["    # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"], "sol_header": "def sol(heights=[10, 2, 14, 1, 8, 19, 16, 6, 12, 3, 17, 0, 9, 18, 5, 7, 11, 13, 15, 4]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"", "weight": 1.0, "sat": "def sat(keep: List[bool], heights=[10, 2, 14, 1, 8, 19, 16, 6, 12, 3, 17, 0, 9, 18, 5, 7, 11, 13, 15, 4]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))", "input": "def sat(keep: List[bool], heights=[10, 2, 14, 1, 8, 19, 16, 6, 12, 3, 17, 0, 9, 18, 5, 7, 11, 13, 15, 4]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))", "target": ""}
{"module": "IMO.py", "name": "PickNearNeighbors:1", "notes": "Inspired by [IMO 2017 Problem 5](https://www.imo-official.org/problems.aspx)\n\nThe puzzle solution follows the judge's proof closely.", "sol_bodies": ["    # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"], "sol_header": "def sol(heights=[6, 12, 26, 4, 25, 20, 15, 14, 18, 22, 19, 23, 27, 13, 9, 28, 17, 11, 29, 7, 1, 10, 2, 0, 21, 3, 5, 8, 16, 24]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"", "weight": 1.0, "sat": "def sat(keep: List[bool], heights=[6, 12, 26, 4, 25, 20, 15, 14, 18, 22, 19, 23, 27, 13, 9, 28, 17, 11, 29, 7, 1, 10, 2, 0, 21, 3, 5, 8, 16, 24]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))", "input": "def sat(keep: List[bool], heights=[6, 12, 26, 4, 25, 20, 15, 14, 18, 22, 19, 23, 27, 13, 9, 28, 17, 11, 29, 7, 1, 10, 2, 0, 21, 3, 5, 8, 16, 24]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))", "target": ""}
{"module": "IMO.py", "name": "PickNearNeighbors:2", "notes": "Inspired by [IMO 2017 Problem 5](https://www.imo-official.org/problems.aspx)\n\nThe puzzle solution follows the judge's proof closely.", "sol_bodies": ["    # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"], "sol_header": "def sol(heights=[6, 8, 0, 7, 4, 9, 10, 1, 5, 3, 11, 2]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"", "weight": 1.0, "sat": "def sat(keep: List[bool], heights=[6, 8, 0, 7, 4, 9, 10, 1, 5, 3, 11, 2]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))", "input": "def sat(keep: List[bool], heights=[6, 8, 0, 7, 4, 9, 10, 1, 5, 3, 11, 2]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))", "target": ""}
{"module": "IMO.py", "name": "PickNearNeighbors:3", "notes": "Inspired by [IMO 2017 Problem 5](https://www.imo-official.org/problems.aspx)\n\nThe puzzle solution follows the judge's proof closely.", "sol_bodies": ["    # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"], "sol_header": "def sol(heights=[46, 61, 80, 16, 71, 32, 13, 12, 2, 75, 62, 56, 17, 28, 67, 54, 22, 27, 38, 63, 69, 84, 70, 57, 86, 72, 66, 8, 41, 3, 23, 88, 83, 58, 36, 50, 65, 30, 34, 25, 39, 20, 78, 79, 59, 4, 21, 73, 45, 37, 48, 77, 10, 44, 14, 43, 42, 0, 33, 29, 7, 52, 5, 60, 68, 9, 26, 49, 40, 76, 31, 6, 85, 74, 24, 51, 1, 89, 11, 47, 18, 19, 81, 87, 35, 64, 82, 15, 55, 53]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"", "weight": 1.0, "sat": "def sat(keep: List[bool], heights=[46, 61, 80, 16, 71, 32, 13, 12, 2, 75, 62, 56, 17, 28, 67, 54, 22, 27, 38, 63, 69, 84, 70, 57, 86, 72, 66, 8, 41, 3, 23, 88, 83, 58, 36, 50, 65, 30, 34, 25, 39, 20, 78, 79, 59, 4, 21, 73, 45, 37, 48, 77, 10, 44, 14, 43, 42, 0, 33, 29, 7, 52, 5, 60, 68, 9, 26, 49, 40, 76, 31, 6, 85, 74, 24, 51, 1, 89, 11, 47, 18, 19, 81, 87, 35, 64, 82, 15, 55, 53]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))", "input": "def sat(keep: List[bool], heights=[46, 61, 80, 16, 71, 32, 13, 12, 2, 75, 62, 56, 17, 28, 67, 54, 22, 27, 38, 63, 69, 84, 70, 57, 86, 72, 66, 8, 41, 3, 23, 88, 83, 58, 36, 50, 65, 30, 34, 25, 39, 20, 78, 79, 59, 4, 21, 73, 45, 37, 48, 77, 10, 44, 14, 43, 42, 0, 33, 29, 7, 52, 5, 60, 68, 9, 26, 49, 40, 76, 31, 6, 85, 74, 24, 51, 1, 89, 11, 47, 18, 19, 81, 87, 35, 64, 82, 15, 55, 53]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))", "target": ""}
{"module": "IMO.py", "name": "PickNearNeighbors:4", "notes": "Inspired by [IMO 2017 Problem 5](https://www.imo-official.org/problems.aspx)\n\nThe puzzle solution follows the judge's proof closely.", "sol_bodies": ["    # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"], "sol_header": "def sol(heights=[26, 11, 62, 24, 56, 80, 39, 77, 23, 86, 53, 73, 3, 44, 45, 70, 75, 0, 13, 40, 4, 87, 30, 7, 50, 34, 59, 22, 17, 41, 71, 10, 29, 89, 36, 31, 52, 9, 2, 51, 28, 61, 21, 1, 15, 72, 84, 88, 79, 19, 27, 63, 55, 83, 57, 18, 5, 12, 37, 16, 49, 8, 6, 65, 32, 20, 47, 82, 42, 33, 81, 58, 35, 67, 48, 74, 78, 85, 14, 68, 43, 25, 46, 69, 76, 64, 38, 54, 66, 60]):", "ans_type": "List[bool]", "sol_docstring": "    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"", "weight": 1.0, "sat": "def sat(keep: List[bool], heights=[26, 11, 62, 24, 56, 80, 39, 77, 23, 86, 53, 73, 3, 44, 45, 70, 75, 0, 13, 40, 4, 87, 30, 7, 50, 34, 59, 22, 17, 41, 71, 10, 29, 89, 36, 31, 52, 9, 2, 51, 28, 61, 21, 1, 15, 72, 84, 88, 79, 19, 27, 63, 55, 83, 57, 18, 5, 12, 37, 16, 49, 8, 6, 65, 32, 20, 47, 82, 42, 33, 81, 58, 35, 67, 48, 74, 78, 85, 14, 68, 43, 25, 46, 69, 76, 64, 38, 54, 66, 60]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))", "input": "def sat(keep: List[bool], heights=[26, 11, 62, 24, 56, 80, 39, 77, 23, 86, 53, 73, 3, 44, 45, 70, 75, 0, 13, 40, 4, 87, 30, 7, 50, 34, 59, 22, 17, 41, 71, 10, 29, 89, 36, 31, 52, 9, 2, 51, 28, 61, 21, 1, 15, 72, 84, 88, 79, 19, 27, 63, 55, 83, 57, 18, 5, 12, 37, 16, 49, 8, 6, 65, 32, 20, 47, 82, 42, 33, 81, 58, 35, 67, 48, 74, 78, 85, 14, 68, 43, 25, 46, 69, 76, 64, 38, 54, 66, 60]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))", "target": ""}
{"module": "IMO.py", "name": "HalfTag:0", "notes": "Inspired by [IMO 2020 Problem 3](https://www.imo-official.org/problems.aspx)", "sol_bodies": ["    n = max(tags) + 1\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"], "sol_header": "def sol(tags=[3, 0, 3, 2, 0, 1, 0, 3, 1, 1, 2, 2, 0, 2, 1, 3]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], tags=[3, 0, 3, 2, 0, 1, 0, 3, 1, 1, 2, 2, 0, 2, 1, 3]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "input": "def sat(li: List[int], tags=[3, 0, 3, 2, 0, 1, 0, 3, 1, 1, 2, 2, 0, 2, 1, 3]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "target": ""}
{"module": "IMO.py", "name": "HalfTag:1", "notes": "Inspired by [IMO 2020 Problem 3](https://www.imo-official.org/problems.aspx)", "sol_bodies": ["    n = max(tags) + 1\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"], "sol_header": "def sol(tags=[2, 3, 1, 0, 3, 3, 0, 2, 1, 3, 1, 0, 1, 2, 2, 0]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], tags=[2, 3, 1, 0, 3, 3, 0, 2, 1, 3, 1, 0, 1, 2, 2, 0]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "input": "def sat(li: List[int], tags=[2, 3, 1, 0, 3, 3, 0, 2, 1, 3, 1, 0, 1, 2, 2, 0]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "target": ""}
{"module": "IMO.py", "name": "HalfTag:2", "notes": "Inspired by [IMO 2020 Problem 3](https://www.imo-official.org/problems.aspx)", "sol_bodies": ["    n = max(tags) + 1\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"], "sol_header": "def sol(tags=[4, 1, 6, 5, 6, 4, 2, 1, 6, 2, 3, 1, 4, 6, 5, 2, 3, 5, 0, 5, 0, 3, 0, 0, 4, 2, 3, 1]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], tags=[4, 1, 6, 5, 6, 4, 2, 1, 6, 2, 3, 1, 4, 6, 5, 2, 3, 5, 0, 5, 0, 3, 0, 0, 4, 2, 3, 1]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "input": "def sat(li: List[int], tags=[4, 1, 6, 5, 6, 4, 2, 1, 6, 2, 3, 1, 4, 6, 5, 2, 3, 5, 0, 5, 0, 3, 0, 0, 4, 2, 3, 1]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "target": ""}
{"module": "IMO.py", "name": "HalfTag:3", "notes": "Inspired by [IMO 2020 Problem 3](https://www.imo-official.org/problems.aspx)", "sol_bodies": ["    n = max(tags) + 1\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"], "sol_header": "def sol(tags=[0, 2, 1, 1, 1, 1, 2, 2, 0, 0, 0, 2]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], tags=[0, 2, 1, 1, 1, 1, 2, 2, 0, 0, 0, 2]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "input": "def sat(li: List[int], tags=[0, 2, 1, 1, 1, 1, 2, 2, 0, 0, 0, 2]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "target": ""}
{"module": "IMO.py", "name": "HalfTag:4", "notes": "Inspired by [IMO 2020 Problem 3](https://www.imo-official.org/problems.aspx)", "sol_bodies": ["    n = max(tags) + 1\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"], "sol_header": "def sol(tags=[1, 2, 6, 0, 6, 2, 4, 7, 4, 0, 0, 5, 0, 3, 2, 1, 7, 5, 5, 3, 1, 7, 2, 7, 6, 6, 3, 3, 1, 4, 4, 5]):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"", "weight": 1.0, "sat": "def sat(li: List[int], tags=[1, 2, 6, 0, 6, 2, 4, 7, 4, 0, 0, 5, 0, 3, 2, 1, 7, 5, 5, 3, 1, 7, 2, 7, 6, 6, 3, 3, 1, 4, 4, 5]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "input": "def sat(li: List[int], tags=[1, 2, 6, 0, 6, 2, 4, 7, 4, 0, 0, 5, 0, 3, 2, 1, 7, 5, 5, 3, 1, 7, 2, 7, 6, 6, 3, 3, 1, 4, 4, 5]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]", "target": ""}
{"module": "number_theory.py", "name": "SmallExponentBigSolution:0", "notes": "Small exponent, big solution\n\nProblems have small b and target but solution is typically a large n.\nSome of them are really hard, for example, for `b=2, target=3`, the smallest solution is `n=4700063497`\n\nSee [Richard K. Guy \"The strong law of small numbers\", (problem 13)](https://doi.org/10.2307/2322249)", "sol_bodies": ["    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"], "sol_header": "def sol(b=2, target=5):", "ans_type": "int", "sol_docstring": "    \"\"\"Solve for n: b^n = target (mod n)\"\"\"", "weight": 1.0, "sat": "def sat(n: int, b=2, target=5):\n    return (b ** n) % n == target", "input": "def sat(n: int, b=2, target=5):\n    return (b ** n) % n == target", "target": ""}
{"module": "number_theory.py", "name": "SmallExponentBigSolution:1", "notes": "Small exponent, big solution\n\nProblems have small b and target but solution is typically a large n.\nSome of them are really hard, for example, for `b=2, target=3`, the smallest solution is `n=4700063497`\n\nSee [Richard K. Guy \"The strong law of small numbers\", (problem 13)](https://doi.org/10.2307/2322249)", "sol_bodies": [], "sol_header": "def sol(b=2, target=3):", "ans_type": "int", "sol_docstring": "    \"\"\"Solve for n: b^n = target (mod n)\"\"\"", "weight": 1.0, "sat": "def sat(n: int, b=2, target=3):\n    return (b ** n) % n == target", "input": "def sat(n: int, b=2, target=3):\n    return (b ** n) % n == target", "target": ""}
{"module": "number_theory.py", "name": "SmallExponentBigSolution:2", "notes": "Small exponent, big solution\n\nProblems have small b and target but solution is typically a large n.\nSome of them are really hard, for example, for `b=2, target=3`, the smallest solution is `n=4700063497`\n\nSee [Richard K. Guy \"The strong law of small numbers\", (problem 13)](https://doi.org/10.2307/2322249)", "sol_bodies": [], "sol_header": "def sol(b=1, target=2):", "ans_type": "int", "sol_docstring": "    \"\"\"Solve for n: b^n = target (mod n)\"\"\"", "weight": 1.0, "sat": "def sat(n: int, b=1, target=2):\n    return (b ** n) % n == target", "input": "def sat(n: int, b=1, target=2):\n    return (b ** n) % n == target", "target": ""}
{"module": "number_theory.py", "name": "SmallExponentBigSolution:3", "notes": "Small exponent, big solution\n\nProblems have small b and target but solution is typically a large n.\nSome of them are really hard, for example, for `b=2, target=3`, the smallest solution is `n=4700063497`\n\nSee [Richard K. Guy \"The strong law of small numbers\", (problem 13)](https://doi.org/10.2307/2322249)", "sol_bodies": ["    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"], "sol_header": "def sol(b=69, target=2):", "ans_type": "int", "sol_docstring": "    \"\"\"Solve for n: b^n = target (mod n)\"\"\"", "weight": 1.0, "sat": "def sat(n: int, b=69, target=2):\n    return (b ** n) % n == target", "input": "def sat(n: int, b=69, target=2):\n    return (b ** n) % n == target", "target": ""}
{"module": "number_theory.py", "name": "ThreeCubes:0", "notes": "Sum of three cubes\n\nGiven `n`, find integers `a`, `b`, `c` such that `a**3 + b**3 + c**3 = n`. This is unsolvable for `n % 9 in {4, 5}`.\nConjectured to be true for all other n, i.e., `n % 9 not in {4, 5}`.\n`a`, `b`, `c` may be positive or negative\n\nSee [wikipedia entry](https://en.wikipedia.org/wiki/Sums_of_three_cubes) or\n[Andrew R. Booker, Andrew V. Sutherland (2020). \"On a question of Mordell.\"](https://arxiv.org/abs/2007.01209)", "sol_bodies": ["    assert target % 9 not in {4, 5}\n    for i in range(20):\n        for j in range(i + 1):\n            for k in range(-20, j + 1):\n                n = i ** 3 + j ** 3 + k ** 3\n                if n == target:\n                    return [i, j, k]\n                if n == -target:\n                    return [-i, -j, -k]"], "sol_header": "def sol(target=983):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Given n, find integers a, b, c such that a^3 + b^3 + c^3 = n.\"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], target=983):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "input": "def sat(nums: List[int], target=983):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "target": ""}
{"module": "number_theory.py", "name": "ThreeCubes:1", "notes": "Sum of three cubes\n\nGiven `n`, find integers `a`, `b`, `c` such that `a**3 + b**3 + c**3 = n`. This is unsolvable for `n % 9 in {4, 5}`.\nConjectured to be true for all other n, i.e., `n % 9 not in {4, 5}`.\n`a`, `b`, `c` may be positive or negative\n\nSee [wikipedia entry](https://en.wikipedia.org/wiki/Sums_of_three_cubes) or\n[Andrew R. Booker, Andrew V. Sutherland (2020). \"On a question of Mordell.\"](https://arxiv.org/abs/2007.01209)", "sol_bodies": [], "sol_header": "def sol(target=114):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Given n, find integers a, b, c such that a^3 + b^3 + c^3 = n.\"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], target=114):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "input": "def sat(nums: List[int], target=114):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "target": ""}
{"module": "number_theory.py", "name": "ThreeCubes:2", "notes": "Sum of three cubes\n\nGiven `n`, find integers `a`, `b`, `c` such that `a**3 + b**3 + c**3 = n`. This is unsolvable for `n % 9 in {4, 5}`.\nConjectured to be true for all other n, i.e., `n % 9 not in {4, 5}`.\n`a`, `b`, `c` may be positive or negative\n\nSee [wikipedia entry](https://en.wikipedia.org/wiki/Sums_of_three_cubes) or\n[Andrew R. Booker, Andrew V. Sutherland (2020). \"On a question of Mordell.\"](https://arxiv.org/abs/2007.01209)", "sol_bodies": [], "sol_header": "def sol(target=390):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Given n, find integers a, b, c such that a^3 + b^3 + c^3 = n.\"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], target=390):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "input": "def sat(nums: List[int], target=390):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "target": ""}
{"module": "number_theory.py", "name": "ThreeCubes:3", "notes": "Sum of three cubes\n\nGiven `n`, find integers `a`, `b`, `c` such that `a**3 + b**3 + c**3 = n`. This is unsolvable for `n % 9 in {4, 5}`.\nConjectured to be true for all other n, i.e., `n % 9 not in {4, 5}`.\n`a`, `b`, `c` may be positive or negative\n\nSee [wikipedia entry](https://en.wikipedia.org/wiki/Sums_of_three_cubes) or\n[Andrew R. Booker, Andrew V. Sutherland (2020). \"On a question of Mordell.\"](https://arxiv.org/abs/2007.01209)", "sol_bodies": [], "sol_header": "def sol(target=579):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Given n, find integers a, b, c such that a^3 + b^3 + c^3 = n.\"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], target=579):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "input": "def sat(nums: List[int], target=579):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "target": ""}
{"module": "number_theory.py", "name": "ThreeCubes:4", "notes": "Sum of three cubes\n\nGiven `n`, find integers `a`, `b`, `c` such that `a**3 + b**3 + c**3 = n`. This is unsolvable for `n % 9 in {4, 5}`.\nConjectured to be true for all other n, i.e., `n % 9 not in {4, 5}`.\n`a`, `b`, `c` may be positive or negative\n\nSee [wikipedia entry](https://en.wikipedia.org/wiki/Sums_of_three_cubes) or\n[Andrew R. Booker, Andrew V. Sutherland (2020). \"On a question of Mordell.\"](https://arxiv.org/abs/2007.01209)", "sol_bodies": [], "sol_header": "def sol(target=69294):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Given n, find integers a, b, c such that a^3 + b^3 + c^3 = n.\"\"\"", "weight": 1.0, "sat": "def sat(nums: List[int], target=69294):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "input": "def sat(nums: List[int], target=69294):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target", "target": ""}
{"module": "number_theory.py", "name": "Factoring:0", "notes": "[Factoring](https://en.wikipedia.org/w/index.php?title=Integer_factorization) and\n[RSA challenge](https://en.wikipedia.org/w/index.php?title=RSA_numbers)\n\n*See class FermatComposite in codex.py for an easier composite test puzzle*\n\nThe factoring problems require one to find any nontrivial factor of n, which is equivalent to factoring by a\nsimple repetition process. Problems range from small (single-digit n) all the way to the \"RSA challenges\"\nwhich include several *unsolved* factoring problems put out by the RSA company. The challenge was closed in 2007,\nwith hundreds of thousands of dollars in unclaimed prize money for factoring their given numbers. People\ncontinue to work on them, nonetheless, and only the first 22/53 have RSA challenges have been solved thusfar.\n\nFrom Wikipedia:\n\nRSA-2048 has 617 decimal digits (2,048 bits). It is the largest of the RSA numbers and carried the largest\ncash prize for its factorization, $200,000. The RSA-2048 may not be factorizable for many years to come,\nunless considerable advances are made in integer factorization or computational power in the near future.", "sol_bodies": ["    if n % 2 == 0:\n        return 2\n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return i\n\n    assert False, \"problem defined for composite n only\""], "sol_header": "def sol(n=241864633):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a non-trivial factor of integer n\"\"\"", "weight": 1.0, "sat": "def sat(i: int, n=241864633):\n    return 1 < i < n and n % i == 0", "input": "def sat(i: int, n=241864633):\n    return 1 < i < n and n % i == 0", "target": ""}
{"module": "number_theory.py", "name": "Factoring:1", "notes": "[Factoring](https://en.wikipedia.org/w/index.php?title=Integer_factorization) and\n[RSA challenge](https://en.wikipedia.org/w/index.php?title=RSA_numbers)\n\n*See class FermatComposite in codex.py for an easier composite test puzzle*\n\nThe factoring problems require one to find any nontrivial factor of n, which is equivalent to factoring by a\nsimple repetition process. Problems range from small (single-digit n) all the way to the \"RSA challenges\"\nwhich include several *unsolved* factoring problems put out by the RSA company. The challenge was closed in 2007,\nwith hundreds of thousands of dollars in unclaimed prize money for factoring their given numbers. People\ncontinue to work on them, nonetheless, and only the first 22/53 have RSA challenges have been solved thusfar.\n\nFrom Wikipedia:\n\nRSA-2048 has 617 decimal digits (2,048 bits). It is the largest of the RSA numbers and carried the largest\ncash prize for its factorization, $200,000. The RSA-2048 may not be factorizable for many years to come,\nunless considerable advances are made in integer factorization or computational power in the near future.", "sol_bodies": ["    if n % 2 == 0:\n        return 2\n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return i\n\n    assert False, \"problem defined for composite n only\""], "sol_header": "def sol(n=16):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a non-trivial factor of integer n\"\"\"", "weight": 1.0, "sat": "def sat(i: int, n=16):\n    return 1 < i < n and n % i == 0", "input": "def sat(i: int, n=16):\n    return 1 < i < n and n % i == 0", "target": ""}
{"module": "number_theory.py", "name": "Factoring:2", "notes": "[Factoring](https://en.wikipedia.org/w/index.php?title=Integer_factorization) and\n[RSA challenge](https://en.wikipedia.org/w/index.php?title=RSA_numbers)\n\n*See class FermatComposite in codex.py for an easier composite test puzzle*\n\nThe factoring problems require one to find any nontrivial factor of n, which is equivalent to factoring by a\nsimple repetition process. Problems range from small (single-digit n) all the way to the \"RSA challenges\"\nwhich include several *unsolved* factoring problems put out by the RSA company. The challenge was closed in 2007,\nwith hundreds of thousands of dollars in unclaimed prize money for factoring their given numbers. People\ncontinue to work on them, nonetheless, and only the first 22/53 have RSA challenges have been solved thusfar.\n\nFrom Wikipedia:\n\nRSA-2048 has 617 decimal digits (2,048 bits). It is the largest of the RSA numbers and carried the largest\ncash prize for its factorization, $200,000. The RSA-2048 may not be factorizable for many years to come,\nunless considerable advances are made in integer factorization or computational power in the near future.", "sol_bodies": [], "sol_header": "def sol(n=1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a non-trivial factor of integer n\"\"\"", "weight": 1.0, "sat": "def sat(i: int, n=1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139):\n    return 1 < i < n and n % i == 0", "input": "def sat(i: int, n=1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139):\n    return 1 < i < n and n % i == 0", "target": ""}
{"module": "number_theory.py", "name": "Factoring:3", "notes": "[Factoring](https://en.wikipedia.org/w/index.php?title=Integer_factorization) and\n[RSA challenge](https://en.wikipedia.org/w/index.php?title=RSA_numbers)\n\n*See class FermatComposite in codex.py for an easier composite test puzzle*\n\nThe factoring problems require one to find any nontrivial factor of n, which is equivalent to factoring by a\nsimple repetition process. Problems range from small (single-digit n) all the way to the \"RSA challenges\"\nwhich include several *unsolved* factoring problems put out by the RSA company. The challenge was closed in 2007,\nwith hundreds of thousands of dollars in unclaimed prize money for factoring their given numbers. People\ncontinue to work on them, nonetheless, and only the first 22/53 have RSA challenges have been solved thusfar.\n\nFrom Wikipedia:\n\nRSA-2048 has 617 decimal digits (2,048 bits). It is the largest of the RSA numbers and carried the largest\ncash prize for its factorization, $200,000. The RSA-2048 may not be factorizable for many years to come,\nunless considerable advances are made in integer factorization or computational power in the near future.", "sol_bodies": [], "sol_header": "def sol(n=35794234179725868774991807832568455403003778024228226193532908190484670252364677411513516111204504060317568667):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a non-trivial factor of integer n\"\"\"", "weight": 1.0, "sat": "def sat(i: int, n=35794234179725868774991807832568455403003778024228226193532908190484670252364677411513516111204504060317568667):\n    return 1 < i < n and n % i == 0", "input": "def sat(i: int, n=35794234179725868774991807832568455403003778024228226193532908190484670252364677411513516111204504060317568667):\n    return 1 < i < n and n % i == 0", "target": ""}
{"module": "number_theory.py", "name": "Factoring:4", "notes": "[Factoring](https://en.wikipedia.org/w/index.php?title=Integer_factorization) and\n[RSA challenge](https://en.wikipedia.org/w/index.php?title=RSA_numbers)\n\n*See class FermatComposite in codex.py for an easier composite test puzzle*\n\nThe factoring problems require one to find any nontrivial factor of n, which is equivalent to factoring by a\nsimple repetition process. Problems range from small (single-digit n) all the way to the \"RSA challenges\"\nwhich include several *unsolved* factoring problems put out by the RSA company. The challenge was closed in 2007,\nwith hundreds of thousands of dollars in unclaimed prize money for factoring their given numbers. People\ncontinue to work on them, nonetheless, and only the first 22/53 have RSA challenges have been solved thusfar.\n\nFrom Wikipedia:\n\nRSA-2048 has 617 decimal digits (2,048 bits). It is the largest of the RSA numbers and carried the largest\ncash prize for its factorization, $200,000. The RSA-2048 may not be factorizable for many years to come,\nunless considerable advances are made in integer factorization or computational power in the near future.", "sol_bodies": ["    if n % 2 == 0:\n        return 2\n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return i\n\n    assert False, \"problem defined for composite n only\""], "sol_header": "def sol(n=3363):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a non-trivial factor of integer n\"\"\"", "weight": 1.0, "sat": "def sat(i: int, n=3363):\n    return 1 < i < n and n % i == 0", "input": "def sat(i: int, n=3363):\n    return 1 < i < n and n % i == 0", "target": ""}
{"module": "number_theory.py", "name": "DiscreteLog:0", "notes": "Discrete Log\n\nThe discrete logarithm problem is (given `g`, `t`, and `p`) to find n such that:\n\n`g ** n % p == t`\n\nFrom [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Discrete_logarithm_records):\n\n\"Several important algorithms in public-key cryptography base their security on the assumption\nthat the discrete logarithm problem over carefully chosen problems has no efficient solution.\"\n\nThe problem is *unsolved* in the sense that no known polynomial-time algorithm has been found.\n\nWe include McCurley's discrete log challenge from\n[Weber D., Denny T. (1998) \"The solution of McCurley's discrete log challenge.\"](https://link.springer.com/content/pdf/10.1007/BFb0055747.pdf)", "sol_bodies": ["    for n in range(p):\n        if pow(g, n, p) == t:\n            return n\n    assert False, f\"unsolvable discrete log problem g={g}, t={t}, p={p}\""], "sol_header": "def sol(g=44337, p=69337, t=38187):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"", "weight": 1.0, "sat": "def sat(n: int, g=44337, p=69337, t=38187):\n    return pow(g, n, p) == t", "input": "def sat(n: int, g=44337, p=69337, t=38187):\n    return pow(g, n, p) == t", "target": ""}
{"module": "number_theory.py", "name": "DiscreteLog:1", "notes": "Discrete Log\n\nThe discrete logarithm problem is (given `g`, `t`, and `p`) to find n such that:\n\n`g ** n % p == t`\n\nFrom [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Discrete_logarithm_records):\n\n\"Several important algorithms in public-key cryptography base their security on the assumption\nthat the discrete logarithm problem over carefully chosen problems has no efficient solution.\"\n\nThe problem is *unsolved* in the sense that no known polynomial-time algorithm has been found.\n\nWe include McCurley's discrete log challenge from\n[Weber D., Denny T. (1998) \"The solution of McCurley's discrete log challenge.\"](https://link.springer.com/content/pdf/10.1007/BFb0055747.pdf)", "sol_bodies": [], "sol_header": "def sol(g=7, p=204706270385532838059744535166974274803608394340123459695798674591526591372685229510652847339705797622075505069831043486651682279, t=127402180119973946824269244334322849749382042586931621654557735290322914679095998681860978813046595166455458144280588076766033781):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"", "weight": 1.0, "sat": "def sat(n: int, g=7, p=204706270385532838059744535166974274803608394340123459695798674591526591372685229510652847339705797622075505069831043486651682279, t=127402180119973946824269244334322849749382042586931621654557735290322914679095998681860978813046595166455458144280588076766033781):\n    return pow(g, n, p) == t", "input": "def sat(n: int, g=7, p=204706270385532838059744535166974274803608394340123459695798674591526591372685229510652847339705797622075505069831043486651682279, t=127402180119973946824269244334322849749382042586931621654557735290322914679095998681860978813046595166455458144280588076766033781):\n    return pow(g, n, p) == t", "target": ""}
{"module": "number_theory.py", "name": "DiscreteLog:2", "notes": "Discrete Log\n\nThe discrete logarithm problem is (given `g`, `t`, and `p`) to find n such that:\n\n`g ** n % p == t`\n\nFrom [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Discrete_logarithm_records):\n\n\"Several important algorithms in public-key cryptography base their security on the assumption\nthat the discrete logarithm problem over carefully chosen problems has no efficient solution.\"\n\nThe problem is *unsolved* in the sense that no known polynomial-time algorithm has been found.\n\nWe include McCurley's discrete log challenge from\n[Weber D., Denny T. (1998) \"The solution of McCurley's discrete log challenge.\"](https://link.springer.com/content/pdf/10.1007/BFb0055747.pdf)", "sol_bodies": ["    for n in range(p):\n        if pow(g, n, p) == t:\n            return n\n    assert False, f\"unsolvable discrete log problem g={g}, t={t}, p={p}\""], "sol_header": "def sol(g=13, p=21, t=1):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"", "weight": 1.0, "sat": "def sat(n: int, g=13, p=21, t=1):\n    return pow(g, n, p) == t", "input": "def sat(n: int, g=13, p=21, t=1):\n    return pow(g, n, p) == t", "target": ""}
{"module": "number_theory.py", "name": "DiscreteLog:3", "notes": "Discrete Log\n\nThe discrete logarithm problem is (given `g`, `t`, and `p`) to find n such that:\n\n`g ** n % p == t`\n\nFrom [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Discrete_logarithm_records):\n\n\"Several important algorithms in public-key cryptography base their security on the assumption\nthat the discrete logarithm problem over carefully chosen problems has no efficient solution.\"\n\nThe problem is *unsolved* in the sense that no known polynomial-time algorithm has been found.\n\nWe include McCurley's discrete log challenge from\n[Weber D., Denny T. (1998) \"The solution of McCurley's discrete log challenge.\"](https://link.springer.com/content/pdf/10.1007/BFb0055747.pdf)", "sol_bodies": [], "sol_header": "def sol(g=101873924449108026052, p=576036946901458671597, t=330515716425197141833):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"", "weight": 1.0, "sat": "def sat(n: int, g=101873924449108026052, p=576036946901458671597, t=330515716425197141833):\n    return pow(g, n, p) == t", "input": "def sat(n: int, g=101873924449108026052, p=576036946901458671597, t=330515716425197141833):\n    return pow(g, n, p) == t", "target": ""}
{"module": "number_theory.py", "name": "DiscreteLog:4", "notes": "Discrete Log\n\nThe discrete logarithm problem is (given `g`, `t`, and `p`) to find n such that:\n\n`g ** n % p == t`\n\nFrom [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Discrete_logarithm_records):\n\n\"Several important algorithms in public-key cryptography base their security on the assumption\nthat the discrete logarithm problem over carefully chosen problems has no efficient solution.\"\n\nThe problem is *unsolved* in the sense that no known polynomial-time algorithm has been found.\n\nWe include McCurley's discrete log challenge from\n[Weber D., Denny T. (1998) \"The solution of McCurley's discrete log challenge.\"](https://link.springer.com/content/pdf/10.1007/BFb0055747.pdf)", "sol_bodies": [], "sol_header": "def sol(g=1696881788, p=8006168143, t=7111327686):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"", "weight": 1.0, "sat": "def sat(n: int, g=1696881788, p=8006168143, t=7111327686):\n    return pow(g, n, p) == t", "input": "def sat(n: int, g=1696881788, p=8006168143, t=7111327686):\n    return pow(g, n, p) == t", "target": ""}
{"module": "number_theory.py", "name": "GCD17:0", "notes": "According to [this article](https://primes.utm.edu/glossary/page.php?sort=LawOfSmall), the smallest\nsolution is 8424432925592889329288197322308900672459420460792433", "sol_bodies": [], "sol_header": "def sol():", "ans_type": "int", "sol_docstring": "    \"\"\"Find n for which gcd(n^17+9, (n+1)^17+9) != 1\"\"\"", "weight": 1.0, "sat": "def sat(n: int):\n    i = n ** 17 + 9\n    j = (n + 1) ** 17 + 9\n\n    while i != 0:  # compute gcd using Euclid's algorithm\n        (i, j) = (j % i, i)\n\n    return n >= 0 and j != 1", "input": "def sat(n: int):\n    i = n ** 17 + 9\n    j = (n + 1) ** 17 + 9\n\n    while i != 0:  # compute gcd using Euclid's algorithm\n        (i, j) = (j % i, i)\n\n    return n >= 0 and j != 1", "target": ""}
{"module": "probability.py", "name": "BirthdayParadox:0", "notes": "Adaptation of the classic\n[Birthday Problem](https://en.wikipedia.org/wiki/Birthday_problem (Mathematical Problems category)).\n\nThe year length is year_len (365 is earth, while Neptune year is 60,182).", "sol_bodies": ["    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"], "sol_header": "def sol(year_len=365):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"", "weight": 1.0, "sat": "def sat(n: int, year_len=365):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len", "input": "def sat(n: int, year_len=365):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len", "target": ""}
{"module": "probability.py", "name": "BirthdayParadox:1", "notes": "Adaptation of the classic\n[Birthday Problem](https://en.wikipedia.org/wiki/Birthday_problem (Mathematical Problems category)).\n\nThe year length is year_len (365 is earth, while Neptune year is 60,182).", "sol_bodies": ["    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"], "sol_header": "def sol(year_len=60182):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"", "weight": 1.0, "sat": "def sat(n: int, year_len=60182):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len", "input": "def sat(n: int, year_len=60182):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len", "target": ""}
{"module": "probability.py", "name": "BirthdayParadox:2", "notes": "Adaptation of the classic\n[Birthday Problem](https://en.wikipedia.org/wiki/Birthday_problem (Mathematical Problems category)).\n\nThe year length is year_len (365 is earth, while Neptune year is 60,182).", "sol_bodies": ["    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"], "sol_header": "def sol(year_len=2):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"", "weight": 1.0, "sat": "def sat(n: int, year_len=2):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len", "input": "def sat(n: int, year_len=2):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len", "target": ""}
{"module": "probability.py", "name": "BirthdayParadox:3", "notes": "Adaptation of the classic\n[Birthday Problem](https://en.wikipedia.org/wiki/Birthday_problem (Mathematical Problems category)).\n\nThe year length is year_len (365 is earth, while Neptune year is 60,182).", "sol_bodies": ["    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"], "sol_header": "def sol(year_len=3):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"", "weight": 1.0, "sat": "def sat(n: int, year_len=3):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len", "input": "def sat(n: int, year_len=3):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len", "target": ""}
{"module": "probability.py", "name": "BinomialProbabilities:0", "notes": "See [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution)", "sol_bodies": ["    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"], "sol_header": "def sol(p=0.5, target_prob=0.0625):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"", "weight": 1.0, "sat": "def sat(counts: List[int], p=0.5, target_prob=0.0625):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6", "input": "def sat(counts: List[int], p=0.5, target_prob=0.0625):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6", "target": ""}
{"module": "probability.py", "name": "BinomialProbabilities:1", "notes": "See [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution)", "sol_bodies": ["    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"], "sol_header": "def sol(p=0.7588822808660473, target_prob=0.41658075878732215):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"", "weight": 1.0, "sat": "def sat(counts: List[int], p=0.7588822808660473, target_prob=0.41658075878732215):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6", "input": "def sat(counts: List[int], p=0.7588822808660473, target_prob=0.41658075878732215):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6", "target": ""}
{"module": "probability.py", "name": "BinomialProbabilities:2", "notes": "See [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution)", "sol_bodies": ["    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"], "sol_header": "def sol(p=0.6569421516251613, target_prob=0.01872902529162693):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"", "weight": 1.0, "sat": "def sat(counts: List[int], p=0.6569421516251613, target_prob=0.01872902529162693):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6", "input": "def sat(counts: List[int], p=0.6569421516251613, target_prob=0.01872902529162693):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6", "target": ""}
{"module": "probability.py", "name": "BinomialProbabilities:3", "notes": "See [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution)", "sol_bodies": ["    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"], "sol_header": "def sol(p=0.20001220211746595, target_prob=0.13419930454361995):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"", "weight": 1.0, "sat": "def sat(counts: List[int], p=0.20001220211746595, target_prob=0.13419930454361995):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6", "input": "def sat(counts: List[int], p=0.20001220211746595, target_prob=0.13419930454361995):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6", "target": ""}
{"module": "probability.py", "name": "BinomialProbabilities:4", "notes": "See [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution)", "sol_bodies": ["    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"], "sol_header": "def sol(p=0.004837079863490135, target_prob=3.5517791266002235e-13):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"", "weight": 1.0, "sat": "def sat(counts: List[int], p=0.004837079863490135, target_prob=3.5517791266002235e-13):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6", "input": "def sat(counts: List[int], p=0.004837079863490135, target_prob=3.5517791266002235e-13):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6", "target": ""}
{"module": "probability.py", "name": "ExponentialProbability:0", "notes": "See [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution)", "sol_bodies": ["    return 1 - (1 - target_prob) ** (1.0/steps)"], "sol_header": "def sol(steps=10, target_prob=0.5):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"", "weight": 1.0, "sat": "def sat(p_stop: float, steps=10, target_prob=0.5):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "input": "def sat(p_stop: float, steps=10, target_prob=0.5):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "target": ""}
{"module": "probability.py", "name": "ExponentialProbability:1", "notes": "See [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution)", "sol_bodies": ["    return 1 - (1 - target_prob) ** (1.0/steps)"], "sol_header": "def sol(steps=43, target_prob=0.2661542669448821):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"", "weight": 1.0, "sat": "def sat(p_stop: float, steps=43, target_prob=0.2661542669448821):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "input": "def sat(p_stop: float, steps=43, target_prob=0.2661542669448821):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "target": ""}
{"module": "probability.py", "name": "ExponentialProbability:2", "notes": "See [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution)", "sol_bodies": ["    return 1 - (1 - target_prob) ** (1.0/steps)"], "sol_header": "def sol(steps=91, target_prob=0.03729141037377781):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"", "weight": 1.0, "sat": "def sat(p_stop: float, steps=91, target_prob=0.03729141037377781):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "input": "def sat(p_stop: float, steps=91, target_prob=0.03729141037377781):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "target": ""}
{"module": "probability.py", "name": "ExponentialProbability:3", "notes": "See [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution)", "sol_bodies": ["    return 1 - (1 - target_prob) ** (1.0/steps)"], "sol_header": "def sol(steps=11, target_prob=0.9742781783529525):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"", "weight": 1.0, "sat": "def sat(p_stop: float, steps=11, target_prob=0.9742781783529525):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "input": "def sat(p_stop: float, steps=11, target_prob=0.9742781783529525):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "target": ""}
{"module": "probability.py", "name": "ExponentialProbability:4", "notes": "See [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution)", "sol_bodies": ["    return 1 - (1 - target_prob) ** (1.0/steps)"], "sol_header": "def sol(steps=65, target_prob=0.8318555442956944):", "ans_type": "float", "sol_docstring": "    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"", "weight": 1.0, "sat": "def sat(p_stop: float, steps=65, target_prob=0.8318555442956944):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "input": "def sat(p_stop: float, steps=65, target_prob=0.8318555442956944):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6", "target": ""}
{"module": "trivial_inverse.py", "name": "BackWorlds:0", "notes": "We provide two solutions", "sol_bodies": ["    return ' olleH'", "    # solution methods must begin with 'sol'\n    return 'Hello '[::-1]"], "sol_header": "def sol():", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string that when reversed and concatenated onto 'world' gives 'Hello world'.\"\"\"", "weight": 0.2, "sat": "def sat(s: str):\n    return s[::-1] + 'world' == 'Hello world'", "input": "def sat(s: str):\n    return s[::-1] + 'world' == 'Hello world'", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSetLen:0", "notes": "", "sol_bodies": ["    return \"a\" * (dups + 1)"], "sol_header": "def sol(dups=2021):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string with dups duplicate chars\"\"\"", "weight": 0.2, "sat": "def sat(s: str, dups=2021):\n    return len(set(s)) == len(s) - dups", "input": "def sat(s: str, dups=2021):\n    return len(set(s)) == len(s) - dups", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSetLen:1", "notes": "", "sol_bodies": ["    return \"a\" * (dups + 1)"], "sol_header": "def sol(dups=0):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string with dups duplicate chars\"\"\"", "weight": 0.2, "sat": "def sat(s: str, dups=0):\n    return len(set(s)) == len(s) - dups", "input": "def sat(s: str, dups=0):\n    return len(set(s)) == len(s) - dups", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSetLen:2", "notes": "", "sol_bodies": ["    return \"a\" * (dups + 1)"], "sol_header": "def sol(dups=1):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string with dups duplicate chars\"\"\"", "weight": 0.2, "sat": "def sat(s: str, dups=1):\n    return len(set(s)) == len(s) - dups", "input": "def sat(s: str, dups=1):\n    return len(set(s)) == len(s) - dups", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSetLen:3", "notes": "", "sol_bodies": ["    return \"a\" * (dups + 1)"], "sol_header": "def sol(dups=2):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string with dups duplicate chars\"\"\"", "weight": 0.2, "sat": "def sat(s: str, dups=2):\n    return len(set(s)) == len(s) - dups", "input": "def sat(s: str, dups=2):\n    return len(set(s)) == len(s) - dups", "target": ""}
{"module": "trivial_inverse.py", "name": "StrMul:0", "notes": "", "sol_bodies": ["    if n == 0:\n        return ''\n    return target[:len(target) // n]"], "sol_header": "def sol(target=\"foofoofoofoo\", n=2):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string which when repeated n times gives target\"\"\"", "weight": 0.2, "sat": "def sat(s: str, target=\"foofoofoofoo\", n=2):\n    return s * n == target", "input": "def sat(s: str, target=\"foofoofoofoo\", n=2):\n    return s * n == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrMul:1", "notes": "", "sol_bodies": ["    if n == 0:\n        return ''\n    return target[:len(target) // n]"], "sol_header": "def sol(target=\"biquacagegichisykbiquacagegichisykbiquacagegichisyk\", n=3):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string which when repeated n times gives target\"\"\"", "weight": 0.2, "sat": "def sat(s: str, target=\"biquacagegichisykbiquacagegichisykbiquacagegichisyk\", n=3):\n    return s * n == target", "input": "def sat(s: str, target=\"biquacagegichisykbiquacagegichisykbiquacagegichisyk\", n=3):\n    return s * n == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrMul:2", "notes": "", "sol_bodies": ["    if n == 0:\n        return ''\n    return target[:len(target) // n]"], "sol_header": "def sol(target=\"hutextogoxanithiru\", n=1):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string which when repeated n times gives target\"\"\"", "weight": 0.2, "sat": "def sat(s: str, target=\"hutextogoxanithiru\", n=1):\n    return s * n == target", "input": "def sat(s: str, target=\"hutextogoxanithiru\", n=1):\n    return s * n == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrMul:3", "notes": "", "sol_bodies": ["    if n == 0:\n        return ''\n    return target[:len(target) // n]"], "sol_header": "def sol(target=\"sisisisisisisisisisisisisisi\", n=7):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string which when repeated n times gives target\"\"\"", "weight": 0.2, "sat": "def sat(s: str, target=\"sisisisisisisisisisisisisisi\", n=7):\n    return s * n == target", "input": "def sat(s: str, target=\"sisisisisisisisisisisisisisi\", n=7):\n    return s * n == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrMul:4", "notes": "", "sol_bodies": ["    if n == 0:\n        return ''\n    return target[:len(target) // n]"], "sol_header": "def sol(target=\"fuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxe\", n=7):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string which when repeated n times gives target\"\"\"", "weight": 0.2, "sat": "def sat(s: str, target=\"fuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxe\", n=7):\n    return s * n == target", "input": "def sat(s: str, target=\"fuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxe\", n=7):\n    return s * n == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrMul2:0", "notes": "", "sol_bodies": ["    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"], "sol_header": "def sol(target=\"foofoofoofoo\", s=\"foofoo\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that s repeated n times gives target\"\"\"", "weight": 0.2, "sat": "def sat(n: int, target=\"foofoofoofoo\", s=\"foofoo\"):\n    return s * n == target", "input": "def sat(n: int, target=\"foofoofoofoo\", s=\"foofoo\"):\n    return s * n == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrMul2:1", "notes": "", "sol_bodies": ["    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"], "sol_header": "def sol(target=\"\", s=\"jan\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that s repeated n times gives target\"\"\"", "weight": 0.2, "sat": "def sat(n: int, target=\"\", s=\"jan\"):\n    return s * n == target", "input": "def sat(n: int, target=\"\", s=\"jan\"):\n    return s * n == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrMul2:2", "notes": "", "sol_bodies": ["    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"], "sol_header": "def sol(target=\"koquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyc\", s=\"koquuwibehyc\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that s repeated n times gives target\"\"\"", "weight": 0.2, "sat": "def sat(n: int, target=\"koquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyc\", s=\"koquuwibehyc\"):\n    return s * n == target", "input": "def sat(n: int, target=\"koquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyc\", s=\"koquuwibehyc\"):\n    return s * n == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrMul2:3", "notes": "", "sol_bodies": ["    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"], "sol_header": "def sol(target=\"kasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyz\", s=\"kasujyzkasujyz\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that s repeated n times gives target\"\"\"", "weight": 0.2, "sat": "def sat(n: int, target=\"kasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyz\", s=\"kasujyzkasujyz\"):\n    return s * n == target", "input": "def sat(n: int, target=\"kasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyz\", s=\"kasujyzkasujyz\"):\n    return s * n == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrMul2:4", "notes": "", "sol_bodies": ["    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"], "sol_header": "def sol(target=\"kedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuth\", s=\"kedezygijithequuthkedezygijithequuth\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find n such that s repeated n times gives target\"\"\"", "weight": 0.2, "sat": "def sat(n: int, target=\"kedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuth\", s=\"kedezygijithequuthkedezygijithequuth\"):\n    return s * n == target", "input": "def sat(n: int, target=\"kedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuth\", s=\"kedezygijithequuthkedezygijithequuth\"):\n    return s * n == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrAt:0", "notes": "", "sol_bodies": ["    return s.index(target)"], "sol_header": "def sol(s=\"cat\", target=\"a\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the index of target in string s\"\"\"", "weight": 0.2, "sat": "def sat(i: int, s=\"cat\", target=\"a\"):\n    return s[i] == target", "input": "def sat(i: int, s=\"cat\", target=\"a\"):\n    return s[i] == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrAt:1", "notes": "", "sol_bodies": ["    return s.index(target)"], "sol_header": "def sol(s=\"quadyquady\", target=\"a\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the index of target in string s\"\"\"", "weight": 0.2, "sat": "def sat(i: int, s=\"quadyquady\", target=\"a\"):\n    return s[i] == target", "input": "def sat(i: int, s=\"quadyquady\", target=\"a\"):\n    return s[i] == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrAt:2", "notes": "", "sol_bodies": ["    return s.index(target)"], "sol_header": "def sol(s=\"quixatextofazejate\", target=\"i\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the index of target in string s\"\"\"", "weight": 0.2, "sat": "def sat(i: int, s=\"quixatextofazejate\", target=\"i\"):\n    return s[i] == target", "input": "def sat(i: int, s=\"quixatextofazejate\", target=\"i\"):\n    return s[i] == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrAt:3", "notes": "", "sol_bodies": ["    return s.index(target)"], "sol_header": "def sol(s=\"thethe\", target=\"e\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the index of target in string s\"\"\"", "weight": 0.2, "sat": "def sat(i: int, s=\"thethe\", target=\"e\"):\n    return s[i] == target", "input": "def sat(i: int, s=\"thethe\", target=\"e\"):\n    return s[i] == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrAt:4", "notes": "", "sol_bodies": ["    return s.index(target)"], "sol_header": "def sol(s=\"bucudibucudibucudi\", target=\"b\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the index of target in string s\"\"\"", "weight": 0.2, "sat": "def sat(i: int, s=\"bucudibucudibucudi\", target=\"b\"):\n    return s[i] == target", "input": "def sat(i: int, s=\"bucudibucudibucudi\", target=\"b\"):\n    return s[i] == target", "target": ""}
{"module": "trivial_inverse.py", "name": "StrNegAt:0", "notes": "", "sol_bodies": ["    return - (len(s) - s.index(target))"], "sol_header": "def sol(s=\"cat\", target=\"a\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the index of target in s using a negative index.\"\"\"", "weight": 0.2, "sat": "def sat(i: int, s=\"cat\", target=\"a\"):\n    return s[i] == target and i < 0", "input": "def sat(i: int, s=\"cat\", target=\"a\"):\n    return s[i] == target and i < 0", "target": ""}
{"module": "trivial_inverse.py", "name": "StrNegAt:1", "notes": "", "sol_bodies": ["    return - (len(s) - s.index(target))"], "sol_header": "def sol(s=\"ch\", target=\"c\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the index of target in s using a negative index.\"\"\"", "weight": 0.2, "sat": "def sat(i: int, s=\"ch\", target=\"c\"):\n    return s[i] == target and i < 0", "input": "def sat(i: int, s=\"ch\", target=\"c\"):\n    return s[i] == target and i < 0", "target": ""}
{"module": "trivial_inverse.py", "name": "StrNegAt:2", "notes": "", "sol_bodies": ["    return - (len(s) - s.index(target))"], "sol_header": "def sol(s=\"nydivimocuvacetext\", target=\"y\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the index of target in s using a negative index.\"\"\"", "weight": 0.2, "sat": "def sat(i: int, s=\"nydivimocuvacetext\", target=\"y\"):\n    return s[i] == target and i < 0", "input": "def sat(i: int, s=\"nydivimocuvacetext\", target=\"y\"):\n    return s[i] == target and i < 0", "target": ""}
{"module": "trivial_inverse.py", "name": "StrNegAt:3", "notes": "", "sol_bodies": ["    return - (len(s) - s.index(target))"], "sol_header": "def sol(s=\"chyxchyx\", target=\"x\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the index of target in s using a negative index.\"\"\"", "weight": 0.2, "sat": "def sat(i: int, s=\"chyxchyx\", target=\"x\"):\n    return s[i] == target and i < 0", "input": "def sat(i: int, s=\"chyxchyx\", target=\"x\"):\n    return s[i] == target and i < 0", "target": ""}
{"module": "trivial_inverse.py", "name": "StrNegAt:4", "notes": "", "sol_bodies": ["    return - (len(s) - s.index(target))"], "sol_header": "def sol(s=\"tuchuworyquofojyzusutuchuworyquofojyzusutuchuworyquofojyzusu\", target=\"h\"):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the index of target in s using a negative index.\"\"\"", "weight": 0.2, "sat": "def sat(i: int, s=\"tuchuworyquofojyzusutuchuworyquofojyzusutuchuworyquofojyzusu\", target=\"h\"):\n    return s[i] == target and i < 0", "input": "def sat(i: int, s=\"tuchuworyquofojyzusutuchuworyquofojyzusutuchuworyquofojyzusu\", target=\"h\"):\n    return s[i] == target and i < 0", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSplit:0", "notes": "", "sol_bodies": ["    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"], "sol_header": "def sol(parts=['I', 'love', 'dumplings', '!'], length=100):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string of a given length with a certain split\"\"\"", "weight": 0.2, "sat": "def sat(x: str, parts=['I', 'love', 'dumplings', '!'], length=100):\n    return len(x) == length and x.split() == parts", "input": "def sat(x: str, parts=['I', 'love', 'dumplings', '!'], length=100):\n    return len(x) == length and x.split() == parts", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSplit:1", "notes": "", "sol_bodies": ["    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"], "sol_header": "def sol(parts=['thala', 'chaliriliq', 'chufyselikizap'], length=116):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string of a given length with a certain split\"\"\"", "weight": 0.2, "sat": "def sat(x: str, parts=['thala', 'chaliriliq', 'chufyselikizap'], length=116):\n    return len(x) == length and x.split() == parts", "input": "def sat(x: str, parts=['thala', 'chaliriliq', 'chufyselikizap'], length=116):\n    return len(x) == length and x.split() == parts", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSplit:2", "notes": "", "sol_bodies": ["    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"], "sol_header": "def sol(parts=['lepytextati', 'ki', 'fy'], length=69):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string of a given length with a certain split\"\"\"", "weight": 0.2, "sat": "def sat(x: str, parts=['lepytextati', 'ki', 'fy'], length=69):\n    return len(x) == length and x.split() == parts", "input": "def sat(x: str, parts=['lepytextati', 'ki', 'fy'], length=69):\n    return len(x) == length and x.split() == parts", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSplit:3", "notes": "", "sol_bodies": ["    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"], "sol_header": "def sol(parts=['quyhigechyhy'], length=38):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string of a given length with a certain split\"\"\"", "weight": 0.2, "sat": "def sat(x: str, parts=['quyhigechyhy'], length=38):\n    return len(x) == length and x.split() == parts", "input": "def sat(x: str, parts=['quyhigechyhy'], length=38):\n    return len(x) == length and x.split() == parts", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSplit:4", "notes": "", "sol_bodies": ["    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"], "sol_header": "def sol(parts=['je', 'pojacyda', 'papucet', 'wesobaq'], length=40):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a string of a given length with a certain split\"\"\"", "weight": 0.2, "sat": "def sat(x: str, parts=['je', 'pojacyda', 'papucet', 'wesobaq'], length=40):\n    return len(x) == length and x.split() == parts", "input": "def sat(x: str, parts=['je', 'pojacyda', 'papucet', 'wesobaq'], length=40):\n    return len(x) == length and x.split() == parts", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSplitter:0", "notes": "", "sol_bodies": ["    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"], "sol_header": "def sol(parts=['I', 'love', 'dumplings', '!', ''], string=\"I_love_dumplings_!_\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"", "weight": 0.2, "sat": "def sat(x: str, parts=['I', 'love', 'dumplings', '!', ''], string=\"I_love_dumplings_!_\"):\n    return string.split(x) == parts", "input": "def sat(x: str, parts=['I', 'love', 'dumplings', '!', ''], string=\"I_love_dumplings_!_\"):\n    return string.split(x) == parts", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSplitter:1", "notes": "", "sol_bodies": ["    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"], "sol_header": "def sol(parts=['kowot', 'quimimy'], string=\"kowottextihocavikirofegyfquimimy\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"", "weight": 0.2, "sat": "def sat(x: str, parts=['kowot', 'quimimy'], string=\"kowottextihocavikirofegyfquimimy\"):\n    return string.split(x) == parts", "input": "def sat(x: str, parts=['kowot', 'quimimy'], string=\"kowottextihocavikirofegyfquimimy\"):\n    return string.split(x) == parts", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSplitter:2", "notes": "", "sol_bodies": ["    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"], "sol_header": "def sol(parts=['f', 'thixaresiquagipoquas', 'fytylu', 'jywaxaw'], string=\"fdetthixaresiquagipoquasdetfytyludetjywaxaw\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"", "weight": 0.2, "sat": "def sat(x: str, parts=['f', 'thixaresiquagipoquas', 'fytylu', 'jywaxaw'], string=\"fdetthixaresiquagipoquasdetfytyludetjywaxaw\"):\n    return string.split(x) == parts", "input": "def sat(x: str, parts=['f', 'thixaresiquagipoquas', 'fytylu', 'jywaxaw'], string=\"fdetthixaresiquagipoquasdetfytyludetjywaxaw\"):\n    return string.split(x) == parts", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSplitter:3", "notes": "", "sol_bodies": ["    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"], "sol_header": "def sol(parts=['tibuzumurun', 'hakebixutextolonyf', 'bothuraquobara'], string=\"tibuzumurunhocyxihakebixutextolonyfhocyxibothuraquobara\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"", "weight": 0.2, "sat": "def sat(x: str, parts=['tibuzumurun', 'hakebixutextolonyf', 'bothuraquobara'], string=\"tibuzumurunhocyxihakebixutextolonyfhocyxibothuraquobara\"):\n    return string.split(x) == parts", "input": "def sat(x: str, parts=['tibuzumurun', 'hakebixutextolonyf', 'bothuraquobara'], string=\"tibuzumurunhocyxihakebixutextolonyfhocyxibothuraquobara\"):\n    return string.split(x) == parts", "target": ""}
{"module": "trivial_inverse.py", "name": "StrSplitter:4", "notes": "", "sol_bodies": ["    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"], "sol_header": "def sol(parts=['fitextu', 'chythawequeku', 'th'], string=\"fitextufyhachochythawequekufyhachoth\"):", "ans_type": "str", "sol_docstring": "    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"", "weight": 0.2, "sat": "def sat(x: str, parts=['fitextu', 'chythawequeku', 'th'], string=\"fitextufyhachochythawequekufyhachoth\"):\n    return string.split(x) == parts", "input": "def sat(x: str, parts=['fitextu', 'chythawequeku', 'th'], string=\"fitextufyhachochythawequekufyhachoth\"):\n    return string.split(x) == parts", "target": ""}
{"module": "trivial_inverse.py", "name": "ListLen:0", "notes": "", "sol_bodies": ["    return [1] * n"], "sol_header": "def sol(n=85012):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of a given length n\"\"\"", "weight": 0.2, "sat": "def sat(li: List[int], n=85012):\n    return len(li) == n", "input": "def sat(li: List[int], n=85012):\n    return len(li) == n", "target": ""}
{"module": "trivial_inverse.py", "name": "ListLen:1", "notes": "", "sol_bodies": ["    return [1] * n"], "sol_header": "def sol(n=969):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of a given length n\"\"\"", "weight": 0.2, "sat": "def sat(li: List[int], n=969):\n    return len(li) == n", "input": "def sat(li: List[int], n=969):\n    return len(li) == n", "target": ""}
{"module": "trivial_inverse.py", "name": "ListLen:2", "notes": "", "sol_bodies": ["    return [1] * n"], "sol_header": "def sol(n=7051):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of a given length n\"\"\"", "weight": 0.2, "sat": "def sat(li: List[int], n=7051):\n    return len(li) == n", "input": "def sat(li: List[int], n=7051):\n    return len(li) == n", "target": ""}
{"module": "trivial_inverse.py", "name": "ListLen:3", "notes": "", "sol_bodies": ["    return [1] * n"], "sol_header": "def sol(n=9):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of a given length n\"\"\"", "weight": 0.2, "sat": "def sat(li: List[int], n=9):\n    return len(li) == n", "input": "def sat(li: List[int], n=9):\n    return len(li) == n", "target": ""}
{"module": "trivial_inverse.py", "name": "ListLen:4", "notes": "", "sol_bodies": ["    return [1] * n"], "sol_header": "def sol(n=324):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list of a given length n\"\"\"", "weight": 0.2, "sat": "def sat(li: List[int], n=324):\n    return len(li) == n", "input": "def sat(li: List[int], n=324):\n    return len(li) == n", "target": ""}
{"module": "trivial_inverse.py", "name": "ListIndex:0", "notes": "", "sol_bodies": ["    return li[index]"], "sol_header": "def sol(li=[17, 2, 3, 9, 11, 11], index=4):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the item whose first index in li is index\"\"\"", "weight": 0.2, "sat": "def sat(item: int, li=[17, 2, 3, 9, 11, 11], index=4):\n    return li.index(item) == index", "input": "def sat(item: int, li=[17, 2, 3, 9, 11, 11], index=4):\n    return li.index(item) == index", "target": ""}
{"module": "trivial_inverse.py", "name": "ListIndex:1", "notes": "", "sol_bodies": ["    return li[index]"], "sol_header": "def sol(li=[93, -13, -56, 19], index=2):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the item whose first index in li is index\"\"\"", "weight": 0.2, "sat": "def sat(item: int, li=[93, -13, -56, 19], index=2):\n    return li.index(item) == index", "input": "def sat(item: int, li=[93, -13, -56, 19], index=2):\n    return li.index(item) == index", "target": ""}
{"module": "trivial_inverse.py", "name": "ListIndex:2", "notes": "", "sol_bodies": ["    return li[index]"], "sol_header": "def sol(li=[-79, 49, 4, -75, -66, -76, 37, -62, -35, -79, 68, 82, -11, -71, 63, -82, 22, 65], index=2):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the item whose first index in li is index\"\"\"", "weight": 0.2, "sat": "def sat(item: int, li=[-79, 49, 4, -75, -66, -76, 37, -62, -35, -79, 68, 82, -11, -71, 63, -82, 22, 65], index=2):\n    return li.index(item) == index", "input": "def sat(item: int, li=[-79, 49, 4, -75, -66, -76, 37, -62, -35, -79, 68, 82, -11, -71, 63, -82, 22, 65], index=2):\n    return li.index(item) == index", "target": ""}
{"module": "trivial_inverse.py", "name": "ListIndex:3", "notes": "", "sol_bodies": ["    return li[index]"], "sol_header": "def sol(li=[96, -61, 50, -49, -1, -23, -35], index=3):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the item whose first index in li is index\"\"\"", "weight": 0.2, "sat": "def sat(item: int, li=[96, -61, 50, -49, -1, -23, -35], index=3):\n    return li.index(item) == index", "input": "def sat(item: int, li=[96, -61, 50, -49, -1, -23, -35], index=3):\n    return li.index(item) == index", "target": ""}
{"module": "trivial_inverse.py", "name": "ListIndex:4", "notes": "", "sol_bodies": ["    return li[index]"], "sol_header": "def sol(li=[26, -90, 89], index=0):", "ans_type": "int", "sol_docstring": "    \"\"\"Find the item whose first index in li is index\"\"\"", "weight": 0.2, "sat": "def sat(item: int, li=[26, -90, 89], index=0):\n    return li.index(item) == index", "input": "def sat(item: int, li=[26, -90, 89], index=0):\n    return li.index(item) == index", "target": ""}
{"module": "trivial_inverse.py", "name": "ListIndex2:0", "notes": "", "sol_bodies": ["    return [i - 1] * index + [i]"], "sol_header": "def sol(i=29, index=10412):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list that contains i first at index index\"\"\"", "weight": 0.2, "sat": "def sat(li: List[int], i=29, index=10412):\n    return li.index(i) == index", "input": "def sat(li: List[int], i=29, index=10412):\n    return li.index(i) == index", "target": ""}
{"module": "trivial_inverse.py", "name": "ListIndex2:1", "notes": "", "sol_bodies": ["    return [i - 1] * index + [i]"], "sol_header": "def sol(i=-99167, index=48792):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list that contains i first at index index\"\"\"", "weight": 0.2, "sat": "def sat(li: List[int], i=-99167, index=48792):\n    return li.index(i) == index", "input": "def sat(li: List[int], i=-99167, index=48792):\n    return li.index(i) == index", "target": ""}
{"module": "trivial_inverse.py", "name": "ListIndex2:2", "notes": "", "sol_bodies": ["    return [i - 1] * index + [i]"], "sol_header": "def sol(i=-67679, index=87059):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list that contains i first at index index\"\"\"", "weight": 0.2, "sat": "def sat(li: List[int], i=-67679, index=87059):\n    return li.index(i) == index", "input": "def sat(li: List[int], i=-67679, index=87059):\n    return li.index(i) == index", "target": ""}
{"module": "trivial_inverse.py", "name": "ListIndex2:3", "notes": "", "sol_bodies": ["    return [i - 1] * index + [i]"], "sol_header": "def sol(i=81395, index=79231):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list that contains i first at index index\"\"\"", "weight": 0.2, "sat": "def sat(li: List[int], i=81395, index=79231):\n    return li.index(i) == index", "input": "def sat(li: List[int], i=81395, index=79231):\n    return li.index(i) == index", "target": ""}
{"module": "trivial_inverse.py", "name": "ListIndex2:4", "notes": "", "sol_bodies": ["    return [i - 1] * index + [i]"], "sol_header": "def sol(i=63344, index=1583):", "ans_type": "List[int]", "sol_docstring": "    \"\"\"Find a list that contains i first at index index\"\"\"", "weight": 0.2, "sat": "def sat(li: List[int], i=63344, index=1583):\n    return li.index(i) == index", "input": "def sat(li: List[int], i=63344, index=1583):\n    return li.index(i) == index", "target": ""}
{"module": "trivial_inverse.py", "name": "IntNegSquareRoot:0", "notes": "", "sol_bodies": ["    return -int(a ** 0.5)"], "sol_header": "def sol(a=10000200001):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a negative integer that when squared equals perfect-square a.\"\"\"", "weight": 0.2, "sat": "def sat(n: int, a=10000200001):\n    return a == n * n and n < 0", "input": "def sat(n: int, a=10000200001):\n    return a == n * n and n < 0", "target": ""}
{"module": "trivial_inverse.py", "name": "IntNegSquareRoot:1", "notes": "", "sol_bodies": ["    return -int(a ** 0.5)"], "sol_header": "def sol(a=1153723843107852129):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a negative integer that when squared equals perfect-square a.\"\"\"", "weight": 0.2, "sat": "def sat(n: int, a=1153723843107852129):\n    return a == n * n and n < 0", "input": "def sat(n: int, a=1153723843107852129):\n    return a == n * n and n < 0", "target": ""}
{"module": "trivial_inverse.py", "name": "IntNegSquareRoot:2", "notes": "", "sol_bodies": ["    return -int(a ** 0.5)"], "sol_header": "def sol(a=1940392439040171204):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a negative integer that when squared equals perfect-square a.\"\"\"", "weight": 0.2, "sat": "def sat(n: int, a=1940392439040171204):\n    return a == n * n and n < 0", "input": "def sat(n: int, a=1940392439040171204):\n    return a == n * n and n < 0", "target": ""}
{"module": "trivial_inverse.py", "name": "IntNegSquareRoot:3", "notes": "", "sol_bodies": ["    return -int(a ** 0.5)"], "sol_header": "def sol(a=1256820805863398416):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a negative integer that when squared equals perfect-square a.\"\"\"", "weight": 0.2, "sat": "def sat(n: int, a=1256820805863398416):\n    return a == n * n and n < 0", "input": "def sat(n: int, a=1256820805863398416):\n    return a == n * n and n < 0", "target": ""}
{"module": "trivial_inverse.py", "name": "IntNegSquareRoot:4", "notes": "", "sol_bodies": ["    return -int(a ** 0.5)"], "sol_header": "def sol(a=1001282815140004804):", "ans_type": "int", "sol_docstring": "    \"\"\"Find a negative integer that when squared equals perfect-square a.\"\"\"", "weight": 0.2, "sat": "def sat(n: int, a=1001282815140004804):\n    return a == n * n and n < 0", "input": "def sat(n: int, a=1001282815140004804):\n    return a == n * n and n < 0", "target": ""}
